/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.DeprecatedGetCryptoSnapshotTickerBook200Response
import org.openapitools.client.models.DeprecatedGetHistoricCryptoTrades200Response
import org.openapitools.client.models.DeprecatedGetHistoricForexQuotes200Response
import org.openapitools.client.models.DeprecatedGetHistoricStocksQuotes200Response
import org.openapitools.client.models.DeprecatedGetHistoricStocksTrades200Response
import org.openapitools.client.models.GetBenzingaV1AnalystInsights200Response
import org.openapitools.client.models.GetBenzingaV1AnalystInsights400Response
import org.openapitools.client.models.GetBenzingaV1Analysts200Response
import org.openapitools.client.models.GetBenzingaV1ConsensusRatings200Response
import org.openapitools.client.models.GetBenzingaV1Earnings200Response
import org.openapitools.client.models.GetBenzingaV1Firms200Response
import org.openapitools.client.models.GetBenzingaV1Guidance200Response
import org.openapitools.client.models.GetBenzingaV1News200Response
import org.openapitools.client.models.GetBenzingaV1Ratings200Response
import org.openapitools.client.models.GetCryptoAggregates200Response
import org.openapitools.client.models.GetCryptoEMA200Response
import org.openapitools.client.models.GetCryptoMACD200Response
import org.openapitools.client.models.GetCryptoOpenClose200Response
import org.openapitools.client.models.GetCryptoRSI200Response
import org.openapitools.client.models.GetCryptoSMA200Response
import org.openapitools.client.models.GetCryptoSnapshotDirection200Response
import org.openapitools.client.models.GetCryptoSnapshotTicker200Response
import org.openapitools.client.models.GetCryptoSnapshotTickers200Response
import org.openapitools.client.models.GetCryptoTrades200Response
import org.openapitools.client.models.GetCurrencyConversion200Response
import org.openapitools.client.models.GetEvents200Response
import org.openapitools.client.models.GetFedV1TreasuryYields200Response
import org.openapitools.client.models.GetForexQuotes200Response
import org.openapitools.client.models.GetForexSnapshotTicker200Response
import org.openapitools.client.models.GetForexSnapshotTickers200Response
import org.openapitools.client.models.GetGroupedCryptoAggregates200Response
import org.openapitools.client.models.GetGroupedStocksAggregates200Response
import org.openapitools.client.models.GetIndicesOpenClose200Response
import org.openapitools.client.models.GetIndicesSnapshot200Response
import org.openapitools.client.models.GetLastCryptoTrade200Response
import org.openapitools.client.models.GetLastCurrencyQuote200Response
import org.openapitools.client.models.GetLastOptionsTrade200Response
import org.openapitools.client.models.GetLastStocksQuote200Response
import org.openapitools.client.models.GetMarketHolidays200ResponseInner
import org.openapitools.client.models.GetMarketStatus200Response
import org.openapitools.client.models.GetOptionContract200Response
import org.openapitools.client.models.GetOptionsChain200Response
import org.openapitools.client.models.GetOptionsContract200Response
import org.openapitools.client.models.GetOptionsOpenClose200Response
import org.openapitools.client.models.GetOptionsQuotes200Response
import org.openapitools.client.models.GetOptionsTrades200Response
import org.openapitools.client.models.GetPreviousCryptoAggregates200Response
import org.openapitools.client.models.GetPreviousForexAggregates200Response
import org.openapitools.client.models.GetPreviousIndicesAggregates200Response
import org.openapitools.client.models.GetRelatedCompanies200Response
import org.openapitools.client.models.GetSnapshotSummary200Response
import org.openapitools.client.models.GetSnapshots200Response
import org.openapitools.client.models.GetStocksAggregates200Response
import org.openapitools.client.models.GetStocksQuotes200Response
import org.openapitools.client.models.GetStocksSnapshotDirection200Response
import org.openapitools.client.models.GetStocksSnapshotTicker200Response
import org.openapitools.client.models.GetStocksSnapshotTickers200Response
import org.openapitools.client.models.GetStocksTrades200Response
import org.openapitools.client.models.GetStocksV1ShortInterest200Response
import org.openapitools.client.models.GetStocksV1ShortVolume200Response
import org.openapitools.client.models.GetTicker200Response
import org.openapitools.client.models.GetTmxV1CorporateEvents200Response
import org.openapitools.client.models.ListConditions200Response
import org.openapitools.client.models.ListConditions400Response
import org.openapitools.client.models.ListDividends200Response
import org.openapitools.client.models.ListExchanges200Response
import org.openapitools.client.models.ListExchanges400Response
import org.openapitools.client.models.ListFinancials200Response
import org.openapitools.client.models.ListIPOs200Response
import org.openapitools.client.models.ListNews200Response
import org.openapitools.client.models.ListNewsPublishedUtcParameter
import org.openapitools.client.models.ListOptionsContracts200Response
import org.openapitools.client.models.ListStockSplits200Response
import org.openapitools.client.models.ListTickerTypes200Response
import org.openapitools.client.models.ListTickers200Response

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class DefaultApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://api.polygon.io")
        }
    }

    /**
     * GET /v2/snapshot/locale/global/markets/crypto/tickers/{ticker}/book
     * Ticker Full Book (L2)
     * Get the current level 2 book of a single ticker. This is the combined book from all of the exchanges. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
     * @param ticker The cryptocurrency ticker.
     * @return DeprecatedGetCryptoSnapshotTickerBook200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deprecatedGetCryptoSnapshotTickerBook(ticker: kotlin.String) : DeprecatedGetCryptoSnapshotTickerBook200Response {
        val localVarResponse = deprecatedGetCryptoSnapshotTickerBookWithHttpInfo(ticker = ticker)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DeprecatedGetCryptoSnapshotTickerBook200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/snapshot/locale/global/markets/crypto/tickers/{ticker}/book
     * Ticker Full Book (L2)
     * Get the current level 2 book of a single ticker. This is the combined book from all of the exchanges. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
     * @param ticker The cryptocurrency ticker.
     * @return ApiResponse<DeprecatedGetCryptoSnapshotTickerBook200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deprecatedGetCryptoSnapshotTickerBookWithHttpInfo(ticker: kotlin.String) : ApiResponse<DeprecatedGetCryptoSnapshotTickerBook200Response?> {
        val localVariableConfig = deprecatedGetCryptoSnapshotTickerBookRequestConfig(ticker = ticker)

        return request<Unit, DeprecatedGetCryptoSnapshotTickerBook200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deprecatedGetCryptoSnapshotTickerBook
     *
     * @param ticker The cryptocurrency ticker.
     * @return RequestConfig
     */
    fun deprecatedGetCryptoSnapshotTickerBookRequestConfig(ticker: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/snapshot/locale/global/markets/crypto/tickers/{ticker}/book".replace("{"+"ticker"+"}", encodeURIComponent(ticker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/historic/crypto/{from}/{to}/{date}
     * Historic Crypto Trades
     * Get historic trade ticks for a cryptocurrency pair. 
     * @param from The \&quot;from\&quot; symbol of the crypto pair.
     * @param to The \&quot;to\&quot; symbol of the crypto pair.
     * @param date The date/day of the historic ticks to retrieve.
     * @param offset The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results.  (optional)
     * @param limit Limit the size of the response, max 10000. (optional)
     * @return DeprecatedGetHistoricCryptoTrades200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deprecatedGetHistoricCryptoTrades(from: kotlin.String, to: kotlin.String, date: java.time.LocalDate, offset: kotlin.Int? = null, limit: kotlin.Int? = null) : DeprecatedGetHistoricCryptoTrades200Response {
        val localVarResponse = deprecatedGetHistoricCryptoTradesWithHttpInfo(from = from, to = to, date = date, offset = offset, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DeprecatedGetHistoricCryptoTrades200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/historic/crypto/{from}/{to}/{date}
     * Historic Crypto Trades
     * Get historic trade ticks for a cryptocurrency pair. 
     * @param from The \&quot;from\&quot; symbol of the crypto pair.
     * @param to The \&quot;to\&quot; symbol of the crypto pair.
     * @param date The date/day of the historic ticks to retrieve.
     * @param offset The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results.  (optional)
     * @param limit Limit the size of the response, max 10000. (optional)
     * @return ApiResponse<DeprecatedGetHistoricCryptoTrades200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deprecatedGetHistoricCryptoTradesWithHttpInfo(from: kotlin.String, to: kotlin.String, date: java.time.LocalDate, offset: kotlin.Int?, limit: kotlin.Int?) : ApiResponse<DeprecatedGetHistoricCryptoTrades200Response?> {
        val localVariableConfig = deprecatedGetHistoricCryptoTradesRequestConfig(from = from, to = to, date = date, offset = offset, limit = limit)

        return request<Unit, DeprecatedGetHistoricCryptoTrades200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deprecatedGetHistoricCryptoTrades
     *
     * @param from The \&quot;from\&quot; symbol of the crypto pair.
     * @param to The \&quot;to\&quot; symbol of the crypto pair.
     * @param date The date/day of the historic ticks to retrieve.
     * @param offset The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results.  (optional)
     * @param limit Limit the size of the response, max 10000. (optional)
     * @return RequestConfig
     */
    fun deprecatedGetHistoricCryptoTradesRequestConfig(from: kotlin.String, to: kotlin.String, date: java.time.LocalDate, offset: kotlin.Int?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/historic/crypto/{from}/{to}/{date}".replace("{"+"from"+"}", encodeURIComponent(from.toString())).replace("{"+"to"+"}", encodeURIComponent(to.toString())).replace("{"+"date"+"}", encodeURIComponent(date.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/historic/forex/{from}/{to}/{date}
     * Historic Forex Ticks
     * Get historic ticks for a forex currency pair. 
     * @param from The \&quot;from\&quot; symbol of the currency pair.  Example: For **USD/JPY** the &#x60;from&#x60; would be **USD**. 
     * @param to The \&quot;to\&quot; symbol of the currency pair.  Example: For **USD/JPY** the &#x60;to&#x60; would be **JPY**. 
     * @param date The date/day of the historic ticks to retrieve.
     * @param offset The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results.  (optional)
     * @param limit Limit the size of the response, max 10000. (optional)
     * @return DeprecatedGetHistoricForexQuotes200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deprecatedGetHistoricForexQuotes(from: kotlin.String, to: kotlin.String, date: java.time.LocalDate, offset: kotlin.Int? = null, limit: kotlin.Int? = null) : DeprecatedGetHistoricForexQuotes200Response {
        val localVarResponse = deprecatedGetHistoricForexQuotesWithHttpInfo(from = from, to = to, date = date, offset = offset, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DeprecatedGetHistoricForexQuotes200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/historic/forex/{from}/{to}/{date}
     * Historic Forex Ticks
     * Get historic ticks for a forex currency pair. 
     * @param from The \&quot;from\&quot; symbol of the currency pair.  Example: For **USD/JPY** the &#x60;from&#x60; would be **USD**. 
     * @param to The \&quot;to\&quot; symbol of the currency pair.  Example: For **USD/JPY** the &#x60;to&#x60; would be **JPY**. 
     * @param date The date/day of the historic ticks to retrieve.
     * @param offset The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results.  (optional)
     * @param limit Limit the size of the response, max 10000. (optional)
     * @return ApiResponse<DeprecatedGetHistoricForexQuotes200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deprecatedGetHistoricForexQuotesWithHttpInfo(from: kotlin.String, to: kotlin.String, date: java.time.LocalDate, offset: kotlin.Int?, limit: kotlin.Int?) : ApiResponse<DeprecatedGetHistoricForexQuotes200Response?> {
        val localVariableConfig = deprecatedGetHistoricForexQuotesRequestConfig(from = from, to = to, date = date, offset = offset, limit = limit)

        return request<Unit, DeprecatedGetHistoricForexQuotes200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deprecatedGetHistoricForexQuotes
     *
     * @param from The \&quot;from\&quot; symbol of the currency pair.  Example: For **USD/JPY** the &#x60;from&#x60; would be **USD**. 
     * @param to The \&quot;to\&quot; symbol of the currency pair.  Example: For **USD/JPY** the &#x60;to&#x60; would be **JPY**. 
     * @param date The date/day of the historic ticks to retrieve.
     * @param offset The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results.  (optional)
     * @param limit Limit the size of the response, max 10000. (optional)
     * @return RequestConfig
     */
    fun deprecatedGetHistoricForexQuotesRequestConfig(from: kotlin.String, to: kotlin.String, date: java.time.LocalDate, offset: kotlin.Int?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/historic/forex/{from}/{to}/{date}".replace("{"+"from"+"}", encodeURIComponent(from.toString())).replace("{"+"to"+"}", encodeURIComponent(to.toString())).replace("{"+"date"+"}", encodeURIComponent(date.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/ticks/stocks/nbbo/{ticker}/{date}
     * Quotes (NBBO)
     * Get NBBO quotes for a given ticker symbol on a specified date. 
     * @param ticker The ticker symbol we want quotes for.
     * @param date The date/day of the quotes to retrieve in the format YYYY-MM-DD.
     * @param timestamp The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results.  (optional)
     * @param timestampLimit The maximum timestamp allowed in the results.  (optional)
     * @param reverse Reverse the order of the results.  (optional)
     * @param limit Limit the size of the response, max 50000 and default 5000. (optional)
     * @return DeprecatedGetHistoricStocksQuotes200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deprecatedGetHistoricStocksQuotes(ticker: kotlin.String, date: java.time.LocalDate, timestamp: kotlin.Int? = null, timestampLimit: kotlin.Int? = null, reverse: kotlin.Boolean? = null, limit: kotlin.Int? = null) : DeprecatedGetHistoricStocksQuotes200Response {
        val localVarResponse = deprecatedGetHistoricStocksQuotesWithHttpInfo(ticker = ticker, date = date, timestamp = timestamp, timestampLimit = timestampLimit, reverse = reverse, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DeprecatedGetHistoricStocksQuotes200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/ticks/stocks/nbbo/{ticker}/{date}
     * Quotes (NBBO)
     * Get NBBO quotes for a given ticker symbol on a specified date. 
     * @param ticker The ticker symbol we want quotes for.
     * @param date The date/day of the quotes to retrieve in the format YYYY-MM-DD.
     * @param timestamp The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results.  (optional)
     * @param timestampLimit The maximum timestamp allowed in the results.  (optional)
     * @param reverse Reverse the order of the results.  (optional)
     * @param limit Limit the size of the response, max 50000 and default 5000. (optional)
     * @return ApiResponse<DeprecatedGetHistoricStocksQuotes200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deprecatedGetHistoricStocksQuotesWithHttpInfo(ticker: kotlin.String, date: java.time.LocalDate, timestamp: kotlin.Int?, timestampLimit: kotlin.Int?, reverse: kotlin.Boolean?, limit: kotlin.Int?) : ApiResponse<DeprecatedGetHistoricStocksQuotes200Response?> {
        val localVariableConfig = deprecatedGetHistoricStocksQuotesRequestConfig(ticker = ticker, date = date, timestamp = timestamp, timestampLimit = timestampLimit, reverse = reverse, limit = limit)

        return request<Unit, DeprecatedGetHistoricStocksQuotes200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deprecatedGetHistoricStocksQuotes
     *
     * @param ticker The ticker symbol we want quotes for.
     * @param date The date/day of the quotes to retrieve in the format YYYY-MM-DD.
     * @param timestamp The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results.  (optional)
     * @param timestampLimit The maximum timestamp allowed in the results.  (optional)
     * @param reverse Reverse the order of the results.  (optional)
     * @param limit Limit the size of the response, max 50000 and default 5000. (optional)
     * @return RequestConfig
     */
    fun deprecatedGetHistoricStocksQuotesRequestConfig(ticker: kotlin.String, date: java.time.LocalDate, timestamp: kotlin.Int?, timestampLimit: kotlin.Int?, reverse: kotlin.Boolean?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (timestampLimit != null) {
                    put("timestampLimit", listOf(timestampLimit.toString()))
                }
                if (reverse != null) {
                    put("reverse", listOf(reverse.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/ticks/stocks/nbbo/{ticker}/{date}".replace("{"+"ticker"+"}", encodeURIComponent(ticker.toString())).replace("{"+"date"+"}", encodeURIComponent(date.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/ticks/stocks/trades/{ticker}/{date}
     * Trades
     * Get trades for a given ticker symbol on a specified date. 
     * @param ticker The ticker symbol we want trades for.
     * @param date The date/day of the trades to retrieve in the format YYYY-MM-DD.
     * @param timestamp The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results.  (optional)
     * @param timestampLimit The maximum timestamp allowed in the results.  (optional)
     * @param reverse Reverse the order of the results.  (optional)
     * @param limit Limit the size of the response, max 50000 and default 5000. (optional)
     * @return DeprecatedGetHistoricStocksTrades200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deprecatedGetHistoricStocksTrades(ticker: kotlin.String, date: java.time.LocalDate, timestamp: kotlin.Int? = null, timestampLimit: kotlin.Int? = null, reverse: kotlin.Boolean? = null, limit: kotlin.Int? = null) : DeprecatedGetHistoricStocksTrades200Response {
        val localVarResponse = deprecatedGetHistoricStocksTradesWithHttpInfo(ticker = ticker, date = date, timestamp = timestamp, timestampLimit = timestampLimit, reverse = reverse, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DeprecatedGetHistoricStocksTrades200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/ticks/stocks/trades/{ticker}/{date}
     * Trades
     * Get trades for a given ticker symbol on a specified date. 
     * @param ticker The ticker symbol we want trades for.
     * @param date The date/day of the trades to retrieve in the format YYYY-MM-DD.
     * @param timestamp The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results.  (optional)
     * @param timestampLimit The maximum timestamp allowed in the results.  (optional)
     * @param reverse Reverse the order of the results.  (optional)
     * @param limit Limit the size of the response, max 50000 and default 5000. (optional)
     * @return ApiResponse<DeprecatedGetHistoricStocksTrades200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deprecatedGetHistoricStocksTradesWithHttpInfo(ticker: kotlin.String, date: java.time.LocalDate, timestamp: kotlin.Int?, timestampLimit: kotlin.Int?, reverse: kotlin.Boolean?, limit: kotlin.Int?) : ApiResponse<DeprecatedGetHistoricStocksTrades200Response?> {
        val localVariableConfig = deprecatedGetHistoricStocksTradesRequestConfig(ticker = ticker, date = date, timestamp = timestamp, timestampLimit = timestampLimit, reverse = reverse, limit = limit)

        return request<Unit, DeprecatedGetHistoricStocksTrades200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deprecatedGetHistoricStocksTrades
     *
     * @param ticker The ticker symbol we want trades for.
     * @param date The date/day of the trades to retrieve in the format YYYY-MM-DD.
     * @param timestamp The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results.  (optional)
     * @param timestampLimit The maximum timestamp allowed in the results.  (optional)
     * @param reverse Reverse the order of the results.  (optional)
     * @param limit Limit the size of the response, max 50000 and default 5000. (optional)
     * @return RequestConfig
     */
    fun deprecatedGetHistoricStocksTradesRequestConfig(ticker: kotlin.String, date: java.time.LocalDate, timestamp: kotlin.Int?, timestampLimit: kotlin.Int?, reverse: kotlin.Boolean?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (timestampLimit != null) {
                    put("timestampLimit", listOf(timestampLimit.toString()))
                }
                if (reverse != null) {
                    put("reverse", listOf(reverse.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/ticks/stocks/trades/{ticker}/{date}".replace("{"+"ticker"+"}", encodeURIComponent(ticker.toString())).replace("{"+"date"+"}", encodeURIComponent(date.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /benzinga/v1/analyst-insights
     * 
     * 
     * @param date The calendar date (formatted as YYYY-MM-DD) when the rating was issued. (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param ticker The stock symbol of the company being rated. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param lastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the rating was last updated in the system. (optional)
     * @param lastUpdatedAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param lastUpdatedGt Filter greater than the value. (optional)
     * @param lastUpdatedGte Filter greater than or equal to the value. (optional)
     * @param lastUpdatedLt Filter less than the value. (optional)
     * @param lastUpdatedLte Filter less than or equal to the value. (optional)
     * @param firm The name of the research firm or investment bank issuing the rating. (optional)
     * @param firmAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param firmGt Filter greater than the value. (optional)
     * @param firmGte Filter greater than or equal to the value. (optional)
     * @param firmLt Filter less than the value. (optional)
     * @param firmLte Filter less than or equal to the value. (optional)
     * @param benzingaFirmId The identifer used by Benzinga for the firm record. (optional)
     * @param benzingaFirmIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaFirmIdGt Filter greater than the value. (optional)
     * @param benzingaFirmIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaFirmIdLt Filter less than the value. (optional)
     * @param benzingaFirmIdLte Filter less than or equal to the value. (optional)
     * @param benzingaRatingId The identifier used by Benzinga for the rating record. (optional)
     * @param benzingaRatingIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaRatingIdGt Filter greater than the value. (optional)
     * @param benzingaRatingIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaRatingIdLt Filter less than the value. (optional)
     * @param benzingaRatingIdLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;date&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "date.desc")
     * @return GetBenzingaV1AnalystInsights200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBenzingaV1AnalystInsights(date: kotlin.String? = null, dateAnyOf: kotlin.String? = null, dateGt: kotlin.String? = null, dateGte: kotlin.String? = null, dateLt: kotlin.String? = null, dateLte: kotlin.String? = null, ticker: kotlin.String? = null, tickerAnyOf: kotlin.String? = null, tickerGt: kotlin.String? = null, tickerGte: kotlin.String? = null, tickerLt: kotlin.String? = null, tickerLte: kotlin.String? = null, lastUpdated: kotlin.String? = null, lastUpdatedAnyOf: kotlin.String? = null, lastUpdatedGt: kotlin.String? = null, lastUpdatedGte: kotlin.String? = null, lastUpdatedLt: kotlin.String? = null, lastUpdatedLte: kotlin.String? = null, firm: kotlin.String? = null, firmAnyOf: kotlin.String? = null, firmGt: kotlin.String? = null, firmGte: kotlin.String? = null, firmLt: kotlin.String? = null, firmLte: kotlin.String? = null, benzingaFirmId: kotlin.String? = null, benzingaFirmIdAnyOf: kotlin.String? = null, benzingaFirmIdGt: kotlin.String? = null, benzingaFirmIdGte: kotlin.String? = null, benzingaFirmIdLt: kotlin.String? = null, benzingaFirmIdLte: kotlin.String? = null, benzingaRatingId: kotlin.String? = null, benzingaRatingIdAnyOf: kotlin.String? = null, benzingaRatingIdGt: kotlin.String? = null, benzingaRatingIdGte: kotlin.String? = null, benzingaRatingIdLt: kotlin.String? = null, benzingaRatingIdLte: kotlin.String? = null, limit: kotlin.Int? = 100, sort: kotlin.String? = "date.desc") : GetBenzingaV1AnalystInsights200Response {
        val localVarResponse = getBenzingaV1AnalystInsightsWithHttpInfo(date = date, dateAnyOf = dateAnyOf, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, lastUpdated = lastUpdated, lastUpdatedAnyOf = lastUpdatedAnyOf, lastUpdatedGt = lastUpdatedGt, lastUpdatedGte = lastUpdatedGte, lastUpdatedLt = lastUpdatedLt, lastUpdatedLte = lastUpdatedLte, firm = firm, firmAnyOf = firmAnyOf, firmGt = firmGt, firmGte = firmGte, firmLt = firmLt, firmLte = firmLte, benzingaFirmId = benzingaFirmId, benzingaFirmIdAnyOf = benzingaFirmIdAnyOf, benzingaFirmIdGt = benzingaFirmIdGt, benzingaFirmIdGte = benzingaFirmIdGte, benzingaFirmIdLt = benzingaFirmIdLt, benzingaFirmIdLte = benzingaFirmIdLte, benzingaRatingId = benzingaRatingId, benzingaRatingIdAnyOf = benzingaRatingIdAnyOf, benzingaRatingIdGt = benzingaRatingIdGt, benzingaRatingIdGte = benzingaRatingIdGte, benzingaRatingIdLt = benzingaRatingIdLt, benzingaRatingIdLte = benzingaRatingIdLte, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetBenzingaV1AnalystInsights200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /benzinga/v1/analyst-insights
     * 
     * 
     * @param date The calendar date (formatted as YYYY-MM-DD) when the rating was issued. (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param ticker The stock symbol of the company being rated. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param lastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the rating was last updated in the system. (optional)
     * @param lastUpdatedAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param lastUpdatedGt Filter greater than the value. (optional)
     * @param lastUpdatedGte Filter greater than or equal to the value. (optional)
     * @param lastUpdatedLt Filter less than the value. (optional)
     * @param lastUpdatedLte Filter less than or equal to the value. (optional)
     * @param firm The name of the research firm or investment bank issuing the rating. (optional)
     * @param firmAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param firmGt Filter greater than the value. (optional)
     * @param firmGte Filter greater than or equal to the value. (optional)
     * @param firmLt Filter less than the value. (optional)
     * @param firmLte Filter less than or equal to the value. (optional)
     * @param benzingaFirmId The identifer used by Benzinga for the firm record. (optional)
     * @param benzingaFirmIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaFirmIdGt Filter greater than the value. (optional)
     * @param benzingaFirmIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaFirmIdLt Filter less than the value. (optional)
     * @param benzingaFirmIdLte Filter less than or equal to the value. (optional)
     * @param benzingaRatingId The identifier used by Benzinga for the rating record. (optional)
     * @param benzingaRatingIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaRatingIdGt Filter greater than the value. (optional)
     * @param benzingaRatingIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaRatingIdLt Filter less than the value. (optional)
     * @param benzingaRatingIdLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;date&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "date.desc")
     * @return ApiResponse<GetBenzingaV1AnalystInsights200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBenzingaV1AnalystInsightsWithHttpInfo(date: kotlin.String?, dateAnyOf: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, lastUpdated: kotlin.String?, lastUpdatedAnyOf: kotlin.String?, lastUpdatedGt: kotlin.String?, lastUpdatedGte: kotlin.String?, lastUpdatedLt: kotlin.String?, lastUpdatedLte: kotlin.String?, firm: kotlin.String?, firmAnyOf: kotlin.String?, firmGt: kotlin.String?, firmGte: kotlin.String?, firmLt: kotlin.String?, firmLte: kotlin.String?, benzingaFirmId: kotlin.String?, benzingaFirmIdAnyOf: kotlin.String?, benzingaFirmIdGt: kotlin.String?, benzingaFirmIdGte: kotlin.String?, benzingaFirmIdLt: kotlin.String?, benzingaFirmIdLte: kotlin.String?, benzingaRatingId: kotlin.String?, benzingaRatingIdAnyOf: kotlin.String?, benzingaRatingIdGt: kotlin.String?, benzingaRatingIdGte: kotlin.String?, benzingaRatingIdLt: kotlin.String?, benzingaRatingIdLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetBenzingaV1AnalystInsights200Response?> {
        val localVariableConfig = getBenzingaV1AnalystInsightsRequestConfig(date = date, dateAnyOf = dateAnyOf, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, lastUpdated = lastUpdated, lastUpdatedAnyOf = lastUpdatedAnyOf, lastUpdatedGt = lastUpdatedGt, lastUpdatedGte = lastUpdatedGte, lastUpdatedLt = lastUpdatedLt, lastUpdatedLte = lastUpdatedLte, firm = firm, firmAnyOf = firmAnyOf, firmGt = firmGt, firmGte = firmGte, firmLt = firmLt, firmLte = firmLte, benzingaFirmId = benzingaFirmId, benzingaFirmIdAnyOf = benzingaFirmIdAnyOf, benzingaFirmIdGt = benzingaFirmIdGt, benzingaFirmIdGte = benzingaFirmIdGte, benzingaFirmIdLt = benzingaFirmIdLt, benzingaFirmIdLte = benzingaFirmIdLte, benzingaRatingId = benzingaRatingId, benzingaRatingIdAnyOf = benzingaRatingIdAnyOf, benzingaRatingIdGt = benzingaRatingIdGt, benzingaRatingIdGte = benzingaRatingIdGte, benzingaRatingIdLt = benzingaRatingIdLt, benzingaRatingIdLte = benzingaRatingIdLte, limit = limit, sort = sort)

        return request<Unit, GetBenzingaV1AnalystInsights200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBenzingaV1AnalystInsights
     *
     * @param date The calendar date (formatted as YYYY-MM-DD) when the rating was issued. (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param ticker The stock symbol of the company being rated. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param lastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the rating was last updated in the system. (optional)
     * @param lastUpdatedAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param lastUpdatedGt Filter greater than the value. (optional)
     * @param lastUpdatedGte Filter greater than or equal to the value. (optional)
     * @param lastUpdatedLt Filter less than the value. (optional)
     * @param lastUpdatedLte Filter less than or equal to the value. (optional)
     * @param firm The name of the research firm or investment bank issuing the rating. (optional)
     * @param firmAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param firmGt Filter greater than the value. (optional)
     * @param firmGte Filter greater than or equal to the value. (optional)
     * @param firmLt Filter less than the value. (optional)
     * @param firmLte Filter less than or equal to the value. (optional)
     * @param benzingaFirmId The identifer used by Benzinga for the firm record. (optional)
     * @param benzingaFirmIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaFirmIdGt Filter greater than the value. (optional)
     * @param benzingaFirmIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaFirmIdLt Filter less than the value. (optional)
     * @param benzingaFirmIdLte Filter less than or equal to the value. (optional)
     * @param benzingaRatingId The identifier used by Benzinga for the rating record. (optional)
     * @param benzingaRatingIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaRatingIdGt Filter greater than the value. (optional)
     * @param benzingaRatingIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaRatingIdLt Filter less than the value. (optional)
     * @param benzingaRatingIdLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;date&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "date.desc")
     * @return RequestConfig
     */
    fun getBenzingaV1AnalystInsightsRequestConfig(date: kotlin.String?, dateAnyOf: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, lastUpdated: kotlin.String?, lastUpdatedAnyOf: kotlin.String?, lastUpdatedGt: kotlin.String?, lastUpdatedGte: kotlin.String?, lastUpdatedLt: kotlin.String?, lastUpdatedLte: kotlin.String?, firm: kotlin.String?, firmAnyOf: kotlin.String?, firmGt: kotlin.String?, firmGte: kotlin.String?, firmLt: kotlin.String?, firmLte: kotlin.String?, benzingaFirmId: kotlin.String?, benzingaFirmIdAnyOf: kotlin.String?, benzingaFirmIdGt: kotlin.String?, benzingaFirmIdGte: kotlin.String?, benzingaFirmIdLt: kotlin.String?, benzingaFirmIdLte: kotlin.String?, benzingaRatingId: kotlin.String?, benzingaRatingIdAnyOf: kotlin.String?, benzingaRatingIdGt: kotlin.String?, benzingaRatingIdGte: kotlin.String?, benzingaRatingIdLt: kotlin.String?, benzingaRatingIdLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (date != null) {
                    put("date", listOf(date.toString()))
                }
                if (dateAnyOf != null) {
                    put("date.any_of", listOf(dateAnyOf.toString()))
                }
                if (dateGt != null) {
                    put("date.gt", listOf(dateGt.toString()))
                }
                if (dateGte != null) {
                    put("date.gte", listOf(dateGte.toString()))
                }
                if (dateLt != null) {
                    put("date.lt", listOf(dateLt.toString()))
                }
                if (dateLte != null) {
                    put("date.lte", listOf(dateLte.toString()))
                }
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
                if (tickerAnyOf != null) {
                    put("ticker.any_of", listOf(tickerAnyOf.toString()))
                }
                if (tickerGt != null) {
                    put("ticker.gt", listOf(tickerGt.toString()))
                }
                if (tickerGte != null) {
                    put("ticker.gte", listOf(tickerGte.toString()))
                }
                if (tickerLt != null) {
                    put("ticker.lt", listOf(tickerLt.toString()))
                }
                if (tickerLte != null) {
                    put("ticker.lte", listOf(tickerLte.toString()))
                }
                if (lastUpdated != null) {
                    put("last_updated", listOf(lastUpdated.toString()))
                }
                if (lastUpdatedAnyOf != null) {
                    put("last_updated.any_of", listOf(lastUpdatedAnyOf.toString()))
                }
                if (lastUpdatedGt != null) {
                    put("last_updated.gt", listOf(lastUpdatedGt.toString()))
                }
                if (lastUpdatedGte != null) {
                    put("last_updated.gte", listOf(lastUpdatedGte.toString()))
                }
                if (lastUpdatedLt != null) {
                    put("last_updated.lt", listOf(lastUpdatedLt.toString()))
                }
                if (lastUpdatedLte != null) {
                    put("last_updated.lte", listOf(lastUpdatedLte.toString()))
                }
                if (firm != null) {
                    put("firm", listOf(firm.toString()))
                }
                if (firmAnyOf != null) {
                    put("firm.any_of", listOf(firmAnyOf.toString()))
                }
                if (firmGt != null) {
                    put("firm.gt", listOf(firmGt.toString()))
                }
                if (firmGte != null) {
                    put("firm.gte", listOf(firmGte.toString()))
                }
                if (firmLt != null) {
                    put("firm.lt", listOf(firmLt.toString()))
                }
                if (firmLte != null) {
                    put("firm.lte", listOf(firmLte.toString()))
                }
                if (benzingaFirmId != null) {
                    put("benzinga_firm_id", listOf(benzingaFirmId.toString()))
                }
                if (benzingaFirmIdAnyOf != null) {
                    put("benzinga_firm_id.any_of", listOf(benzingaFirmIdAnyOf.toString()))
                }
                if (benzingaFirmIdGt != null) {
                    put("benzinga_firm_id.gt", listOf(benzingaFirmIdGt.toString()))
                }
                if (benzingaFirmIdGte != null) {
                    put("benzinga_firm_id.gte", listOf(benzingaFirmIdGte.toString()))
                }
                if (benzingaFirmIdLt != null) {
                    put("benzinga_firm_id.lt", listOf(benzingaFirmIdLt.toString()))
                }
                if (benzingaFirmIdLte != null) {
                    put("benzinga_firm_id.lte", listOf(benzingaFirmIdLte.toString()))
                }
                if (benzingaRatingId != null) {
                    put("benzinga_rating_id", listOf(benzingaRatingId.toString()))
                }
                if (benzingaRatingIdAnyOf != null) {
                    put("benzinga_rating_id.any_of", listOf(benzingaRatingIdAnyOf.toString()))
                }
                if (benzingaRatingIdGt != null) {
                    put("benzinga_rating_id.gt", listOf(benzingaRatingIdGt.toString()))
                }
                if (benzingaRatingIdGte != null) {
                    put("benzinga_rating_id.gte", listOf(benzingaRatingIdGte.toString()))
                }
                if (benzingaRatingIdLt != null) {
                    put("benzinga_rating_id.lt", listOf(benzingaRatingIdLt.toString()))
                }
                if (benzingaRatingIdLte != null) {
                    put("benzinga_rating_id.lte", listOf(benzingaRatingIdLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/benzinga/v1/analyst-insights",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /benzinga/v1/analysts
     * 
     * 
     * @param benzingaId The identifier used by Benzinga for this record. (optional)
     * @param benzingaIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaIdGt Filter greater than the value. (optional)
     * @param benzingaIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaIdLt Filter less than the value. (optional)
     * @param benzingaIdLte Filter less than or equal to the value. (optional)
     * @param benzingaFirmId The unique identifier assigned by Benzinga to the research firm or investment bank. (optional)
     * @param benzingaFirmIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaFirmIdGt Filter greater than the value. (optional)
     * @param benzingaFirmIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaFirmIdLt Filter less than the value. (optional)
     * @param benzingaFirmIdLte Filter less than or equal to the value. (optional)
     * @param firmName The name of the research firm or investment bank issuing the ratings. (optional)
     * @param firmNameAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param firmNameGt Filter greater than the value. (optional)
     * @param firmNameGte Filter greater than or equal to the value. (optional)
     * @param firmNameLt Filter less than the value. (optional)
     * @param firmNameLte Filter less than or equal to the value. (optional)
     * @param fullName The full name of the analyst associated with the ratings. (optional)
     * @param fullNameAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param fullNameGt Filter greater than the value. (optional)
     * @param fullNameGte Filter greater than or equal to the value. (optional)
     * @param fullNameLt Filter less than the value. (optional)
     * @param fullNameLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;full_name&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "full_name.asc")
     * @return GetBenzingaV1Analysts200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBenzingaV1Analysts(benzingaId: kotlin.String? = null, benzingaIdAnyOf: kotlin.String? = null, benzingaIdGt: kotlin.String? = null, benzingaIdGte: kotlin.String? = null, benzingaIdLt: kotlin.String? = null, benzingaIdLte: kotlin.String? = null, benzingaFirmId: kotlin.String? = null, benzingaFirmIdAnyOf: kotlin.String? = null, benzingaFirmIdGt: kotlin.String? = null, benzingaFirmIdGte: kotlin.String? = null, benzingaFirmIdLt: kotlin.String? = null, benzingaFirmIdLte: kotlin.String? = null, firmName: kotlin.String? = null, firmNameAnyOf: kotlin.String? = null, firmNameGt: kotlin.String? = null, firmNameGte: kotlin.String? = null, firmNameLt: kotlin.String? = null, firmNameLte: kotlin.String? = null, fullName: kotlin.String? = null, fullNameAnyOf: kotlin.String? = null, fullNameGt: kotlin.String? = null, fullNameGte: kotlin.String? = null, fullNameLt: kotlin.String? = null, fullNameLte: kotlin.String? = null, limit: kotlin.Int? = 100, sort: kotlin.String? = "full_name.asc") : GetBenzingaV1Analysts200Response {
        val localVarResponse = getBenzingaV1AnalystsWithHttpInfo(benzingaId = benzingaId, benzingaIdAnyOf = benzingaIdAnyOf, benzingaIdGt = benzingaIdGt, benzingaIdGte = benzingaIdGte, benzingaIdLt = benzingaIdLt, benzingaIdLte = benzingaIdLte, benzingaFirmId = benzingaFirmId, benzingaFirmIdAnyOf = benzingaFirmIdAnyOf, benzingaFirmIdGt = benzingaFirmIdGt, benzingaFirmIdGte = benzingaFirmIdGte, benzingaFirmIdLt = benzingaFirmIdLt, benzingaFirmIdLte = benzingaFirmIdLte, firmName = firmName, firmNameAnyOf = firmNameAnyOf, firmNameGt = firmNameGt, firmNameGte = firmNameGte, firmNameLt = firmNameLt, firmNameLte = firmNameLte, fullName = fullName, fullNameAnyOf = fullNameAnyOf, fullNameGt = fullNameGt, fullNameGte = fullNameGte, fullNameLt = fullNameLt, fullNameLte = fullNameLte, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetBenzingaV1Analysts200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /benzinga/v1/analysts
     * 
     * 
     * @param benzingaId The identifier used by Benzinga for this record. (optional)
     * @param benzingaIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaIdGt Filter greater than the value. (optional)
     * @param benzingaIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaIdLt Filter less than the value. (optional)
     * @param benzingaIdLte Filter less than or equal to the value. (optional)
     * @param benzingaFirmId The unique identifier assigned by Benzinga to the research firm or investment bank. (optional)
     * @param benzingaFirmIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaFirmIdGt Filter greater than the value. (optional)
     * @param benzingaFirmIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaFirmIdLt Filter less than the value. (optional)
     * @param benzingaFirmIdLte Filter less than or equal to the value. (optional)
     * @param firmName The name of the research firm or investment bank issuing the ratings. (optional)
     * @param firmNameAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param firmNameGt Filter greater than the value. (optional)
     * @param firmNameGte Filter greater than or equal to the value. (optional)
     * @param firmNameLt Filter less than the value. (optional)
     * @param firmNameLte Filter less than or equal to the value. (optional)
     * @param fullName The full name of the analyst associated with the ratings. (optional)
     * @param fullNameAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param fullNameGt Filter greater than the value. (optional)
     * @param fullNameGte Filter greater than or equal to the value. (optional)
     * @param fullNameLt Filter less than the value. (optional)
     * @param fullNameLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;full_name&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "full_name.asc")
     * @return ApiResponse<GetBenzingaV1Analysts200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBenzingaV1AnalystsWithHttpInfo(benzingaId: kotlin.String?, benzingaIdAnyOf: kotlin.String?, benzingaIdGt: kotlin.String?, benzingaIdGte: kotlin.String?, benzingaIdLt: kotlin.String?, benzingaIdLte: kotlin.String?, benzingaFirmId: kotlin.String?, benzingaFirmIdAnyOf: kotlin.String?, benzingaFirmIdGt: kotlin.String?, benzingaFirmIdGte: kotlin.String?, benzingaFirmIdLt: kotlin.String?, benzingaFirmIdLte: kotlin.String?, firmName: kotlin.String?, firmNameAnyOf: kotlin.String?, firmNameGt: kotlin.String?, firmNameGte: kotlin.String?, firmNameLt: kotlin.String?, firmNameLte: kotlin.String?, fullName: kotlin.String?, fullNameAnyOf: kotlin.String?, fullNameGt: kotlin.String?, fullNameGte: kotlin.String?, fullNameLt: kotlin.String?, fullNameLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetBenzingaV1Analysts200Response?> {
        val localVariableConfig = getBenzingaV1AnalystsRequestConfig(benzingaId = benzingaId, benzingaIdAnyOf = benzingaIdAnyOf, benzingaIdGt = benzingaIdGt, benzingaIdGte = benzingaIdGte, benzingaIdLt = benzingaIdLt, benzingaIdLte = benzingaIdLte, benzingaFirmId = benzingaFirmId, benzingaFirmIdAnyOf = benzingaFirmIdAnyOf, benzingaFirmIdGt = benzingaFirmIdGt, benzingaFirmIdGte = benzingaFirmIdGte, benzingaFirmIdLt = benzingaFirmIdLt, benzingaFirmIdLte = benzingaFirmIdLte, firmName = firmName, firmNameAnyOf = firmNameAnyOf, firmNameGt = firmNameGt, firmNameGte = firmNameGte, firmNameLt = firmNameLt, firmNameLte = firmNameLte, fullName = fullName, fullNameAnyOf = fullNameAnyOf, fullNameGt = fullNameGt, fullNameGte = fullNameGte, fullNameLt = fullNameLt, fullNameLte = fullNameLte, limit = limit, sort = sort)

        return request<Unit, GetBenzingaV1Analysts200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBenzingaV1Analysts
     *
     * @param benzingaId The identifier used by Benzinga for this record. (optional)
     * @param benzingaIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaIdGt Filter greater than the value. (optional)
     * @param benzingaIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaIdLt Filter less than the value. (optional)
     * @param benzingaIdLte Filter less than or equal to the value. (optional)
     * @param benzingaFirmId The unique identifier assigned by Benzinga to the research firm or investment bank. (optional)
     * @param benzingaFirmIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaFirmIdGt Filter greater than the value. (optional)
     * @param benzingaFirmIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaFirmIdLt Filter less than the value. (optional)
     * @param benzingaFirmIdLte Filter less than or equal to the value. (optional)
     * @param firmName The name of the research firm or investment bank issuing the ratings. (optional)
     * @param firmNameAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param firmNameGt Filter greater than the value. (optional)
     * @param firmNameGte Filter greater than or equal to the value. (optional)
     * @param firmNameLt Filter less than the value. (optional)
     * @param firmNameLte Filter less than or equal to the value. (optional)
     * @param fullName The full name of the analyst associated with the ratings. (optional)
     * @param fullNameAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param fullNameGt Filter greater than the value. (optional)
     * @param fullNameGte Filter greater than or equal to the value. (optional)
     * @param fullNameLt Filter less than the value. (optional)
     * @param fullNameLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;full_name&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "full_name.asc")
     * @return RequestConfig
     */
    fun getBenzingaV1AnalystsRequestConfig(benzingaId: kotlin.String?, benzingaIdAnyOf: kotlin.String?, benzingaIdGt: kotlin.String?, benzingaIdGte: kotlin.String?, benzingaIdLt: kotlin.String?, benzingaIdLte: kotlin.String?, benzingaFirmId: kotlin.String?, benzingaFirmIdAnyOf: kotlin.String?, benzingaFirmIdGt: kotlin.String?, benzingaFirmIdGte: kotlin.String?, benzingaFirmIdLt: kotlin.String?, benzingaFirmIdLte: kotlin.String?, firmName: kotlin.String?, firmNameAnyOf: kotlin.String?, firmNameGt: kotlin.String?, firmNameGte: kotlin.String?, firmNameLt: kotlin.String?, firmNameLte: kotlin.String?, fullName: kotlin.String?, fullNameAnyOf: kotlin.String?, fullNameGt: kotlin.String?, fullNameGte: kotlin.String?, fullNameLt: kotlin.String?, fullNameLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (benzingaId != null) {
                    put("benzinga_id", listOf(benzingaId.toString()))
                }
                if (benzingaIdAnyOf != null) {
                    put("benzinga_id.any_of", listOf(benzingaIdAnyOf.toString()))
                }
                if (benzingaIdGt != null) {
                    put("benzinga_id.gt", listOf(benzingaIdGt.toString()))
                }
                if (benzingaIdGte != null) {
                    put("benzinga_id.gte", listOf(benzingaIdGte.toString()))
                }
                if (benzingaIdLt != null) {
                    put("benzinga_id.lt", listOf(benzingaIdLt.toString()))
                }
                if (benzingaIdLte != null) {
                    put("benzinga_id.lte", listOf(benzingaIdLte.toString()))
                }
                if (benzingaFirmId != null) {
                    put("benzinga_firm_id", listOf(benzingaFirmId.toString()))
                }
                if (benzingaFirmIdAnyOf != null) {
                    put("benzinga_firm_id.any_of", listOf(benzingaFirmIdAnyOf.toString()))
                }
                if (benzingaFirmIdGt != null) {
                    put("benzinga_firm_id.gt", listOf(benzingaFirmIdGt.toString()))
                }
                if (benzingaFirmIdGte != null) {
                    put("benzinga_firm_id.gte", listOf(benzingaFirmIdGte.toString()))
                }
                if (benzingaFirmIdLt != null) {
                    put("benzinga_firm_id.lt", listOf(benzingaFirmIdLt.toString()))
                }
                if (benzingaFirmIdLte != null) {
                    put("benzinga_firm_id.lte", listOf(benzingaFirmIdLte.toString()))
                }
                if (firmName != null) {
                    put("firm_name", listOf(firmName.toString()))
                }
                if (firmNameAnyOf != null) {
                    put("firm_name.any_of", listOf(firmNameAnyOf.toString()))
                }
                if (firmNameGt != null) {
                    put("firm_name.gt", listOf(firmNameGt.toString()))
                }
                if (firmNameGte != null) {
                    put("firm_name.gte", listOf(firmNameGte.toString()))
                }
                if (firmNameLt != null) {
                    put("firm_name.lt", listOf(firmNameLt.toString()))
                }
                if (firmNameLte != null) {
                    put("firm_name.lte", listOf(firmNameLte.toString()))
                }
                if (fullName != null) {
                    put("full_name", listOf(fullName.toString()))
                }
                if (fullNameAnyOf != null) {
                    put("full_name.any_of", listOf(fullNameAnyOf.toString()))
                }
                if (fullNameGt != null) {
                    put("full_name.gt", listOf(fullNameGt.toString()))
                }
                if (fullNameGte != null) {
                    put("full_name.gte", listOf(fullNameGte.toString()))
                }
                if (fullNameLt != null) {
                    put("full_name.lt", listOf(fullNameLt.toString()))
                }
                if (fullNameLte != null) {
                    put("full_name.lte", listOf(fullNameLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/benzinga/v1/analysts",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /benzinga/v1/consensus-ratings/{ticker}
     * 
     * 
     * @param ticker The requested ticker.
     * @param date Filter equal to the value. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @return GetBenzingaV1ConsensusRatings200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBenzingaV1ConsensusRatings(ticker: kotlin.String, date: kotlin.String? = null, dateGt: kotlin.String? = null, dateGte: kotlin.String? = null, dateLt: kotlin.String? = null, dateLte: kotlin.String? = null, limit: kotlin.Int? = 100) : GetBenzingaV1ConsensusRatings200Response {
        val localVarResponse = getBenzingaV1ConsensusRatingsWithHttpInfo(ticker = ticker, date = date, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetBenzingaV1ConsensusRatings200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /benzinga/v1/consensus-ratings/{ticker}
     * 
     * 
     * @param ticker The requested ticker.
     * @param date Filter equal to the value. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @return ApiResponse<GetBenzingaV1ConsensusRatings200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBenzingaV1ConsensusRatingsWithHttpInfo(ticker: kotlin.String, date: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, limit: kotlin.Int?) : ApiResponse<GetBenzingaV1ConsensusRatings200Response?> {
        val localVariableConfig = getBenzingaV1ConsensusRatingsRequestConfig(ticker = ticker, date = date, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, limit = limit)

        return request<Unit, GetBenzingaV1ConsensusRatings200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBenzingaV1ConsensusRatings
     *
     * @param ticker The requested ticker.
     * @param date Filter equal to the value. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @return RequestConfig
     */
    fun getBenzingaV1ConsensusRatingsRequestConfig(ticker: kotlin.String, date: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (date != null) {
                    put("date", listOf(date.toString()))
                }
                if (dateGt != null) {
                    put("date.gt", listOf(dateGt.toString()))
                }
                if (dateGte != null) {
                    put("date.gte", listOf(dateGte.toString()))
                }
                if (dateLt != null) {
                    put("date.lt", listOf(dateLt.toString()))
                }
                if (dateLte != null) {
                    put("date.lte", listOf(dateLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/benzinga/v1/consensus-ratings/{ticker}".replace("{"+"ticker"+"}", encodeURIComponent(ticker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /benzinga/v1/earnings
     * 
     * 
     * @param date The calendar date (formatted as YYYY-MM-DD) when the earnings are scheduled or were reported. (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param ticker The stock symbol of the company reporting earnings. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param importance A subjective indicator of the importance of the event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer. (optional)
     * @param importanceAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param importanceGt Filter greater than the value. Value must be an integer. (optional)
     * @param importanceGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param importanceLt Filter less than the value. Value must be an integer. (optional)
     * @param importanceLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param lastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the record was last updated in the system. (optional)
     * @param lastUpdatedAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param lastUpdatedGt Filter greater than the value. (optional)
     * @param lastUpdatedGte Filter greater than or equal to the value. (optional)
     * @param lastUpdatedLt Filter less than the value. (optional)
     * @param lastUpdatedLte Filter less than or equal to the value. (optional)
     * @param dateStatus Indicates whether the date of the earnings report has been confirmed. Possible values include: projected, confirmed. (optional)
     * @param dateStatusAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateStatusGt Filter greater than the value. (optional)
     * @param dateStatusGte Filter greater than or equal to the value. (optional)
     * @param dateStatusLt Filter less than the value. (optional)
     * @param dateStatusLte Filter less than or equal to the value. (optional)
     * @param epsSurprisePercent The percentage difference between the actual and estimated EPS. Value must be a floating point number. (optional)
     * @param epsSurprisePercentAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number. (optional)
     * @param epsSurprisePercentGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param epsSurprisePercentGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param epsSurprisePercentLt Filter less than the value. Value must be a floating point number. (optional)
     * @param epsSurprisePercentLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param revenueSurprisePercent The percentage difference between the actual and estimated revenue. Value must be a floating point number. (optional)
     * @param revenueSurprisePercentAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number. (optional)
     * @param revenueSurprisePercentGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param revenueSurprisePercentGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param revenueSurprisePercentLt Filter less than the value. Value must be a floating point number. (optional)
     * @param revenueSurprisePercentLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param fiscalYear The fiscal year in which the earnings period falls. Value must be an integer. (optional)
     * @param fiscalYearAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param fiscalYearGt Filter greater than the value. Value must be an integer. (optional)
     * @param fiscalYearGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param fiscalYearLt Filter less than the value. Value must be an integer. (optional)
     * @param fiscalYearLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param fiscalPeriod The fiscal period for which the earnings are reported. Examples include: Q1, Q2, H1, FY. (optional)
     * @param fiscalPeriodAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param fiscalPeriodGt Filter greater than the value. (optional)
     * @param fiscalPeriodGte Filter greater than or equal to the value. (optional)
     * @param fiscalPeriodLt Filter less than the value. (optional)
     * @param fiscalPeriodLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;date&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "date.desc")
     * @return GetBenzingaV1Earnings200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBenzingaV1Earnings(date: kotlin.String? = null, dateAnyOf: kotlin.String? = null, dateGt: kotlin.String? = null, dateGte: kotlin.String? = null, dateLt: kotlin.String? = null, dateLte: kotlin.String? = null, ticker: kotlin.String? = null, tickerAnyOf: kotlin.String? = null, tickerGt: kotlin.String? = null, tickerGte: kotlin.String? = null, tickerLt: kotlin.String? = null, tickerLte: kotlin.String? = null, importance: kotlin.Long? = null, importanceAnyOf: kotlin.String? = null, importanceGt: kotlin.Long? = null, importanceGte: kotlin.Long? = null, importanceLt: kotlin.Long? = null, importanceLte: kotlin.Long? = null, lastUpdated: kotlin.String? = null, lastUpdatedAnyOf: kotlin.String? = null, lastUpdatedGt: kotlin.String? = null, lastUpdatedGte: kotlin.String? = null, lastUpdatedLt: kotlin.String? = null, lastUpdatedLte: kotlin.String? = null, dateStatus: kotlin.String? = null, dateStatusAnyOf: kotlin.String? = null, dateStatusGt: kotlin.String? = null, dateStatusGte: kotlin.String? = null, dateStatusLt: kotlin.String? = null, dateStatusLte: kotlin.String? = null, epsSurprisePercent: kotlin.Double? = null, epsSurprisePercentAnyOf: kotlin.String? = null, epsSurprisePercentGt: kotlin.Double? = null, epsSurprisePercentGte: kotlin.Double? = null, epsSurprisePercentLt: kotlin.Double? = null, epsSurprisePercentLte: kotlin.Double? = null, revenueSurprisePercent: kotlin.Double? = null, revenueSurprisePercentAnyOf: kotlin.String? = null, revenueSurprisePercentGt: kotlin.Double? = null, revenueSurprisePercentGte: kotlin.Double? = null, revenueSurprisePercentLt: kotlin.Double? = null, revenueSurprisePercentLte: kotlin.Double? = null, fiscalYear: kotlin.Long? = null, fiscalYearAnyOf: kotlin.String? = null, fiscalYearGt: kotlin.Long? = null, fiscalYearGte: kotlin.Long? = null, fiscalYearLt: kotlin.Long? = null, fiscalYearLte: kotlin.Long? = null, fiscalPeriod: kotlin.String? = null, fiscalPeriodAnyOf: kotlin.String? = null, fiscalPeriodGt: kotlin.String? = null, fiscalPeriodGte: kotlin.String? = null, fiscalPeriodLt: kotlin.String? = null, fiscalPeriodLte: kotlin.String? = null, limit: kotlin.Int? = 100, sort: kotlin.String? = "date.desc") : GetBenzingaV1Earnings200Response {
        val localVarResponse = getBenzingaV1EarningsWithHttpInfo(date = date, dateAnyOf = dateAnyOf, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, importance = importance, importanceAnyOf = importanceAnyOf, importanceGt = importanceGt, importanceGte = importanceGte, importanceLt = importanceLt, importanceLte = importanceLte, lastUpdated = lastUpdated, lastUpdatedAnyOf = lastUpdatedAnyOf, lastUpdatedGt = lastUpdatedGt, lastUpdatedGte = lastUpdatedGte, lastUpdatedLt = lastUpdatedLt, lastUpdatedLte = lastUpdatedLte, dateStatus = dateStatus, dateStatusAnyOf = dateStatusAnyOf, dateStatusGt = dateStatusGt, dateStatusGte = dateStatusGte, dateStatusLt = dateStatusLt, dateStatusLte = dateStatusLte, epsSurprisePercent = epsSurprisePercent, epsSurprisePercentAnyOf = epsSurprisePercentAnyOf, epsSurprisePercentGt = epsSurprisePercentGt, epsSurprisePercentGte = epsSurprisePercentGte, epsSurprisePercentLt = epsSurprisePercentLt, epsSurprisePercentLte = epsSurprisePercentLte, revenueSurprisePercent = revenueSurprisePercent, revenueSurprisePercentAnyOf = revenueSurprisePercentAnyOf, revenueSurprisePercentGt = revenueSurprisePercentGt, revenueSurprisePercentGte = revenueSurprisePercentGte, revenueSurprisePercentLt = revenueSurprisePercentLt, revenueSurprisePercentLte = revenueSurprisePercentLte, fiscalYear = fiscalYear, fiscalYearAnyOf = fiscalYearAnyOf, fiscalYearGt = fiscalYearGt, fiscalYearGte = fiscalYearGte, fiscalYearLt = fiscalYearLt, fiscalYearLte = fiscalYearLte, fiscalPeriod = fiscalPeriod, fiscalPeriodAnyOf = fiscalPeriodAnyOf, fiscalPeriodGt = fiscalPeriodGt, fiscalPeriodGte = fiscalPeriodGte, fiscalPeriodLt = fiscalPeriodLt, fiscalPeriodLte = fiscalPeriodLte, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetBenzingaV1Earnings200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /benzinga/v1/earnings
     * 
     * 
     * @param date The calendar date (formatted as YYYY-MM-DD) when the earnings are scheduled or were reported. (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param ticker The stock symbol of the company reporting earnings. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param importance A subjective indicator of the importance of the event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer. (optional)
     * @param importanceAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param importanceGt Filter greater than the value. Value must be an integer. (optional)
     * @param importanceGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param importanceLt Filter less than the value. Value must be an integer. (optional)
     * @param importanceLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param lastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the record was last updated in the system. (optional)
     * @param lastUpdatedAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param lastUpdatedGt Filter greater than the value. (optional)
     * @param lastUpdatedGte Filter greater than or equal to the value. (optional)
     * @param lastUpdatedLt Filter less than the value. (optional)
     * @param lastUpdatedLte Filter less than or equal to the value. (optional)
     * @param dateStatus Indicates whether the date of the earnings report has been confirmed. Possible values include: projected, confirmed. (optional)
     * @param dateStatusAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateStatusGt Filter greater than the value. (optional)
     * @param dateStatusGte Filter greater than or equal to the value. (optional)
     * @param dateStatusLt Filter less than the value. (optional)
     * @param dateStatusLte Filter less than or equal to the value. (optional)
     * @param epsSurprisePercent The percentage difference between the actual and estimated EPS. Value must be a floating point number. (optional)
     * @param epsSurprisePercentAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number. (optional)
     * @param epsSurprisePercentGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param epsSurprisePercentGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param epsSurprisePercentLt Filter less than the value. Value must be a floating point number. (optional)
     * @param epsSurprisePercentLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param revenueSurprisePercent The percentage difference between the actual and estimated revenue. Value must be a floating point number. (optional)
     * @param revenueSurprisePercentAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number. (optional)
     * @param revenueSurprisePercentGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param revenueSurprisePercentGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param revenueSurprisePercentLt Filter less than the value. Value must be a floating point number. (optional)
     * @param revenueSurprisePercentLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param fiscalYear The fiscal year in which the earnings period falls. Value must be an integer. (optional)
     * @param fiscalYearAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param fiscalYearGt Filter greater than the value. Value must be an integer. (optional)
     * @param fiscalYearGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param fiscalYearLt Filter less than the value. Value must be an integer. (optional)
     * @param fiscalYearLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param fiscalPeriod The fiscal period for which the earnings are reported. Examples include: Q1, Q2, H1, FY. (optional)
     * @param fiscalPeriodAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param fiscalPeriodGt Filter greater than the value. (optional)
     * @param fiscalPeriodGte Filter greater than or equal to the value. (optional)
     * @param fiscalPeriodLt Filter less than the value. (optional)
     * @param fiscalPeriodLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;date&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "date.desc")
     * @return ApiResponse<GetBenzingaV1Earnings200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBenzingaV1EarningsWithHttpInfo(date: kotlin.String?, dateAnyOf: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, importance: kotlin.Long?, importanceAnyOf: kotlin.String?, importanceGt: kotlin.Long?, importanceGte: kotlin.Long?, importanceLt: kotlin.Long?, importanceLte: kotlin.Long?, lastUpdated: kotlin.String?, lastUpdatedAnyOf: kotlin.String?, lastUpdatedGt: kotlin.String?, lastUpdatedGte: kotlin.String?, lastUpdatedLt: kotlin.String?, lastUpdatedLte: kotlin.String?, dateStatus: kotlin.String?, dateStatusAnyOf: kotlin.String?, dateStatusGt: kotlin.String?, dateStatusGte: kotlin.String?, dateStatusLt: kotlin.String?, dateStatusLte: kotlin.String?, epsSurprisePercent: kotlin.Double?, epsSurprisePercentAnyOf: kotlin.String?, epsSurprisePercentGt: kotlin.Double?, epsSurprisePercentGte: kotlin.Double?, epsSurprisePercentLt: kotlin.Double?, epsSurprisePercentLte: kotlin.Double?, revenueSurprisePercent: kotlin.Double?, revenueSurprisePercentAnyOf: kotlin.String?, revenueSurprisePercentGt: kotlin.Double?, revenueSurprisePercentGte: kotlin.Double?, revenueSurprisePercentLt: kotlin.Double?, revenueSurprisePercentLte: kotlin.Double?, fiscalYear: kotlin.Long?, fiscalYearAnyOf: kotlin.String?, fiscalYearGt: kotlin.Long?, fiscalYearGte: kotlin.Long?, fiscalYearLt: kotlin.Long?, fiscalYearLte: kotlin.Long?, fiscalPeriod: kotlin.String?, fiscalPeriodAnyOf: kotlin.String?, fiscalPeriodGt: kotlin.String?, fiscalPeriodGte: kotlin.String?, fiscalPeriodLt: kotlin.String?, fiscalPeriodLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetBenzingaV1Earnings200Response?> {
        val localVariableConfig = getBenzingaV1EarningsRequestConfig(date = date, dateAnyOf = dateAnyOf, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, importance = importance, importanceAnyOf = importanceAnyOf, importanceGt = importanceGt, importanceGte = importanceGte, importanceLt = importanceLt, importanceLte = importanceLte, lastUpdated = lastUpdated, lastUpdatedAnyOf = lastUpdatedAnyOf, lastUpdatedGt = lastUpdatedGt, lastUpdatedGte = lastUpdatedGte, lastUpdatedLt = lastUpdatedLt, lastUpdatedLte = lastUpdatedLte, dateStatus = dateStatus, dateStatusAnyOf = dateStatusAnyOf, dateStatusGt = dateStatusGt, dateStatusGte = dateStatusGte, dateStatusLt = dateStatusLt, dateStatusLte = dateStatusLte, epsSurprisePercent = epsSurprisePercent, epsSurprisePercentAnyOf = epsSurprisePercentAnyOf, epsSurprisePercentGt = epsSurprisePercentGt, epsSurprisePercentGte = epsSurprisePercentGte, epsSurprisePercentLt = epsSurprisePercentLt, epsSurprisePercentLte = epsSurprisePercentLte, revenueSurprisePercent = revenueSurprisePercent, revenueSurprisePercentAnyOf = revenueSurprisePercentAnyOf, revenueSurprisePercentGt = revenueSurprisePercentGt, revenueSurprisePercentGte = revenueSurprisePercentGte, revenueSurprisePercentLt = revenueSurprisePercentLt, revenueSurprisePercentLte = revenueSurprisePercentLte, fiscalYear = fiscalYear, fiscalYearAnyOf = fiscalYearAnyOf, fiscalYearGt = fiscalYearGt, fiscalYearGte = fiscalYearGte, fiscalYearLt = fiscalYearLt, fiscalYearLte = fiscalYearLte, fiscalPeriod = fiscalPeriod, fiscalPeriodAnyOf = fiscalPeriodAnyOf, fiscalPeriodGt = fiscalPeriodGt, fiscalPeriodGte = fiscalPeriodGte, fiscalPeriodLt = fiscalPeriodLt, fiscalPeriodLte = fiscalPeriodLte, limit = limit, sort = sort)

        return request<Unit, GetBenzingaV1Earnings200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBenzingaV1Earnings
     *
     * @param date The calendar date (formatted as YYYY-MM-DD) when the earnings are scheduled or were reported. (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param ticker The stock symbol of the company reporting earnings. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param importance A subjective indicator of the importance of the event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer. (optional)
     * @param importanceAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param importanceGt Filter greater than the value. Value must be an integer. (optional)
     * @param importanceGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param importanceLt Filter less than the value. Value must be an integer. (optional)
     * @param importanceLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param lastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the record was last updated in the system. (optional)
     * @param lastUpdatedAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param lastUpdatedGt Filter greater than the value. (optional)
     * @param lastUpdatedGte Filter greater than or equal to the value. (optional)
     * @param lastUpdatedLt Filter less than the value. (optional)
     * @param lastUpdatedLte Filter less than or equal to the value. (optional)
     * @param dateStatus Indicates whether the date of the earnings report has been confirmed. Possible values include: projected, confirmed. (optional)
     * @param dateStatusAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateStatusGt Filter greater than the value. (optional)
     * @param dateStatusGte Filter greater than or equal to the value. (optional)
     * @param dateStatusLt Filter less than the value. (optional)
     * @param dateStatusLte Filter less than or equal to the value. (optional)
     * @param epsSurprisePercent The percentage difference between the actual and estimated EPS. Value must be a floating point number. (optional)
     * @param epsSurprisePercentAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number. (optional)
     * @param epsSurprisePercentGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param epsSurprisePercentGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param epsSurprisePercentLt Filter less than the value. Value must be a floating point number. (optional)
     * @param epsSurprisePercentLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param revenueSurprisePercent The percentage difference between the actual and estimated revenue. Value must be a floating point number. (optional)
     * @param revenueSurprisePercentAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number. (optional)
     * @param revenueSurprisePercentGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param revenueSurprisePercentGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param revenueSurprisePercentLt Filter less than the value. Value must be a floating point number. (optional)
     * @param revenueSurprisePercentLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param fiscalYear The fiscal year in which the earnings period falls. Value must be an integer. (optional)
     * @param fiscalYearAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param fiscalYearGt Filter greater than the value. Value must be an integer. (optional)
     * @param fiscalYearGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param fiscalYearLt Filter less than the value. Value must be an integer. (optional)
     * @param fiscalYearLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param fiscalPeriod The fiscal period for which the earnings are reported. Examples include: Q1, Q2, H1, FY. (optional)
     * @param fiscalPeriodAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param fiscalPeriodGt Filter greater than the value. (optional)
     * @param fiscalPeriodGte Filter greater than or equal to the value. (optional)
     * @param fiscalPeriodLt Filter less than the value. (optional)
     * @param fiscalPeriodLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;date&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "date.desc")
     * @return RequestConfig
     */
    fun getBenzingaV1EarningsRequestConfig(date: kotlin.String?, dateAnyOf: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, importance: kotlin.Long?, importanceAnyOf: kotlin.String?, importanceGt: kotlin.Long?, importanceGte: kotlin.Long?, importanceLt: kotlin.Long?, importanceLte: kotlin.Long?, lastUpdated: kotlin.String?, lastUpdatedAnyOf: kotlin.String?, lastUpdatedGt: kotlin.String?, lastUpdatedGte: kotlin.String?, lastUpdatedLt: kotlin.String?, lastUpdatedLte: kotlin.String?, dateStatus: kotlin.String?, dateStatusAnyOf: kotlin.String?, dateStatusGt: kotlin.String?, dateStatusGte: kotlin.String?, dateStatusLt: kotlin.String?, dateStatusLte: kotlin.String?, epsSurprisePercent: kotlin.Double?, epsSurprisePercentAnyOf: kotlin.String?, epsSurprisePercentGt: kotlin.Double?, epsSurprisePercentGte: kotlin.Double?, epsSurprisePercentLt: kotlin.Double?, epsSurprisePercentLte: kotlin.Double?, revenueSurprisePercent: kotlin.Double?, revenueSurprisePercentAnyOf: kotlin.String?, revenueSurprisePercentGt: kotlin.Double?, revenueSurprisePercentGte: kotlin.Double?, revenueSurprisePercentLt: kotlin.Double?, revenueSurprisePercentLte: kotlin.Double?, fiscalYear: kotlin.Long?, fiscalYearAnyOf: kotlin.String?, fiscalYearGt: kotlin.Long?, fiscalYearGte: kotlin.Long?, fiscalYearLt: kotlin.Long?, fiscalYearLte: kotlin.Long?, fiscalPeriod: kotlin.String?, fiscalPeriodAnyOf: kotlin.String?, fiscalPeriodGt: kotlin.String?, fiscalPeriodGte: kotlin.String?, fiscalPeriodLt: kotlin.String?, fiscalPeriodLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (date != null) {
                    put("date", listOf(date.toString()))
                }
                if (dateAnyOf != null) {
                    put("date.any_of", listOf(dateAnyOf.toString()))
                }
                if (dateGt != null) {
                    put("date.gt", listOf(dateGt.toString()))
                }
                if (dateGte != null) {
                    put("date.gte", listOf(dateGte.toString()))
                }
                if (dateLt != null) {
                    put("date.lt", listOf(dateLt.toString()))
                }
                if (dateLte != null) {
                    put("date.lte", listOf(dateLte.toString()))
                }
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
                if (tickerAnyOf != null) {
                    put("ticker.any_of", listOf(tickerAnyOf.toString()))
                }
                if (tickerGt != null) {
                    put("ticker.gt", listOf(tickerGt.toString()))
                }
                if (tickerGte != null) {
                    put("ticker.gte", listOf(tickerGte.toString()))
                }
                if (tickerLt != null) {
                    put("ticker.lt", listOf(tickerLt.toString()))
                }
                if (tickerLte != null) {
                    put("ticker.lte", listOf(tickerLte.toString()))
                }
                if (importance != null) {
                    put("importance", listOf(importance.toString()))
                }
                if (importanceAnyOf != null) {
                    put("importance.any_of", listOf(importanceAnyOf.toString()))
                }
                if (importanceGt != null) {
                    put("importance.gt", listOf(importanceGt.toString()))
                }
                if (importanceGte != null) {
                    put("importance.gte", listOf(importanceGte.toString()))
                }
                if (importanceLt != null) {
                    put("importance.lt", listOf(importanceLt.toString()))
                }
                if (importanceLte != null) {
                    put("importance.lte", listOf(importanceLte.toString()))
                }
                if (lastUpdated != null) {
                    put("last_updated", listOf(lastUpdated.toString()))
                }
                if (lastUpdatedAnyOf != null) {
                    put("last_updated.any_of", listOf(lastUpdatedAnyOf.toString()))
                }
                if (lastUpdatedGt != null) {
                    put("last_updated.gt", listOf(lastUpdatedGt.toString()))
                }
                if (lastUpdatedGte != null) {
                    put("last_updated.gte", listOf(lastUpdatedGte.toString()))
                }
                if (lastUpdatedLt != null) {
                    put("last_updated.lt", listOf(lastUpdatedLt.toString()))
                }
                if (lastUpdatedLte != null) {
                    put("last_updated.lte", listOf(lastUpdatedLte.toString()))
                }
                if (dateStatus != null) {
                    put("date_status", listOf(dateStatus.toString()))
                }
                if (dateStatusAnyOf != null) {
                    put("date_status.any_of", listOf(dateStatusAnyOf.toString()))
                }
                if (dateStatusGt != null) {
                    put("date_status.gt", listOf(dateStatusGt.toString()))
                }
                if (dateStatusGte != null) {
                    put("date_status.gte", listOf(dateStatusGte.toString()))
                }
                if (dateStatusLt != null) {
                    put("date_status.lt", listOf(dateStatusLt.toString()))
                }
                if (dateStatusLte != null) {
                    put("date_status.lte", listOf(dateStatusLte.toString()))
                }
                if (epsSurprisePercent != null) {
                    put("eps_surprise_percent", listOf(epsSurprisePercent.toString()))
                }
                if (epsSurprisePercentAnyOf != null) {
                    put("eps_surprise_percent.any_of", listOf(epsSurprisePercentAnyOf.toString()))
                }
                if (epsSurprisePercentGt != null) {
                    put("eps_surprise_percent.gt", listOf(epsSurprisePercentGt.toString()))
                }
                if (epsSurprisePercentGte != null) {
                    put("eps_surprise_percent.gte", listOf(epsSurprisePercentGte.toString()))
                }
                if (epsSurprisePercentLt != null) {
                    put("eps_surprise_percent.lt", listOf(epsSurprisePercentLt.toString()))
                }
                if (epsSurprisePercentLte != null) {
                    put("eps_surprise_percent.lte", listOf(epsSurprisePercentLte.toString()))
                }
                if (revenueSurprisePercent != null) {
                    put("revenue_surprise_percent", listOf(revenueSurprisePercent.toString()))
                }
                if (revenueSurprisePercentAnyOf != null) {
                    put("revenue_surprise_percent.any_of", listOf(revenueSurprisePercentAnyOf.toString()))
                }
                if (revenueSurprisePercentGt != null) {
                    put("revenue_surprise_percent.gt", listOf(revenueSurprisePercentGt.toString()))
                }
                if (revenueSurprisePercentGte != null) {
                    put("revenue_surprise_percent.gte", listOf(revenueSurprisePercentGte.toString()))
                }
                if (revenueSurprisePercentLt != null) {
                    put("revenue_surprise_percent.lt", listOf(revenueSurprisePercentLt.toString()))
                }
                if (revenueSurprisePercentLte != null) {
                    put("revenue_surprise_percent.lte", listOf(revenueSurprisePercentLte.toString()))
                }
                if (fiscalYear != null) {
                    put("fiscal_year", listOf(fiscalYear.toString()))
                }
                if (fiscalYearAnyOf != null) {
                    put("fiscal_year.any_of", listOf(fiscalYearAnyOf.toString()))
                }
                if (fiscalYearGt != null) {
                    put("fiscal_year.gt", listOf(fiscalYearGt.toString()))
                }
                if (fiscalYearGte != null) {
                    put("fiscal_year.gte", listOf(fiscalYearGte.toString()))
                }
                if (fiscalYearLt != null) {
                    put("fiscal_year.lt", listOf(fiscalYearLt.toString()))
                }
                if (fiscalYearLte != null) {
                    put("fiscal_year.lte", listOf(fiscalYearLte.toString()))
                }
                if (fiscalPeriod != null) {
                    put("fiscal_period", listOf(fiscalPeriod.toString()))
                }
                if (fiscalPeriodAnyOf != null) {
                    put("fiscal_period.any_of", listOf(fiscalPeriodAnyOf.toString()))
                }
                if (fiscalPeriodGt != null) {
                    put("fiscal_period.gt", listOf(fiscalPeriodGt.toString()))
                }
                if (fiscalPeriodGte != null) {
                    put("fiscal_period.gte", listOf(fiscalPeriodGte.toString()))
                }
                if (fiscalPeriodLt != null) {
                    put("fiscal_period.lt", listOf(fiscalPeriodLt.toString()))
                }
                if (fiscalPeriodLte != null) {
                    put("fiscal_period.lte", listOf(fiscalPeriodLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/benzinga/v1/earnings",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /benzinga/v1/firms
     * 
     * 
     * @param benzingaId The identifer used by Benzinga for this record. (optional)
     * @param benzingaIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaIdGt Filter greater than the value. (optional)
     * @param benzingaIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaIdLt Filter less than the value. (optional)
     * @param benzingaIdLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;name&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "name.asc")
     * @return GetBenzingaV1Firms200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBenzingaV1Firms(benzingaId: kotlin.String? = null, benzingaIdAnyOf: kotlin.String? = null, benzingaIdGt: kotlin.String? = null, benzingaIdGte: kotlin.String? = null, benzingaIdLt: kotlin.String? = null, benzingaIdLte: kotlin.String? = null, limit: kotlin.Int? = 100, sort: kotlin.String? = "name.asc") : GetBenzingaV1Firms200Response {
        val localVarResponse = getBenzingaV1FirmsWithHttpInfo(benzingaId = benzingaId, benzingaIdAnyOf = benzingaIdAnyOf, benzingaIdGt = benzingaIdGt, benzingaIdGte = benzingaIdGte, benzingaIdLt = benzingaIdLt, benzingaIdLte = benzingaIdLte, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetBenzingaV1Firms200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /benzinga/v1/firms
     * 
     * 
     * @param benzingaId The identifer used by Benzinga for this record. (optional)
     * @param benzingaIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaIdGt Filter greater than the value. (optional)
     * @param benzingaIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaIdLt Filter less than the value. (optional)
     * @param benzingaIdLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;name&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "name.asc")
     * @return ApiResponse<GetBenzingaV1Firms200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBenzingaV1FirmsWithHttpInfo(benzingaId: kotlin.String?, benzingaIdAnyOf: kotlin.String?, benzingaIdGt: kotlin.String?, benzingaIdGte: kotlin.String?, benzingaIdLt: kotlin.String?, benzingaIdLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetBenzingaV1Firms200Response?> {
        val localVariableConfig = getBenzingaV1FirmsRequestConfig(benzingaId = benzingaId, benzingaIdAnyOf = benzingaIdAnyOf, benzingaIdGt = benzingaIdGt, benzingaIdGte = benzingaIdGte, benzingaIdLt = benzingaIdLt, benzingaIdLte = benzingaIdLte, limit = limit, sort = sort)

        return request<Unit, GetBenzingaV1Firms200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBenzingaV1Firms
     *
     * @param benzingaId The identifer used by Benzinga for this record. (optional)
     * @param benzingaIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaIdGt Filter greater than the value. (optional)
     * @param benzingaIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaIdLt Filter less than the value. (optional)
     * @param benzingaIdLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;name&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "name.asc")
     * @return RequestConfig
     */
    fun getBenzingaV1FirmsRequestConfig(benzingaId: kotlin.String?, benzingaIdAnyOf: kotlin.String?, benzingaIdGt: kotlin.String?, benzingaIdGte: kotlin.String?, benzingaIdLt: kotlin.String?, benzingaIdLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (benzingaId != null) {
                    put("benzinga_id", listOf(benzingaId.toString()))
                }
                if (benzingaIdAnyOf != null) {
                    put("benzinga_id.any_of", listOf(benzingaIdAnyOf.toString()))
                }
                if (benzingaIdGt != null) {
                    put("benzinga_id.gt", listOf(benzingaIdGt.toString()))
                }
                if (benzingaIdGte != null) {
                    put("benzinga_id.gte", listOf(benzingaIdGte.toString()))
                }
                if (benzingaIdLt != null) {
                    put("benzinga_id.lt", listOf(benzingaIdLt.toString()))
                }
                if (benzingaIdLte != null) {
                    put("benzinga_id.lte", listOf(benzingaIdLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/benzinga/v1/firms",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /benzinga/v1/guidance
     * 
     * 
     * @param date The calendar date (formatted as YYYY-MM-DD) when the guidance was issued. (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param ticker The stock symbol of the company issuing guidance. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param positioning Indicates how a particular guidance value is presented relative to other figures disclosed by the company. Possible values are &#39;primary&#39; (the emphasized figure) and &#39;secondary&#39; (a supporting or alternate figure) (optional)
     * @param positioningAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param positioningGt Filter greater than the value. (optional)
     * @param positioningGte Filter greater than or equal to the value. (optional)
     * @param positioningLt Filter less than the value. (optional)
     * @param positioningLte Filter less than or equal to the value. (optional)
     * @param importance A subjective indicator of the importance of the event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer. (optional)
     * @param importanceAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param importanceGt Filter greater than the value. Value must be an integer. (optional)
     * @param importanceGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param importanceLt Filter less than the value. Value must be an integer. (optional)
     * @param importanceLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param lastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the record was last updated in the system. (optional)
     * @param lastUpdatedAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param lastUpdatedGt Filter greater than the value. (optional)
     * @param lastUpdatedGte Filter greater than or equal to the value. (optional)
     * @param lastUpdatedLt Filter less than the value. (optional)
     * @param lastUpdatedLte Filter less than or equal to the value. (optional)
     * @param fiscalYear The fiscal year corresponding to the period for which the guidance is issued. Value must be an integer. (optional)
     * @param fiscalYearAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param fiscalYearGt Filter greater than the value. Value must be an integer. (optional)
     * @param fiscalYearGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param fiscalYearLt Filter less than the value. Value must be an integer. (optional)
     * @param fiscalYearLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param fiscalPeriod The fiscal quarter to which the guidance applies, such as Q1, Q2, Q3, or Q4. (optional)
     * @param fiscalPeriodAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param fiscalPeriodGt Filter greater than the value. (optional)
     * @param fiscalPeriodGte Filter greater than or equal to the value. (optional)
     * @param fiscalPeriodLt Filter less than the value. (optional)
     * @param fiscalPeriodLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;date&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "date.desc")
     * @return GetBenzingaV1Guidance200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBenzingaV1Guidance(date: kotlin.String? = null, dateAnyOf: kotlin.String? = null, dateGt: kotlin.String? = null, dateGte: kotlin.String? = null, dateLt: kotlin.String? = null, dateLte: kotlin.String? = null, ticker: kotlin.String? = null, tickerAnyOf: kotlin.String? = null, tickerGt: kotlin.String? = null, tickerGte: kotlin.String? = null, tickerLt: kotlin.String? = null, tickerLte: kotlin.String? = null, positioning: kotlin.String? = null, positioningAnyOf: kotlin.String? = null, positioningGt: kotlin.String? = null, positioningGte: kotlin.String? = null, positioningLt: kotlin.String? = null, positioningLte: kotlin.String? = null, importance: kotlin.Long? = null, importanceAnyOf: kotlin.String? = null, importanceGt: kotlin.Long? = null, importanceGte: kotlin.Long? = null, importanceLt: kotlin.Long? = null, importanceLte: kotlin.Long? = null, lastUpdated: kotlin.String? = null, lastUpdatedAnyOf: kotlin.String? = null, lastUpdatedGt: kotlin.String? = null, lastUpdatedGte: kotlin.String? = null, lastUpdatedLt: kotlin.String? = null, lastUpdatedLte: kotlin.String? = null, fiscalYear: kotlin.Long? = null, fiscalYearAnyOf: kotlin.String? = null, fiscalYearGt: kotlin.Long? = null, fiscalYearGte: kotlin.Long? = null, fiscalYearLt: kotlin.Long? = null, fiscalYearLte: kotlin.Long? = null, fiscalPeriod: kotlin.String? = null, fiscalPeriodAnyOf: kotlin.String? = null, fiscalPeriodGt: kotlin.String? = null, fiscalPeriodGte: kotlin.String? = null, fiscalPeriodLt: kotlin.String? = null, fiscalPeriodLte: kotlin.String? = null, limit: kotlin.Int? = 100, sort: kotlin.String? = "date.desc") : GetBenzingaV1Guidance200Response {
        val localVarResponse = getBenzingaV1GuidanceWithHttpInfo(date = date, dateAnyOf = dateAnyOf, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, positioning = positioning, positioningAnyOf = positioningAnyOf, positioningGt = positioningGt, positioningGte = positioningGte, positioningLt = positioningLt, positioningLte = positioningLte, importance = importance, importanceAnyOf = importanceAnyOf, importanceGt = importanceGt, importanceGte = importanceGte, importanceLt = importanceLt, importanceLte = importanceLte, lastUpdated = lastUpdated, lastUpdatedAnyOf = lastUpdatedAnyOf, lastUpdatedGt = lastUpdatedGt, lastUpdatedGte = lastUpdatedGte, lastUpdatedLt = lastUpdatedLt, lastUpdatedLte = lastUpdatedLte, fiscalYear = fiscalYear, fiscalYearAnyOf = fiscalYearAnyOf, fiscalYearGt = fiscalYearGt, fiscalYearGte = fiscalYearGte, fiscalYearLt = fiscalYearLt, fiscalYearLte = fiscalYearLte, fiscalPeriod = fiscalPeriod, fiscalPeriodAnyOf = fiscalPeriodAnyOf, fiscalPeriodGt = fiscalPeriodGt, fiscalPeriodGte = fiscalPeriodGte, fiscalPeriodLt = fiscalPeriodLt, fiscalPeriodLte = fiscalPeriodLte, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetBenzingaV1Guidance200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /benzinga/v1/guidance
     * 
     * 
     * @param date The calendar date (formatted as YYYY-MM-DD) when the guidance was issued. (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param ticker The stock symbol of the company issuing guidance. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param positioning Indicates how a particular guidance value is presented relative to other figures disclosed by the company. Possible values are &#39;primary&#39; (the emphasized figure) and &#39;secondary&#39; (a supporting or alternate figure) (optional)
     * @param positioningAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param positioningGt Filter greater than the value. (optional)
     * @param positioningGte Filter greater than or equal to the value. (optional)
     * @param positioningLt Filter less than the value. (optional)
     * @param positioningLte Filter less than or equal to the value. (optional)
     * @param importance A subjective indicator of the importance of the event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer. (optional)
     * @param importanceAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param importanceGt Filter greater than the value. Value must be an integer. (optional)
     * @param importanceGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param importanceLt Filter less than the value. Value must be an integer. (optional)
     * @param importanceLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param lastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the record was last updated in the system. (optional)
     * @param lastUpdatedAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param lastUpdatedGt Filter greater than the value. (optional)
     * @param lastUpdatedGte Filter greater than or equal to the value. (optional)
     * @param lastUpdatedLt Filter less than the value. (optional)
     * @param lastUpdatedLte Filter less than or equal to the value. (optional)
     * @param fiscalYear The fiscal year corresponding to the period for which the guidance is issued. Value must be an integer. (optional)
     * @param fiscalYearAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param fiscalYearGt Filter greater than the value. Value must be an integer. (optional)
     * @param fiscalYearGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param fiscalYearLt Filter less than the value. Value must be an integer. (optional)
     * @param fiscalYearLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param fiscalPeriod The fiscal quarter to which the guidance applies, such as Q1, Q2, Q3, or Q4. (optional)
     * @param fiscalPeriodAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param fiscalPeriodGt Filter greater than the value. (optional)
     * @param fiscalPeriodGte Filter greater than or equal to the value. (optional)
     * @param fiscalPeriodLt Filter less than the value. (optional)
     * @param fiscalPeriodLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;date&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "date.desc")
     * @return ApiResponse<GetBenzingaV1Guidance200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBenzingaV1GuidanceWithHttpInfo(date: kotlin.String?, dateAnyOf: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, positioning: kotlin.String?, positioningAnyOf: kotlin.String?, positioningGt: kotlin.String?, positioningGte: kotlin.String?, positioningLt: kotlin.String?, positioningLte: kotlin.String?, importance: kotlin.Long?, importanceAnyOf: kotlin.String?, importanceGt: kotlin.Long?, importanceGte: kotlin.Long?, importanceLt: kotlin.Long?, importanceLte: kotlin.Long?, lastUpdated: kotlin.String?, lastUpdatedAnyOf: kotlin.String?, lastUpdatedGt: kotlin.String?, lastUpdatedGte: kotlin.String?, lastUpdatedLt: kotlin.String?, lastUpdatedLte: kotlin.String?, fiscalYear: kotlin.Long?, fiscalYearAnyOf: kotlin.String?, fiscalYearGt: kotlin.Long?, fiscalYearGte: kotlin.Long?, fiscalYearLt: kotlin.Long?, fiscalYearLte: kotlin.Long?, fiscalPeriod: kotlin.String?, fiscalPeriodAnyOf: kotlin.String?, fiscalPeriodGt: kotlin.String?, fiscalPeriodGte: kotlin.String?, fiscalPeriodLt: kotlin.String?, fiscalPeriodLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetBenzingaV1Guidance200Response?> {
        val localVariableConfig = getBenzingaV1GuidanceRequestConfig(date = date, dateAnyOf = dateAnyOf, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, positioning = positioning, positioningAnyOf = positioningAnyOf, positioningGt = positioningGt, positioningGte = positioningGte, positioningLt = positioningLt, positioningLte = positioningLte, importance = importance, importanceAnyOf = importanceAnyOf, importanceGt = importanceGt, importanceGte = importanceGte, importanceLt = importanceLt, importanceLte = importanceLte, lastUpdated = lastUpdated, lastUpdatedAnyOf = lastUpdatedAnyOf, lastUpdatedGt = lastUpdatedGt, lastUpdatedGte = lastUpdatedGte, lastUpdatedLt = lastUpdatedLt, lastUpdatedLte = lastUpdatedLte, fiscalYear = fiscalYear, fiscalYearAnyOf = fiscalYearAnyOf, fiscalYearGt = fiscalYearGt, fiscalYearGte = fiscalYearGte, fiscalYearLt = fiscalYearLt, fiscalYearLte = fiscalYearLte, fiscalPeriod = fiscalPeriod, fiscalPeriodAnyOf = fiscalPeriodAnyOf, fiscalPeriodGt = fiscalPeriodGt, fiscalPeriodGte = fiscalPeriodGte, fiscalPeriodLt = fiscalPeriodLt, fiscalPeriodLte = fiscalPeriodLte, limit = limit, sort = sort)

        return request<Unit, GetBenzingaV1Guidance200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBenzingaV1Guidance
     *
     * @param date The calendar date (formatted as YYYY-MM-DD) when the guidance was issued. (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param ticker The stock symbol of the company issuing guidance. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param positioning Indicates how a particular guidance value is presented relative to other figures disclosed by the company. Possible values are &#39;primary&#39; (the emphasized figure) and &#39;secondary&#39; (a supporting or alternate figure) (optional)
     * @param positioningAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param positioningGt Filter greater than the value. (optional)
     * @param positioningGte Filter greater than or equal to the value. (optional)
     * @param positioningLt Filter less than the value. (optional)
     * @param positioningLte Filter less than or equal to the value. (optional)
     * @param importance A subjective indicator of the importance of the event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer. (optional)
     * @param importanceAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param importanceGt Filter greater than the value. Value must be an integer. (optional)
     * @param importanceGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param importanceLt Filter less than the value. Value must be an integer. (optional)
     * @param importanceLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param lastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the record was last updated in the system. (optional)
     * @param lastUpdatedAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param lastUpdatedGt Filter greater than the value. (optional)
     * @param lastUpdatedGte Filter greater than or equal to the value. (optional)
     * @param lastUpdatedLt Filter less than the value. (optional)
     * @param lastUpdatedLte Filter less than or equal to the value. (optional)
     * @param fiscalYear The fiscal year corresponding to the period for which the guidance is issued. Value must be an integer. (optional)
     * @param fiscalYearAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param fiscalYearGt Filter greater than the value. Value must be an integer. (optional)
     * @param fiscalYearGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param fiscalYearLt Filter less than the value. Value must be an integer. (optional)
     * @param fiscalYearLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param fiscalPeriod The fiscal quarter to which the guidance applies, such as Q1, Q2, Q3, or Q4. (optional)
     * @param fiscalPeriodAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param fiscalPeriodGt Filter greater than the value. (optional)
     * @param fiscalPeriodGte Filter greater than or equal to the value. (optional)
     * @param fiscalPeriodLt Filter less than the value. (optional)
     * @param fiscalPeriodLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;date&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "date.desc")
     * @return RequestConfig
     */
    fun getBenzingaV1GuidanceRequestConfig(date: kotlin.String?, dateAnyOf: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, positioning: kotlin.String?, positioningAnyOf: kotlin.String?, positioningGt: kotlin.String?, positioningGte: kotlin.String?, positioningLt: kotlin.String?, positioningLte: kotlin.String?, importance: kotlin.Long?, importanceAnyOf: kotlin.String?, importanceGt: kotlin.Long?, importanceGte: kotlin.Long?, importanceLt: kotlin.Long?, importanceLte: kotlin.Long?, lastUpdated: kotlin.String?, lastUpdatedAnyOf: kotlin.String?, lastUpdatedGt: kotlin.String?, lastUpdatedGte: kotlin.String?, lastUpdatedLt: kotlin.String?, lastUpdatedLte: kotlin.String?, fiscalYear: kotlin.Long?, fiscalYearAnyOf: kotlin.String?, fiscalYearGt: kotlin.Long?, fiscalYearGte: kotlin.Long?, fiscalYearLt: kotlin.Long?, fiscalYearLte: kotlin.Long?, fiscalPeriod: kotlin.String?, fiscalPeriodAnyOf: kotlin.String?, fiscalPeriodGt: kotlin.String?, fiscalPeriodGte: kotlin.String?, fiscalPeriodLt: kotlin.String?, fiscalPeriodLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (date != null) {
                    put("date", listOf(date.toString()))
                }
                if (dateAnyOf != null) {
                    put("date.any_of", listOf(dateAnyOf.toString()))
                }
                if (dateGt != null) {
                    put("date.gt", listOf(dateGt.toString()))
                }
                if (dateGte != null) {
                    put("date.gte", listOf(dateGte.toString()))
                }
                if (dateLt != null) {
                    put("date.lt", listOf(dateLt.toString()))
                }
                if (dateLte != null) {
                    put("date.lte", listOf(dateLte.toString()))
                }
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
                if (tickerAnyOf != null) {
                    put("ticker.any_of", listOf(tickerAnyOf.toString()))
                }
                if (tickerGt != null) {
                    put("ticker.gt", listOf(tickerGt.toString()))
                }
                if (tickerGte != null) {
                    put("ticker.gte", listOf(tickerGte.toString()))
                }
                if (tickerLt != null) {
                    put("ticker.lt", listOf(tickerLt.toString()))
                }
                if (tickerLte != null) {
                    put("ticker.lte", listOf(tickerLte.toString()))
                }
                if (positioning != null) {
                    put("positioning", listOf(positioning.toString()))
                }
                if (positioningAnyOf != null) {
                    put("positioning.any_of", listOf(positioningAnyOf.toString()))
                }
                if (positioningGt != null) {
                    put("positioning.gt", listOf(positioningGt.toString()))
                }
                if (positioningGte != null) {
                    put("positioning.gte", listOf(positioningGte.toString()))
                }
                if (positioningLt != null) {
                    put("positioning.lt", listOf(positioningLt.toString()))
                }
                if (positioningLte != null) {
                    put("positioning.lte", listOf(positioningLte.toString()))
                }
                if (importance != null) {
                    put("importance", listOf(importance.toString()))
                }
                if (importanceAnyOf != null) {
                    put("importance.any_of", listOf(importanceAnyOf.toString()))
                }
                if (importanceGt != null) {
                    put("importance.gt", listOf(importanceGt.toString()))
                }
                if (importanceGte != null) {
                    put("importance.gte", listOf(importanceGte.toString()))
                }
                if (importanceLt != null) {
                    put("importance.lt", listOf(importanceLt.toString()))
                }
                if (importanceLte != null) {
                    put("importance.lte", listOf(importanceLte.toString()))
                }
                if (lastUpdated != null) {
                    put("last_updated", listOf(lastUpdated.toString()))
                }
                if (lastUpdatedAnyOf != null) {
                    put("last_updated.any_of", listOf(lastUpdatedAnyOf.toString()))
                }
                if (lastUpdatedGt != null) {
                    put("last_updated.gt", listOf(lastUpdatedGt.toString()))
                }
                if (lastUpdatedGte != null) {
                    put("last_updated.gte", listOf(lastUpdatedGte.toString()))
                }
                if (lastUpdatedLt != null) {
                    put("last_updated.lt", listOf(lastUpdatedLt.toString()))
                }
                if (lastUpdatedLte != null) {
                    put("last_updated.lte", listOf(lastUpdatedLte.toString()))
                }
                if (fiscalYear != null) {
                    put("fiscal_year", listOf(fiscalYear.toString()))
                }
                if (fiscalYearAnyOf != null) {
                    put("fiscal_year.any_of", listOf(fiscalYearAnyOf.toString()))
                }
                if (fiscalYearGt != null) {
                    put("fiscal_year.gt", listOf(fiscalYearGt.toString()))
                }
                if (fiscalYearGte != null) {
                    put("fiscal_year.gte", listOf(fiscalYearGte.toString()))
                }
                if (fiscalYearLt != null) {
                    put("fiscal_year.lt", listOf(fiscalYearLt.toString()))
                }
                if (fiscalYearLte != null) {
                    put("fiscal_year.lte", listOf(fiscalYearLte.toString()))
                }
                if (fiscalPeriod != null) {
                    put("fiscal_period", listOf(fiscalPeriod.toString()))
                }
                if (fiscalPeriodAnyOf != null) {
                    put("fiscal_period.any_of", listOf(fiscalPeriodAnyOf.toString()))
                }
                if (fiscalPeriodGt != null) {
                    put("fiscal_period.gt", listOf(fiscalPeriodGt.toString()))
                }
                if (fiscalPeriodGte != null) {
                    put("fiscal_period.gte", listOf(fiscalPeriodGte.toString()))
                }
                if (fiscalPeriodLt != null) {
                    put("fiscal_period.lt", listOf(fiscalPeriodLt.toString()))
                }
                if (fiscalPeriodLte != null) {
                    put("fiscal_period.lte", listOf(fiscalPeriodLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/benzinga/v1/guidance",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /benzinga/v1/news
     * 
     * 
     * @param published The timestamp (formatted as an ISO 8601 timestamp) when the news article was originally published. (optional)
     * @param publishedAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param publishedGt Filter greater than the value. (optional)
     * @param publishedGte Filter greater than or equal to the value. (optional)
     * @param publishedLt Filter less than the value. (optional)
     * @param publishedLte Filter less than or equal to the value. (optional)
     * @param lastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the news article was last updated in the system. (optional)
     * @param lastUpdatedAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param lastUpdatedGt Filter greater than the value. (optional)
     * @param lastUpdatedGte Filter greater than or equal to the value. (optional)
     * @param lastUpdatedLt Filter less than the value. (optional)
     * @param lastUpdatedLte Filter less than or equal to the value. (optional)
     * @param tickers Filter for arrays that contain the value. (optional)
     * @param tickersAllOf Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickersAnyOf Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param channels Filter for arrays that contain the value. (optional)
     * @param channelsAllOf Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param channelsAnyOf Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tags Filter for arrays that contain the value. (optional)
     * @param tagsAllOf Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tagsAnyOf Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param author The name of the journalist or entity that authored the news article. (optional)
     * @param authorAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param authorGt Filter greater than the value. (optional)
     * @param authorGte Filter greater than or equal to the value. (optional)
     * @param authorLt Filter less than the value. (optional)
     * @param authorLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;published&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "published.desc")
     * @return GetBenzingaV1News200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBenzingaV1News(published: kotlin.String? = null, publishedAnyOf: kotlin.String? = null, publishedGt: kotlin.String? = null, publishedGte: kotlin.String? = null, publishedLt: kotlin.String? = null, publishedLte: kotlin.String? = null, lastUpdated: kotlin.String? = null, lastUpdatedAnyOf: kotlin.String? = null, lastUpdatedGt: kotlin.String? = null, lastUpdatedGte: kotlin.String? = null, lastUpdatedLt: kotlin.String? = null, lastUpdatedLte: kotlin.String? = null, tickers: kotlin.String? = null, tickersAllOf: kotlin.String? = null, tickersAnyOf: kotlin.String? = null, channels: kotlin.String? = null, channelsAllOf: kotlin.String? = null, channelsAnyOf: kotlin.String? = null, tags: kotlin.String? = null, tagsAllOf: kotlin.String? = null, tagsAnyOf: kotlin.String? = null, author: kotlin.String? = null, authorAnyOf: kotlin.String? = null, authorGt: kotlin.String? = null, authorGte: kotlin.String? = null, authorLt: kotlin.String? = null, authorLte: kotlin.String? = null, limit: kotlin.Int? = 100, sort: kotlin.String? = "published.desc") : GetBenzingaV1News200Response {
        val localVarResponse = getBenzingaV1NewsWithHttpInfo(published = published, publishedAnyOf = publishedAnyOf, publishedGt = publishedGt, publishedGte = publishedGte, publishedLt = publishedLt, publishedLte = publishedLte, lastUpdated = lastUpdated, lastUpdatedAnyOf = lastUpdatedAnyOf, lastUpdatedGt = lastUpdatedGt, lastUpdatedGte = lastUpdatedGte, lastUpdatedLt = lastUpdatedLt, lastUpdatedLte = lastUpdatedLte, tickers = tickers, tickersAllOf = tickersAllOf, tickersAnyOf = tickersAnyOf, channels = channels, channelsAllOf = channelsAllOf, channelsAnyOf = channelsAnyOf, tags = tags, tagsAllOf = tagsAllOf, tagsAnyOf = tagsAnyOf, author = author, authorAnyOf = authorAnyOf, authorGt = authorGt, authorGte = authorGte, authorLt = authorLt, authorLte = authorLte, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetBenzingaV1News200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /benzinga/v1/news
     * 
     * 
     * @param published The timestamp (formatted as an ISO 8601 timestamp) when the news article was originally published. (optional)
     * @param publishedAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param publishedGt Filter greater than the value. (optional)
     * @param publishedGte Filter greater than or equal to the value. (optional)
     * @param publishedLt Filter less than the value. (optional)
     * @param publishedLte Filter less than or equal to the value. (optional)
     * @param lastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the news article was last updated in the system. (optional)
     * @param lastUpdatedAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param lastUpdatedGt Filter greater than the value. (optional)
     * @param lastUpdatedGte Filter greater than or equal to the value. (optional)
     * @param lastUpdatedLt Filter less than the value. (optional)
     * @param lastUpdatedLte Filter less than or equal to the value. (optional)
     * @param tickers Filter for arrays that contain the value. (optional)
     * @param tickersAllOf Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickersAnyOf Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param channels Filter for arrays that contain the value. (optional)
     * @param channelsAllOf Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param channelsAnyOf Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tags Filter for arrays that contain the value. (optional)
     * @param tagsAllOf Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tagsAnyOf Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param author The name of the journalist or entity that authored the news article. (optional)
     * @param authorAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param authorGt Filter greater than the value. (optional)
     * @param authorGte Filter greater than or equal to the value. (optional)
     * @param authorLt Filter less than the value. (optional)
     * @param authorLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;published&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "published.desc")
     * @return ApiResponse<GetBenzingaV1News200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBenzingaV1NewsWithHttpInfo(published: kotlin.String?, publishedAnyOf: kotlin.String?, publishedGt: kotlin.String?, publishedGte: kotlin.String?, publishedLt: kotlin.String?, publishedLte: kotlin.String?, lastUpdated: kotlin.String?, lastUpdatedAnyOf: kotlin.String?, lastUpdatedGt: kotlin.String?, lastUpdatedGte: kotlin.String?, lastUpdatedLt: kotlin.String?, lastUpdatedLte: kotlin.String?, tickers: kotlin.String?, tickersAllOf: kotlin.String?, tickersAnyOf: kotlin.String?, channels: kotlin.String?, channelsAllOf: kotlin.String?, channelsAnyOf: kotlin.String?, tags: kotlin.String?, tagsAllOf: kotlin.String?, tagsAnyOf: kotlin.String?, author: kotlin.String?, authorAnyOf: kotlin.String?, authorGt: kotlin.String?, authorGte: kotlin.String?, authorLt: kotlin.String?, authorLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetBenzingaV1News200Response?> {
        val localVariableConfig = getBenzingaV1NewsRequestConfig(published = published, publishedAnyOf = publishedAnyOf, publishedGt = publishedGt, publishedGte = publishedGte, publishedLt = publishedLt, publishedLte = publishedLte, lastUpdated = lastUpdated, lastUpdatedAnyOf = lastUpdatedAnyOf, lastUpdatedGt = lastUpdatedGt, lastUpdatedGte = lastUpdatedGte, lastUpdatedLt = lastUpdatedLt, lastUpdatedLte = lastUpdatedLte, tickers = tickers, tickersAllOf = tickersAllOf, tickersAnyOf = tickersAnyOf, channels = channels, channelsAllOf = channelsAllOf, channelsAnyOf = channelsAnyOf, tags = tags, tagsAllOf = tagsAllOf, tagsAnyOf = tagsAnyOf, author = author, authorAnyOf = authorAnyOf, authorGt = authorGt, authorGte = authorGte, authorLt = authorLt, authorLte = authorLte, limit = limit, sort = sort)

        return request<Unit, GetBenzingaV1News200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBenzingaV1News
     *
     * @param published The timestamp (formatted as an ISO 8601 timestamp) when the news article was originally published. (optional)
     * @param publishedAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param publishedGt Filter greater than the value. (optional)
     * @param publishedGte Filter greater than or equal to the value. (optional)
     * @param publishedLt Filter less than the value. (optional)
     * @param publishedLte Filter less than or equal to the value. (optional)
     * @param lastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the news article was last updated in the system. (optional)
     * @param lastUpdatedAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param lastUpdatedGt Filter greater than the value. (optional)
     * @param lastUpdatedGte Filter greater than or equal to the value. (optional)
     * @param lastUpdatedLt Filter less than the value. (optional)
     * @param lastUpdatedLte Filter less than or equal to the value. (optional)
     * @param tickers Filter for arrays that contain the value. (optional)
     * @param tickersAllOf Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickersAnyOf Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param channels Filter for arrays that contain the value. (optional)
     * @param channelsAllOf Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param channelsAnyOf Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tags Filter for arrays that contain the value. (optional)
     * @param tagsAllOf Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tagsAnyOf Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param author The name of the journalist or entity that authored the news article. (optional)
     * @param authorAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param authorGt Filter greater than the value. (optional)
     * @param authorGte Filter greater than or equal to the value. (optional)
     * @param authorLt Filter less than the value. (optional)
     * @param authorLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;published&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "published.desc")
     * @return RequestConfig
     */
    fun getBenzingaV1NewsRequestConfig(published: kotlin.String?, publishedAnyOf: kotlin.String?, publishedGt: kotlin.String?, publishedGte: kotlin.String?, publishedLt: kotlin.String?, publishedLte: kotlin.String?, lastUpdated: kotlin.String?, lastUpdatedAnyOf: kotlin.String?, lastUpdatedGt: kotlin.String?, lastUpdatedGte: kotlin.String?, lastUpdatedLt: kotlin.String?, lastUpdatedLte: kotlin.String?, tickers: kotlin.String?, tickersAllOf: kotlin.String?, tickersAnyOf: kotlin.String?, channels: kotlin.String?, channelsAllOf: kotlin.String?, channelsAnyOf: kotlin.String?, tags: kotlin.String?, tagsAllOf: kotlin.String?, tagsAnyOf: kotlin.String?, author: kotlin.String?, authorAnyOf: kotlin.String?, authorGt: kotlin.String?, authorGte: kotlin.String?, authorLt: kotlin.String?, authorLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (published != null) {
                    put("published", listOf(published.toString()))
                }
                if (publishedAnyOf != null) {
                    put("published.any_of", listOf(publishedAnyOf.toString()))
                }
                if (publishedGt != null) {
                    put("published.gt", listOf(publishedGt.toString()))
                }
                if (publishedGte != null) {
                    put("published.gte", listOf(publishedGte.toString()))
                }
                if (publishedLt != null) {
                    put("published.lt", listOf(publishedLt.toString()))
                }
                if (publishedLte != null) {
                    put("published.lte", listOf(publishedLte.toString()))
                }
                if (lastUpdated != null) {
                    put("last_updated", listOf(lastUpdated.toString()))
                }
                if (lastUpdatedAnyOf != null) {
                    put("last_updated.any_of", listOf(lastUpdatedAnyOf.toString()))
                }
                if (lastUpdatedGt != null) {
                    put("last_updated.gt", listOf(lastUpdatedGt.toString()))
                }
                if (lastUpdatedGte != null) {
                    put("last_updated.gte", listOf(lastUpdatedGte.toString()))
                }
                if (lastUpdatedLt != null) {
                    put("last_updated.lt", listOf(lastUpdatedLt.toString()))
                }
                if (lastUpdatedLte != null) {
                    put("last_updated.lte", listOf(lastUpdatedLte.toString()))
                }
                if (tickers != null) {
                    put("tickers", listOf(tickers.toString()))
                }
                if (tickersAllOf != null) {
                    put("tickers.all_of", listOf(tickersAllOf.toString()))
                }
                if (tickersAnyOf != null) {
                    put("tickers.any_of", listOf(tickersAnyOf.toString()))
                }
                if (channels != null) {
                    put("channels", listOf(channels.toString()))
                }
                if (channelsAllOf != null) {
                    put("channels.all_of", listOf(channelsAllOf.toString()))
                }
                if (channelsAnyOf != null) {
                    put("channels.any_of", listOf(channelsAnyOf.toString()))
                }
                if (tags != null) {
                    put("tags", listOf(tags.toString()))
                }
                if (tagsAllOf != null) {
                    put("tags.all_of", listOf(tagsAllOf.toString()))
                }
                if (tagsAnyOf != null) {
                    put("tags.any_of", listOf(tagsAnyOf.toString()))
                }
                if (author != null) {
                    put("author", listOf(author.toString()))
                }
                if (authorAnyOf != null) {
                    put("author.any_of", listOf(authorAnyOf.toString()))
                }
                if (authorGt != null) {
                    put("author.gt", listOf(authorGt.toString()))
                }
                if (authorGte != null) {
                    put("author.gte", listOf(authorGte.toString()))
                }
                if (authorLt != null) {
                    put("author.lt", listOf(authorLt.toString()))
                }
                if (authorLte != null) {
                    put("author.lte", listOf(authorLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/benzinga/v1/news",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /benzinga/v1/ratings
     * 
     * 
     * @param date The calendar date (formatted as YYYY-MM-DD) when the rating was issued. (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param ticker The stock symbol of the company being rated. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param importance A subjective indicator of the importance of the earnings event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer. (optional)
     * @param importanceAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param importanceGt Filter greater than the value. Value must be an integer. (optional)
     * @param importanceGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param importanceLt Filter less than the value. Value must be an integer. (optional)
     * @param importanceLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param lastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the rating was last updated in the system. (optional)
     * @param lastUpdatedAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param lastUpdatedGt Filter greater than the value. (optional)
     * @param lastUpdatedGte Filter greater than or equal to the value. (optional)
     * @param lastUpdatedLt Filter less than the value. (optional)
     * @param lastUpdatedLte Filter less than or equal to the value. (optional)
     * @param ratingAction The description of the change in rating from the firm&#39;s last rating. Possible values include: downgrades, maintains, reinstates, reiterates, upgrades, assumes, initiates_coverage_on, terminates_coverage_on, removes, suspends, firm_dissolved. (optional)
     * @param ratingActionAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param ratingActionGt Filter greater than the value. (optional)
     * @param ratingActionGte Filter greater than or equal to the value. (optional)
     * @param ratingActionLt Filter less than the value. (optional)
     * @param ratingActionLte Filter less than or equal to the value. (optional)
     * @param priceTargetAction The description of the directional change in price target. Possible values include: raises, lowers, maintains, announces, sets. (optional)
     * @param priceTargetActionAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param priceTargetActionGt Filter greater than the value. (optional)
     * @param priceTargetActionGte Filter greater than or equal to the value. (optional)
     * @param priceTargetActionLt Filter less than the value. (optional)
     * @param priceTargetActionLte Filter less than or equal to the value. (optional)
     * @param benzingaId The identifer used by Benzinga for this record. (optional)
     * @param benzingaIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaIdGt Filter greater than the value. (optional)
     * @param benzingaIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaIdLt Filter less than the value. (optional)
     * @param benzingaIdLte Filter less than or equal to the value. (optional)
     * @param benzingaAnalystId Filter equal to the value. (optional)
     * @param benzingaAnalystIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaAnalystIdGt Filter greater than the value. (optional)
     * @param benzingaAnalystIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaAnalystIdLt Filter less than the value. (optional)
     * @param benzingaAnalystIdLte Filter less than or equal to the value. (optional)
     * @param benzingaFirmId Filter equal to the value. (optional)
     * @param benzingaFirmIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaFirmIdGt Filter greater than the value. (optional)
     * @param benzingaFirmIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaFirmIdLt Filter less than the value. (optional)
     * @param benzingaFirmIdLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;date&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "date.desc")
     * @return GetBenzingaV1Ratings200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBenzingaV1Ratings(date: kotlin.String? = null, dateAnyOf: kotlin.String? = null, dateGt: kotlin.String? = null, dateGte: kotlin.String? = null, dateLt: kotlin.String? = null, dateLte: kotlin.String? = null, ticker: kotlin.String? = null, tickerAnyOf: kotlin.String? = null, tickerGt: kotlin.String? = null, tickerGte: kotlin.String? = null, tickerLt: kotlin.String? = null, tickerLte: kotlin.String? = null, importance: kotlin.Long? = null, importanceAnyOf: kotlin.String? = null, importanceGt: kotlin.Long? = null, importanceGte: kotlin.Long? = null, importanceLt: kotlin.Long? = null, importanceLte: kotlin.Long? = null, lastUpdated: kotlin.String? = null, lastUpdatedAnyOf: kotlin.String? = null, lastUpdatedGt: kotlin.String? = null, lastUpdatedGte: kotlin.String? = null, lastUpdatedLt: kotlin.String? = null, lastUpdatedLte: kotlin.String? = null, ratingAction: kotlin.String? = null, ratingActionAnyOf: kotlin.String? = null, ratingActionGt: kotlin.String? = null, ratingActionGte: kotlin.String? = null, ratingActionLt: kotlin.String? = null, ratingActionLte: kotlin.String? = null, priceTargetAction: kotlin.String? = null, priceTargetActionAnyOf: kotlin.String? = null, priceTargetActionGt: kotlin.String? = null, priceTargetActionGte: kotlin.String? = null, priceTargetActionLt: kotlin.String? = null, priceTargetActionLte: kotlin.String? = null, benzingaId: kotlin.String? = null, benzingaIdAnyOf: kotlin.String? = null, benzingaIdGt: kotlin.String? = null, benzingaIdGte: kotlin.String? = null, benzingaIdLt: kotlin.String? = null, benzingaIdLte: kotlin.String? = null, benzingaAnalystId: kotlin.String? = null, benzingaAnalystIdAnyOf: kotlin.String? = null, benzingaAnalystIdGt: kotlin.String? = null, benzingaAnalystIdGte: kotlin.String? = null, benzingaAnalystIdLt: kotlin.String? = null, benzingaAnalystIdLte: kotlin.String? = null, benzingaFirmId: kotlin.String? = null, benzingaFirmIdAnyOf: kotlin.String? = null, benzingaFirmIdGt: kotlin.String? = null, benzingaFirmIdGte: kotlin.String? = null, benzingaFirmIdLt: kotlin.String? = null, benzingaFirmIdLte: kotlin.String? = null, limit: kotlin.Int? = 100, sort: kotlin.String? = "date.desc") : GetBenzingaV1Ratings200Response {
        val localVarResponse = getBenzingaV1RatingsWithHttpInfo(date = date, dateAnyOf = dateAnyOf, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, importance = importance, importanceAnyOf = importanceAnyOf, importanceGt = importanceGt, importanceGte = importanceGte, importanceLt = importanceLt, importanceLte = importanceLte, lastUpdated = lastUpdated, lastUpdatedAnyOf = lastUpdatedAnyOf, lastUpdatedGt = lastUpdatedGt, lastUpdatedGte = lastUpdatedGte, lastUpdatedLt = lastUpdatedLt, lastUpdatedLte = lastUpdatedLte, ratingAction = ratingAction, ratingActionAnyOf = ratingActionAnyOf, ratingActionGt = ratingActionGt, ratingActionGte = ratingActionGte, ratingActionLt = ratingActionLt, ratingActionLte = ratingActionLte, priceTargetAction = priceTargetAction, priceTargetActionAnyOf = priceTargetActionAnyOf, priceTargetActionGt = priceTargetActionGt, priceTargetActionGte = priceTargetActionGte, priceTargetActionLt = priceTargetActionLt, priceTargetActionLte = priceTargetActionLte, benzingaId = benzingaId, benzingaIdAnyOf = benzingaIdAnyOf, benzingaIdGt = benzingaIdGt, benzingaIdGte = benzingaIdGte, benzingaIdLt = benzingaIdLt, benzingaIdLte = benzingaIdLte, benzingaAnalystId = benzingaAnalystId, benzingaAnalystIdAnyOf = benzingaAnalystIdAnyOf, benzingaAnalystIdGt = benzingaAnalystIdGt, benzingaAnalystIdGte = benzingaAnalystIdGte, benzingaAnalystIdLt = benzingaAnalystIdLt, benzingaAnalystIdLte = benzingaAnalystIdLte, benzingaFirmId = benzingaFirmId, benzingaFirmIdAnyOf = benzingaFirmIdAnyOf, benzingaFirmIdGt = benzingaFirmIdGt, benzingaFirmIdGte = benzingaFirmIdGte, benzingaFirmIdLt = benzingaFirmIdLt, benzingaFirmIdLte = benzingaFirmIdLte, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetBenzingaV1Ratings200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /benzinga/v1/ratings
     * 
     * 
     * @param date The calendar date (formatted as YYYY-MM-DD) when the rating was issued. (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param ticker The stock symbol of the company being rated. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param importance A subjective indicator of the importance of the earnings event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer. (optional)
     * @param importanceAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param importanceGt Filter greater than the value. Value must be an integer. (optional)
     * @param importanceGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param importanceLt Filter less than the value. Value must be an integer. (optional)
     * @param importanceLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param lastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the rating was last updated in the system. (optional)
     * @param lastUpdatedAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param lastUpdatedGt Filter greater than the value. (optional)
     * @param lastUpdatedGte Filter greater than or equal to the value. (optional)
     * @param lastUpdatedLt Filter less than the value. (optional)
     * @param lastUpdatedLte Filter less than or equal to the value. (optional)
     * @param ratingAction The description of the change in rating from the firm&#39;s last rating. Possible values include: downgrades, maintains, reinstates, reiterates, upgrades, assumes, initiates_coverage_on, terminates_coverage_on, removes, suspends, firm_dissolved. (optional)
     * @param ratingActionAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param ratingActionGt Filter greater than the value. (optional)
     * @param ratingActionGte Filter greater than or equal to the value. (optional)
     * @param ratingActionLt Filter less than the value. (optional)
     * @param ratingActionLte Filter less than or equal to the value. (optional)
     * @param priceTargetAction The description of the directional change in price target. Possible values include: raises, lowers, maintains, announces, sets. (optional)
     * @param priceTargetActionAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param priceTargetActionGt Filter greater than the value. (optional)
     * @param priceTargetActionGte Filter greater than or equal to the value. (optional)
     * @param priceTargetActionLt Filter less than the value. (optional)
     * @param priceTargetActionLte Filter less than or equal to the value. (optional)
     * @param benzingaId The identifer used by Benzinga for this record. (optional)
     * @param benzingaIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaIdGt Filter greater than the value. (optional)
     * @param benzingaIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaIdLt Filter less than the value. (optional)
     * @param benzingaIdLte Filter less than or equal to the value. (optional)
     * @param benzingaAnalystId Filter equal to the value. (optional)
     * @param benzingaAnalystIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaAnalystIdGt Filter greater than the value. (optional)
     * @param benzingaAnalystIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaAnalystIdLt Filter less than the value. (optional)
     * @param benzingaAnalystIdLte Filter less than or equal to the value. (optional)
     * @param benzingaFirmId Filter equal to the value. (optional)
     * @param benzingaFirmIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaFirmIdGt Filter greater than the value. (optional)
     * @param benzingaFirmIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaFirmIdLt Filter less than the value. (optional)
     * @param benzingaFirmIdLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;date&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "date.desc")
     * @return ApiResponse<GetBenzingaV1Ratings200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBenzingaV1RatingsWithHttpInfo(date: kotlin.String?, dateAnyOf: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, importance: kotlin.Long?, importanceAnyOf: kotlin.String?, importanceGt: kotlin.Long?, importanceGte: kotlin.Long?, importanceLt: kotlin.Long?, importanceLte: kotlin.Long?, lastUpdated: kotlin.String?, lastUpdatedAnyOf: kotlin.String?, lastUpdatedGt: kotlin.String?, lastUpdatedGte: kotlin.String?, lastUpdatedLt: kotlin.String?, lastUpdatedLte: kotlin.String?, ratingAction: kotlin.String?, ratingActionAnyOf: kotlin.String?, ratingActionGt: kotlin.String?, ratingActionGte: kotlin.String?, ratingActionLt: kotlin.String?, ratingActionLte: kotlin.String?, priceTargetAction: kotlin.String?, priceTargetActionAnyOf: kotlin.String?, priceTargetActionGt: kotlin.String?, priceTargetActionGte: kotlin.String?, priceTargetActionLt: kotlin.String?, priceTargetActionLte: kotlin.String?, benzingaId: kotlin.String?, benzingaIdAnyOf: kotlin.String?, benzingaIdGt: kotlin.String?, benzingaIdGte: kotlin.String?, benzingaIdLt: kotlin.String?, benzingaIdLte: kotlin.String?, benzingaAnalystId: kotlin.String?, benzingaAnalystIdAnyOf: kotlin.String?, benzingaAnalystIdGt: kotlin.String?, benzingaAnalystIdGte: kotlin.String?, benzingaAnalystIdLt: kotlin.String?, benzingaAnalystIdLte: kotlin.String?, benzingaFirmId: kotlin.String?, benzingaFirmIdAnyOf: kotlin.String?, benzingaFirmIdGt: kotlin.String?, benzingaFirmIdGte: kotlin.String?, benzingaFirmIdLt: kotlin.String?, benzingaFirmIdLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetBenzingaV1Ratings200Response?> {
        val localVariableConfig = getBenzingaV1RatingsRequestConfig(date = date, dateAnyOf = dateAnyOf, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, importance = importance, importanceAnyOf = importanceAnyOf, importanceGt = importanceGt, importanceGte = importanceGte, importanceLt = importanceLt, importanceLte = importanceLte, lastUpdated = lastUpdated, lastUpdatedAnyOf = lastUpdatedAnyOf, lastUpdatedGt = lastUpdatedGt, lastUpdatedGte = lastUpdatedGte, lastUpdatedLt = lastUpdatedLt, lastUpdatedLte = lastUpdatedLte, ratingAction = ratingAction, ratingActionAnyOf = ratingActionAnyOf, ratingActionGt = ratingActionGt, ratingActionGte = ratingActionGte, ratingActionLt = ratingActionLt, ratingActionLte = ratingActionLte, priceTargetAction = priceTargetAction, priceTargetActionAnyOf = priceTargetActionAnyOf, priceTargetActionGt = priceTargetActionGt, priceTargetActionGte = priceTargetActionGte, priceTargetActionLt = priceTargetActionLt, priceTargetActionLte = priceTargetActionLte, benzingaId = benzingaId, benzingaIdAnyOf = benzingaIdAnyOf, benzingaIdGt = benzingaIdGt, benzingaIdGte = benzingaIdGte, benzingaIdLt = benzingaIdLt, benzingaIdLte = benzingaIdLte, benzingaAnalystId = benzingaAnalystId, benzingaAnalystIdAnyOf = benzingaAnalystIdAnyOf, benzingaAnalystIdGt = benzingaAnalystIdGt, benzingaAnalystIdGte = benzingaAnalystIdGte, benzingaAnalystIdLt = benzingaAnalystIdLt, benzingaAnalystIdLte = benzingaAnalystIdLte, benzingaFirmId = benzingaFirmId, benzingaFirmIdAnyOf = benzingaFirmIdAnyOf, benzingaFirmIdGt = benzingaFirmIdGt, benzingaFirmIdGte = benzingaFirmIdGte, benzingaFirmIdLt = benzingaFirmIdLt, benzingaFirmIdLte = benzingaFirmIdLte, limit = limit, sort = sort)

        return request<Unit, GetBenzingaV1Ratings200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBenzingaV1Ratings
     *
     * @param date The calendar date (formatted as YYYY-MM-DD) when the rating was issued. (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param ticker The stock symbol of the company being rated. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param importance A subjective indicator of the importance of the earnings event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer. (optional)
     * @param importanceAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param importanceGt Filter greater than the value. Value must be an integer. (optional)
     * @param importanceGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param importanceLt Filter less than the value. Value must be an integer. (optional)
     * @param importanceLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param lastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the rating was last updated in the system. (optional)
     * @param lastUpdatedAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param lastUpdatedGt Filter greater than the value. (optional)
     * @param lastUpdatedGte Filter greater than or equal to the value. (optional)
     * @param lastUpdatedLt Filter less than the value. (optional)
     * @param lastUpdatedLte Filter less than or equal to the value. (optional)
     * @param ratingAction The description of the change in rating from the firm&#39;s last rating. Possible values include: downgrades, maintains, reinstates, reiterates, upgrades, assumes, initiates_coverage_on, terminates_coverage_on, removes, suspends, firm_dissolved. (optional)
     * @param ratingActionAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param ratingActionGt Filter greater than the value. (optional)
     * @param ratingActionGte Filter greater than or equal to the value. (optional)
     * @param ratingActionLt Filter less than the value. (optional)
     * @param ratingActionLte Filter less than or equal to the value. (optional)
     * @param priceTargetAction The description of the directional change in price target. Possible values include: raises, lowers, maintains, announces, sets. (optional)
     * @param priceTargetActionAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param priceTargetActionGt Filter greater than the value. (optional)
     * @param priceTargetActionGte Filter greater than or equal to the value. (optional)
     * @param priceTargetActionLt Filter less than the value. (optional)
     * @param priceTargetActionLte Filter less than or equal to the value. (optional)
     * @param benzingaId The identifer used by Benzinga for this record. (optional)
     * @param benzingaIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaIdGt Filter greater than the value. (optional)
     * @param benzingaIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaIdLt Filter less than the value. (optional)
     * @param benzingaIdLte Filter less than or equal to the value. (optional)
     * @param benzingaAnalystId Filter equal to the value. (optional)
     * @param benzingaAnalystIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaAnalystIdGt Filter greater than the value. (optional)
     * @param benzingaAnalystIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaAnalystIdLt Filter less than the value. (optional)
     * @param benzingaAnalystIdLte Filter less than or equal to the value. (optional)
     * @param benzingaFirmId Filter equal to the value. (optional)
     * @param benzingaFirmIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaFirmIdGt Filter greater than the value. (optional)
     * @param benzingaFirmIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaFirmIdLt Filter less than the value. (optional)
     * @param benzingaFirmIdLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;date&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "date.desc")
     * @return RequestConfig
     */
    fun getBenzingaV1RatingsRequestConfig(date: kotlin.String?, dateAnyOf: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, importance: kotlin.Long?, importanceAnyOf: kotlin.String?, importanceGt: kotlin.Long?, importanceGte: kotlin.Long?, importanceLt: kotlin.Long?, importanceLte: kotlin.Long?, lastUpdated: kotlin.String?, lastUpdatedAnyOf: kotlin.String?, lastUpdatedGt: kotlin.String?, lastUpdatedGte: kotlin.String?, lastUpdatedLt: kotlin.String?, lastUpdatedLte: kotlin.String?, ratingAction: kotlin.String?, ratingActionAnyOf: kotlin.String?, ratingActionGt: kotlin.String?, ratingActionGte: kotlin.String?, ratingActionLt: kotlin.String?, ratingActionLte: kotlin.String?, priceTargetAction: kotlin.String?, priceTargetActionAnyOf: kotlin.String?, priceTargetActionGt: kotlin.String?, priceTargetActionGte: kotlin.String?, priceTargetActionLt: kotlin.String?, priceTargetActionLte: kotlin.String?, benzingaId: kotlin.String?, benzingaIdAnyOf: kotlin.String?, benzingaIdGt: kotlin.String?, benzingaIdGte: kotlin.String?, benzingaIdLt: kotlin.String?, benzingaIdLte: kotlin.String?, benzingaAnalystId: kotlin.String?, benzingaAnalystIdAnyOf: kotlin.String?, benzingaAnalystIdGt: kotlin.String?, benzingaAnalystIdGte: kotlin.String?, benzingaAnalystIdLt: kotlin.String?, benzingaAnalystIdLte: kotlin.String?, benzingaFirmId: kotlin.String?, benzingaFirmIdAnyOf: kotlin.String?, benzingaFirmIdGt: kotlin.String?, benzingaFirmIdGte: kotlin.String?, benzingaFirmIdLt: kotlin.String?, benzingaFirmIdLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (date != null) {
                    put("date", listOf(date.toString()))
                }
                if (dateAnyOf != null) {
                    put("date.any_of", listOf(dateAnyOf.toString()))
                }
                if (dateGt != null) {
                    put("date.gt", listOf(dateGt.toString()))
                }
                if (dateGte != null) {
                    put("date.gte", listOf(dateGte.toString()))
                }
                if (dateLt != null) {
                    put("date.lt", listOf(dateLt.toString()))
                }
                if (dateLte != null) {
                    put("date.lte", listOf(dateLte.toString()))
                }
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
                if (tickerAnyOf != null) {
                    put("ticker.any_of", listOf(tickerAnyOf.toString()))
                }
                if (tickerGt != null) {
                    put("ticker.gt", listOf(tickerGt.toString()))
                }
                if (tickerGte != null) {
                    put("ticker.gte", listOf(tickerGte.toString()))
                }
                if (tickerLt != null) {
                    put("ticker.lt", listOf(tickerLt.toString()))
                }
                if (tickerLte != null) {
                    put("ticker.lte", listOf(tickerLte.toString()))
                }
                if (importance != null) {
                    put("importance", listOf(importance.toString()))
                }
                if (importanceAnyOf != null) {
                    put("importance.any_of", listOf(importanceAnyOf.toString()))
                }
                if (importanceGt != null) {
                    put("importance.gt", listOf(importanceGt.toString()))
                }
                if (importanceGte != null) {
                    put("importance.gte", listOf(importanceGte.toString()))
                }
                if (importanceLt != null) {
                    put("importance.lt", listOf(importanceLt.toString()))
                }
                if (importanceLte != null) {
                    put("importance.lte", listOf(importanceLte.toString()))
                }
                if (lastUpdated != null) {
                    put("last_updated", listOf(lastUpdated.toString()))
                }
                if (lastUpdatedAnyOf != null) {
                    put("last_updated.any_of", listOf(lastUpdatedAnyOf.toString()))
                }
                if (lastUpdatedGt != null) {
                    put("last_updated.gt", listOf(lastUpdatedGt.toString()))
                }
                if (lastUpdatedGte != null) {
                    put("last_updated.gte", listOf(lastUpdatedGte.toString()))
                }
                if (lastUpdatedLt != null) {
                    put("last_updated.lt", listOf(lastUpdatedLt.toString()))
                }
                if (lastUpdatedLte != null) {
                    put("last_updated.lte", listOf(lastUpdatedLte.toString()))
                }
                if (ratingAction != null) {
                    put("rating_action", listOf(ratingAction.toString()))
                }
                if (ratingActionAnyOf != null) {
                    put("rating_action.any_of", listOf(ratingActionAnyOf.toString()))
                }
                if (ratingActionGt != null) {
                    put("rating_action.gt", listOf(ratingActionGt.toString()))
                }
                if (ratingActionGte != null) {
                    put("rating_action.gte", listOf(ratingActionGte.toString()))
                }
                if (ratingActionLt != null) {
                    put("rating_action.lt", listOf(ratingActionLt.toString()))
                }
                if (ratingActionLte != null) {
                    put("rating_action.lte", listOf(ratingActionLte.toString()))
                }
                if (priceTargetAction != null) {
                    put("price_target_action", listOf(priceTargetAction.toString()))
                }
                if (priceTargetActionAnyOf != null) {
                    put("price_target_action.any_of", listOf(priceTargetActionAnyOf.toString()))
                }
                if (priceTargetActionGt != null) {
                    put("price_target_action.gt", listOf(priceTargetActionGt.toString()))
                }
                if (priceTargetActionGte != null) {
                    put("price_target_action.gte", listOf(priceTargetActionGte.toString()))
                }
                if (priceTargetActionLt != null) {
                    put("price_target_action.lt", listOf(priceTargetActionLt.toString()))
                }
                if (priceTargetActionLte != null) {
                    put("price_target_action.lte", listOf(priceTargetActionLte.toString()))
                }
                if (benzingaId != null) {
                    put("benzinga_id", listOf(benzingaId.toString()))
                }
                if (benzingaIdAnyOf != null) {
                    put("benzinga_id.any_of", listOf(benzingaIdAnyOf.toString()))
                }
                if (benzingaIdGt != null) {
                    put("benzinga_id.gt", listOf(benzingaIdGt.toString()))
                }
                if (benzingaIdGte != null) {
                    put("benzinga_id.gte", listOf(benzingaIdGte.toString()))
                }
                if (benzingaIdLt != null) {
                    put("benzinga_id.lt", listOf(benzingaIdLt.toString()))
                }
                if (benzingaIdLte != null) {
                    put("benzinga_id.lte", listOf(benzingaIdLte.toString()))
                }
                if (benzingaAnalystId != null) {
                    put("benzinga_analyst_id", listOf(benzingaAnalystId.toString()))
                }
                if (benzingaAnalystIdAnyOf != null) {
                    put("benzinga_analyst_id.any_of", listOf(benzingaAnalystIdAnyOf.toString()))
                }
                if (benzingaAnalystIdGt != null) {
                    put("benzinga_analyst_id.gt", listOf(benzingaAnalystIdGt.toString()))
                }
                if (benzingaAnalystIdGte != null) {
                    put("benzinga_analyst_id.gte", listOf(benzingaAnalystIdGte.toString()))
                }
                if (benzingaAnalystIdLt != null) {
                    put("benzinga_analyst_id.lt", listOf(benzingaAnalystIdLt.toString()))
                }
                if (benzingaAnalystIdLte != null) {
                    put("benzinga_analyst_id.lte", listOf(benzingaAnalystIdLte.toString()))
                }
                if (benzingaFirmId != null) {
                    put("benzinga_firm_id", listOf(benzingaFirmId.toString()))
                }
                if (benzingaFirmIdAnyOf != null) {
                    put("benzinga_firm_id.any_of", listOf(benzingaFirmIdAnyOf.toString()))
                }
                if (benzingaFirmIdGt != null) {
                    put("benzinga_firm_id.gt", listOf(benzingaFirmIdGt.toString()))
                }
                if (benzingaFirmIdGte != null) {
                    put("benzinga_firm_id.gte", listOf(benzingaFirmIdGte.toString()))
                }
                if (benzingaFirmIdLt != null) {
                    put("benzinga_firm_id.lt", listOf(benzingaFirmIdLt.toString()))
                }
                if (benzingaFirmIdLte != null) {
                    put("benzinga_firm_id.lte", listOf(benzingaFirmIdLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/benzinga/v1/ratings",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter timespan
     */
     enum class TimespanGetCryptoAggregates(val value: kotlin.String) {
         @Json(name = "second") second("second"),
         @Json(name = "minute") minute("minute"),
         @Json(name = "hour") hour("hour"),
         @Json(name = "day") day("day"),
         @Json(name = "week") week("week"),
         @Json(name = "month") month("month"),
         @Json(name = "quarter") quarter("quarter"),
         @Json(name = "year") year("year");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortGetCryptoAggregates(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v2/aggs/ticker/{cryptoTicker}/range/{multiplier}/{timespan}/{from}/{to}
     * Aggregates (Bars)
     * Get aggregate bars for a cryptocurrency pair over a given date range in custom time window sizes. &lt;br /&gt; &lt;br /&gt; For example, if timespan &#x3D; ‘minute’ and multiplier &#x3D; ‘5’ then 5-minute bars will be returned. 
     * @param cryptoTicker The ticker symbol of the currency pair.
     * @param multiplier The size of the timespan multiplier.
     * @param timespan The size of the time window.
     * @param from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @param sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top).  (optional)
     * @param limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;.  (optional)
     * @return GetCryptoAggregates200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getCryptoAggregates(cryptoTicker: kotlin.String, multiplier: kotlin.Int, timespan: TimespanGetCryptoAggregates, from: kotlin.String, to: kotlin.String, adjusted: kotlin.Boolean? = null, sort: SortGetCryptoAggregates? = null, limit: kotlin.Int? = null) : GetCryptoAggregates200Response {
        val localVarResponse = getCryptoAggregatesWithHttpInfo(cryptoTicker = cryptoTicker, multiplier = multiplier, timespan = timespan, from = from, to = to, adjusted = adjusted, sort = sort, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoAggregates200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/aggs/ticker/{cryptoTicker}/range/{multiplier}/{timespan}/{from}/{to}
     * Aggregates (Bars)
     * Get aggregate bars for a cryptocurrency pair over a given date range in custom time window sizes. &lt;br /&gt; &lt;br /&gt; For example, if timespan &#x3D; ‘minute’ and multiplier &#x3D; ‘5’ then 5-minute bars will be returned. 
     * @param cryptoTicker The ticker symbol of the currency pair.
     * @param multiplier The size of the timespan multiplier.
     * @param timespan The size of the time window.
     * @param from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @param sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top).  (optional)
     * @param limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;.  (optional)
     * @return ApiResponse<GetCryptoAggregates200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getCryptoAggregatesWithHttpInfo(cryptoTicker: kotlin.String, multiplier: kotlin.Int, timespan: TimespanGetCryptoAggregates, from: kotlin.String, to: kotlin.String, adjusted: kotlin.Boolean?, sort: SortGetCryptoAggregates?, limit: kotlin.Int?) : ApiResponse<GetCryptoAggregates200Response?> {
        val localVariableConfig = getCryptoAggregatesRequestConfig(cryptoTicker = cryptoTicker, multiplier = multiplier, timespan = timespan, from = from, to = to, adjusted = adjusted, sort = sort, limit = limit)

        return request<Unit, GetCryptoAggregates200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCryptoAggregates
     *
     * @param cryptoTicker The ticker symbol of the currency pair.
     * @param multiplier The size of the timespan multiplier.
     * @param timespan The size of the time window.
     * @param from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @param sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top).  (optional)
     * @param limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;.  (optional)
     * @return RequestConfig
     */
    fun getCryptoAggregatesRequestConfig(cryptoTicker: kotlin.String, multiplier: kotlin.Int, timespan: TimespanGetCryptoAggregates, from: kotlin.String, to: kotlin.String, adjusted: kotlin.Boolean?, sort: SortGetCryptoAggregates?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/aggs/ticker/{cryptoTicker}/range/{multiplier}/{timespan}/{from}/{to}".replace("{"+"cryptoTicker"+"}", encodeURIComponent(cryptoTicker.toString())).replace("{"+"multiplier"+"}", encodeURIComponent(multiplier.toString())).replace("{"+"timespan"+"}", encodeURIComponent(timespan.value.toString())).replace("{"+"from"+"}", encodeURIComponent(from.toString())).replace("{"+"to"+"}", encodeURIComponent(to.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter timespan
     */
     enum class TimespanGetCryptoEMA(val value: kotlin.String) {
         @Json(name = "minute") minute("minute"),
         @Json(name = "hour") hour("hour"),
         @Json(name = "day") day("day"),
         @Json(name = "week") week("week"),
         @Json(name = "month") month("month"),
         @Json(name = "quarter") quarter("quarter"),
         @Json(name = "year") year("year");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter seriesType
     */
     enum class SeriesTypeGetCryptoEMA(val value: kotlin.String) {
         @Json(name = "open") `open`("open"),
         @Json(name = "high") high("high"),
         @Json(name = "low") low("low"),
         @Json(name = "close") close("close");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderGetCryptoEMA(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v1/indicators/ema/{cryptoTicker}
     * Exponential Moving Average (EMA)
     * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
     * @param cryptoTicker The ticker symbol for which to get exponential moving average (EMA) data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param window The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param seriesType The price in the aggregate which will be used to calculate the exponential moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the exponential moving average (EMA). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return GetCryptoEMA200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getCryptoEMA(cryptoTicker: kotlin.String, timestamp: kotlin.String? = null, timespan: TimespanGetCryptoEMA? = TimespanGetCryptoEMA.day, window: kotlin.Int? = 50, seriesType: SeriesTypeGetCryptoEMA? = SeriesTypeGetCryptoEMA.close, expandUnderlying: kotlin.Boolean? = false, order: OrderGetCryptoEMA? = OrderGetCryptoEMA.desc, limit: kotlin.Int? = 10, timestampGte: kotlin.String? = null, timestampGt: kotlin.String? = null, timestampLte: kotlin.String? = null, timestampLt: kotlin.String? = null) : GetCryptoEMA200Response {
        val localVarResponse = getCryptoEMAWithHttpInfo(cryptoTicker = cryptoTicker, timestamp = timestamp, timespan = timespan, window = window, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoEMA200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/indicators/ema/{cryptoTicker}
     * Exponential Moving Average (EMA)
     * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
     * @param cryptoTicker The ticker symbol for which to get exponential moving average (EMA) data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param window The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param seriesType The price in the aggregate which will be used to calculate the exponential moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the exponential moving average (EMA). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return ApiResponse<GetCryptoEMA200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getCryptoEMAWithHttpInfo(cryptoTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetCryptoEMA?, window: kotlin.Int?, seriesType: SeriesTypeGetCryptoEMA?, expandUnderlying: kotlin.Boolean?, order: OrderGetCryptoEMA?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : ApiResponse<GetCryptoEMA200Response?> {
        val localVariableConfig = getCryptoEMARequestConfig(cryptoTicker = cryptoTicker, timestamp = timestamp, timespan = timespan, window = window, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return request<Unit, GetCryptoEMA200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCryptoEMA
     *
     * @param cryptoTicker The ticker symbol for which to get exponential moving average (EMA) data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param window The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param seriesType The price in the aggregate which will be used to calculate the exponential moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the exponential moving average (EMA). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return RequestConfig
     */
    fun getCryptoEMARequestConfig(cryptoTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetCryptoEMA?, window: kotlin.Int?, seriesType: SeriesTypeGetCryptoEMA?, expandUnderlying: kotlin.Boolean?, order: OrderGetCryptoEMA?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (timespan != null) {
                    put("timespan", listOf(timespan.value))
                }
                if (window != null) {
                    put("window", listOf(window.toString()))
                }
                if (seriesType != null) {
                    put("series_type", listOf(seriesType.value))
                }
                if (expandUnderlying != null) {
                    put("expand_underlying", listOf(expandUnderlying.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (timestampGte != null) {
                    put("timestamp.gte", listOf(timestampGte.toString()))
                }
                if (timestampGt != null) {
                    put("timestamp.gt", listOf(timestampGt.toString()))
                }
                if (timestampLte != null) {
                    put("timestamp.lte", listOf(timestampLte.toString()))
                }
                if (timestampLt != null) {
                    put("timestamp.lt", listOf(timestampLt.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/indicators/ema/{cryptoTicker}".replace("{"+"cryptoTicker"+"}", encodeURIComponent(cryptoTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter timespan
     */
     enum class TimespanGetCryptoMACD(val value: kotlin.String) {
         @Json(name = "minute") minute("minute"),
         @Json(name = "hour") hour("hour"),
         @Json(name = "day") day("day"),
         @Json(name = "week") week("week"),
         @Json(name = "month") month("month"),
         @Json(name = "quarter") quarter("quarter"),
         @Json(name = "year") year("year");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter seriesType
     */
     enum class SeriesTypeGetCryptoMACD(val value: kotlin.String) {
         @Json(name = "open") `open`("open"),
         @Json(name = "high") high("high"),
         @Json(name = "low") low("low"),
         @Json(name = "close") close("close");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderGetCryptoMACD(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v1/indicators/macd/{cryptoTicker}
     * Moving Average Convergence/Divergence (MACD)
     * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
     * @param cryptoTicker The ticker symbol for which to get MACD data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param shortWindow The short window size used to calculate MACD data. (optional, default to 12)
     * @param longWindow The long window size used to calculate MACD data. (optional, default to 26)
     * @param signalWindow The window size used to calculate the MACD signal line. (optional, default to 9)
     * @param seriesType The price in the aggregate which will be used to calculate MACD data. i.e. &#39;close&#39; will result in using close prices to  calculate the MACD. (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return GetCryptoMACD200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getCryptoMACD(cryptoTicker: kotlin.String, timestamp: kotlin.String? = null, timespan: TimespanGetCryptoMACD? = TimespanGetCryptoMACD.day, shortWindow: kotlin.Int? = 12, longWindow: kotlin.Int? = 26, signalWindow: kotlin.Int? = 9, seriesType: SeriesTypeGetCryptoMACD? = SeriesTypeGetCryptoMACD.close, expandUnderlying: kotlin.Boolean? = false, order: OrderGetCryptoMACD? = OrderGetCryptoMACD.desc, limit: kotlin.Int? = 10, timestampGte: kotlin.String? = null, timestampGt: kotlin.String? = null, timestampLte: kotlin.String? = null, timestampLt: kotlin.String? = null) : GetCryptoMACD200Response {
        val localVarResponse = getCryptoMACDWithHttpInfo(cryptoTicker = cryptoTicker, timestamp = timestamp, timespan = timespan, shortWindow = shortWindow, longWindow = longWindow, signalWindow = signalWindow, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoMACD200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/indicators/macd/{cryptoTicker}
     * Moving Average Convergence/Divergence (MACD)
     * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
     * @param cryptoTicker The ticker symbol for which to get MACD data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param shortWindow The short window size used to calculate MACD data. (optional, default to 12)
     * @param longWindow The long window size used to calculate MACD data. (optional, default to 26)
     * @param signalWindow The window size used to calculate the MACD signal line. (optional, default to 9)
     * @param seriesType The price in the aggregate which will be used to calculate MACD data. i.e. &#39;close&#39; will result in using close prices to  calculate the MACD. (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return ApiResponse<GetCryptoMACD200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getCryptoMACDWithHttpInfo(cryptoTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetCryptoMACD?, shortWindow: kotlin.Int?, longWindow: kotlin.Int?, signalWindow: kotlin.Int?, seriesType: SeriesTypeGetCryptoMACD?, expandUnderlying: kotlin.Boolean?, order: OrderGetCryptoMACD?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : ApiResponse<GetCryptoMACD200Response?> {
        val localVariableConfig = getCryptoMACDRequestConfig(cryptoTicker = cryptoTicker, timestamp = timestamp, timespan = timespan, shortWindow = shortWindow, longWindow = longWindow, signalWindow = signalWindow, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return request<Unit, GetCryptoMACD200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCryptoMACD
     *
     * @param cryptoTicker The ticker symbol for which to get MACD data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param shortWindow The short window size used to calculate MACD data. (optional, default to 12)
     * @param longWindow The long window size used to calculate MACD data. (optional, default to 26)
     * @param signalWindow The window size used to calculate the MACD signal line. (optional, default to 9)
     * @param seriesType The price in the aggregate which will be used to calculate MACD data. i.e. &#39;close&#39; will result in using close prices to  calculate the MACD. (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return RequestConfig
     */
    fun getCryptoMACDRequestConfig(cryptoTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetCryptoMACD?, shortWindow: kotlin.Int?, longWindow: kotlin.Int?, signalWindow: kotlin.Int?, seriesType: SeriesTypeGetCryptoMACD?, expandUnderlying: kotlin.Boolean?, order: OrderGetCryptoMACD?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (timespan != null) {
                    put("timespan", listOf(timespan.value))
                }
                if (shortWindow != null) {
                    put("short_window", listOf(shortWindow.toString()))
                }
                if (longWindow != null) {
                    put("long_window", listOf(longWindow.toString()))
                }
                if (signalWindow != null) {
                    put("signal_window", listOf(signalWindow.toString()))
                }
                if (seriesType != null) {
                    put("series_type", listOf(seriesType.value))
                }
                if (expandUnderlying != null) {
                    put("expand_underlying", listOf(expandUnderlying.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (timestampGte != null) {
                    put("timestamp.gte", listOf(timestampGte.toString()))
                }
                if (timestampGt != null) {
                    put("timestamp.gt", listOf(timestampGt.toString()))
                }
                if (timestampLte != null) {
                    put("timestamp.lte", listOf(timestampLte.toString()))
                }
                if (timestampLt != null) {
                    put("timestamp.lt", listOf(timestampLt.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/indicators/macd/{cryptoTicker}".replace("{"+"cryptoTicker"+"}", encodeURIComponent(cryptoTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/open-close/crypto/{from}/{to}/{date}
     * Daily Open/Close
     * Get the open, close prices of a cryptocurrency symbol on a certain day. 
     * @param from The \&quot;from\&quot; symbol of the pair.
     * @param to The \&quot;to\&quot; symbol of the pair.
     * @param date The date of the requested open/close in the format YYYY-MM-DD.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return GetCryptoOpenClose200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getCryptoOpenClose(from: kotlin.String, to: kotlin.String, date: java.time.LocalDate, adjusted: kotlin.Boolean? = null) : GetCryptoOpenClose200Response {
        val localVarResponse = getCryptoOpenCloseWithHttpInfo(from = from, to = to, date = date, adjusted = adjusted)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoOpenClose200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/open-close/crypto/{from}/{to}/{date}
     * Daily Open/Close
     * Get the open, close prices of a cryptocurrency symbol on a certain day. 
     * @param from The \&quot;from\&quot; symbol of the pair.
     * @param to The \&quot;to\&quot; symbol of the pair.
     * @param date The date of the requested open/close in the format YYYY-MM-DD.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return ApiResponse<GetCryptoOpenClose200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getCryptoOpenCloseWithHttpInfo(from: kotlin.String, to: kotlin.String, date: java.time.LocalDate, adjusted: kotlin.Boolean?) : ApiResponse<GetCryptoOpenClose200Response?> {
        val localVariableConfig = getCryptoOpenCloseRequestConfig(from = from, to = to, date = date, adjusted = adjusted)

        return request<Unit, GetCryptoOpenClose200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCryptoOpenClose
     *
     * @param from The \&quot;from\&quot; symbol of the pair.
     * @param to The \&quot;to\&quot; symbol of the pair.
     * @param date The date of the requested open/close in the format YYYY-MM-DD.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return RequestConfig
     */
    fun getCryptoOpenCloseRequestConfig(from: kotlin.String, to: kotlin.String, date: java.time.LocalDate, adjusted: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/open-close/crypto/{from}/{to}/{date}".replace("{"+"from"+"}", encodeURIComponent(from.toString())).replace("{"+"to"+"}", encodeURIComponent(to.toString())).replace("{"+"date"+"}", encodeURIComponent(date.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter timespan
     */
     enum class TimespanGetCryptoRSI(val value: kotlin.String) {
         @Json(name = "minute") minute("minute"),
         @Json(name = "hour") hour("hour"),
         @Json(name = "day") day("day"),
         @Json(name = "week") week("week"),
         @Json(name = "month") month("month"),
         @Json(name = "quarter") quarter("quarter"),
         @Json(name = "year") year("year");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter seriesType
     */
     enum class SeriesTypeGetCryptoRSI(val value: kotlin.String) {
         @Json(name = "open") `open`("open"),
         @Json(name = "high") high("high"),
         @Json(name = "low") low("low"),
         @Json(name = "close") close("close");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderGetCryptoRSI(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v1/indicators/rsi/{cryptoTicker}
     * Relative Strength Index (RSI)
     * Get the relative strength index (RSI) for a ticker symbol over a given time range.
     * @param cryptoTicker The ticker symbol for which to get relative strength index (RSI) data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param window The window size used to calculate the relative strength index (RSI). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 14)
     * @param seriesType The price in the aggregate which will be used to calculate the relative strength index. i.e. &#39;close&#39; will result in using close prices to  calculate the relative strength index (RSI). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return GetCryptoRSI200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getCryptoRSI(cryptoTicker: kotlin.String, timestamp: kotlin.String? = null, timespan: TimespanGetCryptoRSI? = TimespanGetCryptoRSI.day, window: kotlin.Int? = 14, seriesType: SeriesTypeGetCryptoRSI? = SeriesTypeGetCryptoRSI.close, expandUnderlying: kotlin.Boolean? = false, order: OrderGetCryptoRSI? = OrderGetCryptoRSI.desc, limit: kotlin.Int? = 10, timestampGte: kotlin.String? = null, timestampGt: kotlin.String? = null, timestampLte: kotlin.String? = null, timestampLt: kotlin.String? = null) : GetCryptoRSI200Response {
        val localVarResponse = getCryptoRSIWithHttpInfo(cryptoTicker = cryptoTicker, timestamp = timestamp, timespan = timespan, window = window, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoRSI200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/indicators/rsi/{cryptoTicker}
     * Relative Strength Index (RSI)
     * Get the relative strength index (RSI) for a ticker symbol over a given time range.
     * @param cryptoTicker The ticker symbol for which to get relative strength index (RSI) data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param window The window size used to calculate the relative strength index (RSI). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 14)
     * @param seriesType The price in the aggregate which will be used to calculate the relative strength index. i.e. &#39;close&#39; will result in using close prices to  calculate the relative strength index (RSI). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return ApiResponse<GetCryptoRSI200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getCryptoRSIWithHttpInfo(cryptoTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetCryptoRSI?, window: kotlin.Int?, seriesType: SeriesTypeGetCryptoRSI?, expandUnderlying: kotlin.Boolean?, order: OrderGetCryptoRSI?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : ApiResponse<GetCryptoRSI200Response?> {
        val localVariableConfig = getCryptoRSIRequestConfig(cryptoTicker = cryptoTicker, timestamp = timestamp, timespan = timespan, window = window, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return request<Unit, GetCryptoRSI200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCryptoRSI
     *
     * @param cryptoTicker The ticker symbol for which to get relative strength index (RSI) data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param window The window size used to calculate the relative strength index (RSI). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 14)
     * @param seriesType The price in the aggregate which will be used to calculate the relative strength index. i.e. &#39;close&#39; will result in using close prices to  calculate the relative strength index (RSI). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return RequestConfig
     */
    fun getCryptoRSIRequestConfig(cryptoTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetCryptoRSI?, window: kotlin.Int?, seriesType: SeriesTypeGetCryptoRSI?, expandUnderlying: kotlin.Boolean?, order: OrderGetCryptoRSI?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (timespan != null) {
                    put("timespan", listOf(timespan.value))
                }
                if (window != null) {
                    put("window", listOf(window.toString()))
                }
                if (seriesType != null) {
                    put("series_type", listOf(seriesType.value))
                }
                if (expandUnderlying != null) {
                    put("expand_underlying", listOf(expandUnderlying.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (timestampGte != null) {
                    put("timestamp.gte", listOf(timestampGte.toString()))
                }
                if (timestampGt != null) {
                    put("timestamp.gt", listOf(timestampGt.toString()))
                }
                if (timestampLte != null) {
                    put("timestamp.lte", listOf(timestampLte.toString()))
                }
                if (timestampLt != null) {
                    put("timestamp.lt", listOf(timestampLt.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/indicators/rsi/{cryptoTicker}".replace("{"+"cryptoTicker"+"}", encodeURIComponent(cryptoTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter timespan
     */
     enum class TimespanGetCryptoSMA(val value: kotlin.String) {
         @Json(name = "minute") minute("minute"),
         @Json(name = "hour") hour("hour"),
         @Json(name = "day") day("day"),
         @Json(name = "week") week("week"),
         @Json(name = "month") month("month"),
         @Json(name = "quarter") quarter("quarter"),
         @Json(name = "year") year("year");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter seriesType
     */
     enum class SeriesTypeGetCryptoSMA(val value: kotlin.String) {
         @Json(name = "open") `open`("open"),
         @Json(name = "high") high("high"),
         @Json(name = "low") low("low"),
         @Json(name = "close") close("close");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderGetCryptoSMA(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v1/indicators/sma/{cryptoTicker}
     * Simple Moving Average (SMA)
     * Get the simple moving average (SMA) for a ticker symbol over a given time range.
     * @param cryptoTicker The ticker symbol for which to get simple moving average (SMA) data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param window The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param seriesType The price in the aggregate which will be used to calculate the simple moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the simple moving average (SMA). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return GetCryptoSMA200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getCryptoSMA(cryptoTicker: kotlin.String, timestamp: kotlin.String? = null, timespan: TimespanGetCryptoSMA? = TimespanGetCryptoSMA.day, window: kotlin.Int? = 50, seriesType: SeriesTypeGetCryptoSMA? = SeriesTypeGetCryptoSMA.close, expandUnderlying: kotlin.Boolean? = false, order: OrderGetCryptoSMA? = OrderGetCryptoSMA.desc, limit: kotlin.Int? = 10, timestampGte: kotlin.String? = null, timestampGt: kotlin.String? = null, timestampLte: kotlin.String? = null, timestampLt: kotlin.String? = null) : GetCryptoSMA200Response {
        val localVarResponse = getCryptoSMAWithHttpInfo(cryptoTicker = cryptoTicker, timestamp = timestamp, timespan = timespan, window = window, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoSMA200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/indicators/sma/{cryptoTicker}
     * Simple Moving Average (SMA)
     * Get the simple moving average (SMA) for a ticker symbol over a given time range.
     * @param cryptoTicker The ticker symbol for which to get simple moving average (SMA) data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param window The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param seriesType The price in the aggregate which will be used to calculate the simple moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the simple moving average (SMA). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return ApiResponse<GetCryptoSMA200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getCryptoSMAWithHttpInfo(cryptoTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetCryptoSMA?, window: kotlin.Int?, seriesType: SeriesTypeGetCryptoSMA?, expandUnderlying: kotlin.Boolean?, order: OrderGetCryptoSMA?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : ApiResponse<GetCryptoSMA200Response?> {
        val localVariableConfig = getCryptoSMARequestConfig(cryptoTicker = cryptoTicker, timestamp = timestamp, timespan = timespan, window = window, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return request<Unit, GetCryptoSMA200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCryptoSMA
     *
     * @param cryptoTicker The ticker symbol for which to get simple moving average (SMA) data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param window The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param seriesType The price in the aggregate which will be used to calculate the simple moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the simple moving average (SMA). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return RequestConfig
     */
    fun getCryptoSMARequestConfig(cryptoTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetCryptoSMA?, window: kotlin.Int?, seriesType: SeriesTypeGetCryptoSMA?, expandUnderlying: kotlin.Boolean?, order: OrderGetCryptoSMA?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (timespan != null) {
                    put("timespan", listOf(timespan.value))
                }
                if (window != null) {
                    put("window", listOf(window.toString()))
                }
                if (seriesType != null) {
                    put("series_type", listOf(seriesType.value))
                }
                if (expandUnderlying != null) {
                    put("expand_underlying", listOf(expandUnderlying.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (timestampGte != null) {
                    put("timestamp.gte", listOf(timestampGte.toString()))
                }
                if (timestampGt != null) {
                    put("timestamp.gt", listOf(timestampGt.toString()))
                }
                if (timestampLte != null) {
                    put("timestamp.lte", listOf(timestampLte.toString()))
                }
                if (timestampLt != null) {
                    put("timestamp.lt", listOf(timestampLt.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/indicators/sma/{cryptoTicker}".replace("{"+"cryptoTicker"+"}", encodeURIComponent(cryptoTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter direction
     */
     enum class DirectionGetCryptoSnapshotDirection(val value: kotlin.String) {
         @Json(name = "gainers") gainers("gainers"),
         @Json(name = "losers") losers("losers");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v2/snapshot/locale/global/markets/crypto/{direction}
     * Gainers/Losers
     * Get the current top 20 gainers or losers of the day in cryptocurrency markets. &lt;br /&gt; &lt;br /&gt; Top gainers are those tickers whose price has increased by the highest percentage since the previous day&#39;s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day&#39;s close. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
     * @param direction The direction of the snapshot results to return. 
     * @return GetCryptoSnapshotDirection200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getCryptoSnapshotDirection(direction: DirectionGetCryptoSnapshotDirection) : GetCryptoSnapshotDirection200Response {
        val localVarResponse = getCryptoSnapshotDirectionWithHttpInfo(direction = direction)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoSnapshotDirection200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/snapshot/locale/global/markets/crypto/{direction}
     * Gainers/Losers
     * Get the current top 20 gainers or losers of the day in cryptocurrency markets. &lt;br /&gt; &lt;br /&gt; Top gainers are those tickers whose price has increased by the highest percentage since the previous day&#39;s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day&#39;s close. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
     * @param direction The direction of the snapshot results to return. 
     * @return ApiResponse<GetCryptoSnapshotDirection200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getCryptoSnapshotDirectionWithHttpInfo(direction: DirectionGetCryptoSnapshotDirection) : ApiResponse<GetCryptoSnapshotDirection200Response?> {
        val localVariableConfig = getCryptoSnapshotDirectionRequestConfig(direction = direction)

        return request<Unit, GetCryptoSnapshotDirection200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCryptoSnapshotDirection
     *
     * @param direction The direction of the snapshot results to return. 
     * @return RequestConfig
     */
    fun getCryptoSnapshotDirectionRequestConfig(direction: DirectionGetCryptoSnapshotDirection) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/snapshot/locale/global/markets/crypto/{direction}".replace("{"+"direction"+"}", encodeURIComponent(direction.value.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/snapshot/locale/global/markets/crypto/tickers/{ticker}
     * Ticker
     * Get the current minute, day, and previous day’s aggregate, as well as the last trade and quote for a single traded cryptocurrency symbol. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
     * @param ticker Ticker of the snapshot
     * @return GetCryptoSnapshotTicker200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getCryptoSnapshotTicker(ticker: kotlin.String) : GetCryptoSnapshotTicker200Response {
        val localVarResponse = getCryptoSnapshotTickerWithHttpInfo(ticker = ticker)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoSnapshotTicker200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/snapshot/locale/global/markets/crypto/tickers/{ticker}
     * Ticker
     * Get the current minute, day, and previous day’s aggregate, as well as the last trade and quote for a single traded cryptocurrency symbol. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
     * @param ticker Ticker of the snapshot
     * @return ApiResponse<GetCryptoSnapshotTicker200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getCryptoSnapshotTickerWithHttpInfo(ticker: kotlin.String) : ApiResponse<GetCryptoSnapshotTicker200Response?> {
        val localVariableConfig = getCryptoSnapshotTickerRequestConfig(ticker = ticker)

        return request<Unit, GetCryptoSnapshotTicker200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCryptoSnapshotTicker
     *
     * @param ticker Ticker of the snapshot
     * @return RequestConfig
     */
    fun getCryptoSnapshotTickerRequestConfig(ticker: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/snapshot/locale/global/markets/crypto/tickers/{ticker}".replace("{"+"ticker"+"}", encodeURIComponent(ticker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/snapshot/locale/global/markets/crypto/tickers
     * All Tickers
     * Get the current minute, day, and previous day’s aggregate, as well as the last trade and quote for all traded cryptocurrency symbols. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
     * @param tickers A case-sensitive comma separated list of tickers to get snapshots for. For example, X:BTCUSD, X:ETHBTC, and X:BOBAUSD. Empty string defaults to querying all tickers. (optional)
     * @return GetCryptoSnapshotTickers200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getCryptoSnapshotTickers(tickers: kotlin.collections.List<kotlin.String>? = null) : GetCryptoSnapshotTickers200Response {
        val localVarResponse = getCryptoSnapshotTickersWithHttpInfo(tickers = tickers)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoSnapshotTickers200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/snapshot/locale/global/markets/crypto/tickers
     * All Tickers
     * Get the current minute, day, and previous day’s aggregate, as well as the last trade and quote for all traded cryptocurrency symbols. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
     * @param tickers A case-sensitive comma separated list of tickers to get snapshots for. For example, X:BTCUSD, X:ETHBTC, and X:BOBAUSD. Empty string defaults to querying all tickers. (optional)
     * @return ApiResponse<GetCryptoSnapshotTickers200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getCryptoSnapshotTickersWithHttpInfo(tickers: kotlin.collections.List<kotlin.String>?) : ApiResponse<GetCryptoSnapshotTickers200Response?> {
        val localVariableConfig = getCryptoSnapshotTickersRequestConfig(tickers = tickers)

        return request<Unit, GetCryptoSnapshotTickers200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCryptoSnapshotTickers
     *
     * @param tickers A case-sensitive comma separated list of tickers to get snapshots for. For example, X:BTCUSD, X:ETHBTC, and X:BOBAUSD. Empty string defaults to querying all tickers. (optional)
     * @return RequestConfig
     */
    fun getCryptoSnapshotTickersRequestConfig(tickers: kotlin.collections.List<kotlin.String>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (tickers != null) {
                    put("tickers", toMultiValue(tickers.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/snapshot/locale/global/markets/crypto/tickers",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter order
     */
     enum class OrderGetCryptoTrades(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortGetCryptoTrades(val value: kotlin.String) {
         @Json(name = "timestamp") timestamp("timestamp");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v3/trades/{cryptoTicker}
     * Trades
     * Get trades for a crypto ticker symbol in a given time range.
     * @param cryptoTicker The ticker symbol to get trades for.
     * @param timestamp Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp. (optional)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 1000 and max is 50000. (optional, default to 1000)
     * @param sort Sort field used for ordering. (optional, default to timestamp)
     * @return GetCryptoTrades200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getCryptoTrades(cryptoTicker: kotlin.String, timestamp: kotlin.String? = null, timestampGte: kotlin.String? = null, timestampGt: kotlin.String? = null, timestampLte: kotlin.String? = null, timestampLt: kotlin.String? = null, order: OrderGetCryptoTrades? = OrderGetCryptoTrades.desc, limit: kotlin.Int? = 1000, sort: SortGetCryptoTrades? = SortGetCryptoTrades.timestamp) : GetCryptoTrades200Response {
        val localVarResponse = getCryptoTradesWithHttpInfo(cryptoTicker = cryptoTicker, timestamp = timestamp, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt, order = order, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoTrades200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v3/trades/{cryptoTicker}
     * Trades
     * Get trades for a crypto ticker symbol in a given time range.
     * @param cryptoTicker The ticker symbol to get trades for.
     * @param timestamp Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp. (optional)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 1000 and max is 50000. (optional, default to 1000)
     * @param sort Sort field used for ordering. (optional, default to timestamp)
     * @return ApiResponse<GetCryptoTrades200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getCryptoTradesWithHttpInfo(cryptoTicker: kotlin.String, timestamp: kotlin.String?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?, order: OrderGetCryptoTrades?, limit: kotlin.Int?, sort: SortGetCryptoTrades?) : ApiResponse<GetCryptoTrades200Response?> {
        val localVariableConfig = getCryptoTradesRequestConfig(cryptoTicker = cryptoTicker, timestamp = timestamp, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt, order = order, limit = limit, sort = sort)

        return request<Unit, GetCryptoTrades200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCryptoTrades
     *
     * @param cryptoTicker The ticker symbol to get trades for.
     * @param timestamp Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp. (optional)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 1000 and max is 50000. (optional, default to 1000)
     * @param sort Sort field used for ordering. (optional, default to timestamp)
     * @return RequestConfig
     */
    fun getCryptoTradesRequestConfig(cryptoTicker: kotlin.String, timestamp: kotlin.String?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?, order: OrderGetCryptoTrades?, limit: kotlin.Int?, sort: SortGetCryptoTrades?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (timestampGte != null) {
                    put("timestamp.gte", listOf(timestampGte.toString()))
                }
                if (timestampGt != null) {
                    put("timestamp.gt", listOf(timestampGt.toString()))
                }
                if (timestampLte != null) {
                    put("timestamp.lte", listOf(timestampLte.toString()))
                }
                if (timestampLt != null) {
                    put("timestamp.lt", listOf(timestampLt.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v3/trades/{cryptoTicker}".replace("{"+"cryptoTicker"+"}", encodeURIComponent(cryptoTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter precision
     */
     enum class PrecisionGetCurrencyConversion(val value: kotlin.Int) {
         @Json(name = "0") _0(0),
         @Json(name = "1") _1(1),
         @Json(name = "2") _2(2),
         @Json(name = "3") _3(3),
         @Json(name = "4") _4(4);

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v1/conversion/{from}/{to}
     * Real-time Currency Conversion
     * Get currency conversions using the latest market conversion rates. Note than you can convert in both directions. For example USD to CAD or CAD to USD.
     * @param from The \&quot;from\&quot; symbol of the pair.
     * @param to The \&quot;to\&quot; symbol of the pair.
     * @param amount The amount to convert, with a decimal. (optional, default to 1)
     * @param precision The decimal precision of the conversion. Defaults to 2 which is 2 decimal places accuracy. (optional, default to 2)
     * @return GetCurrencyConversion200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getCurrencyConversion(from: kotlin.String, to: kotlin.String, amount: java.math.BigDecimal? = java.math.BigDecimal("1"), precision: PrecisionGetCurrencyConversion? = PrecisionGetCurrencyConversion._2) : GetCurrencyConversion200Response {
        val localVarResponse = getCurrencyConversionWithHttpInfo(from = from, to = to, amount = amount, precision = precision)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCurrencyConversion200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/conversion/{from}/{to}
     * Real-time Currency Conversion
     * Get currency conversions using the latest market conversion rates. Note than you can convert in both directions. For example USD to CAD or CAD to USD.
     * @param from The \&quot;from\&quot; symbol of the pair.
     * @param to The \&quot;to\&quot; symbol of the pair.
     * @param amount The amount to convert, with a decimal. (optional, default to 1)
     * @param precision The decimal precision of the conversion. Defaults to 2 which is 2 decimal places accuracy. (optional, default to 2)
     * @return ApiResponse<GetCurrencyConversion200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getCurrencyConversionWithHttpInfo(from: kotlin.String, to: kotlin.String, amount: java.math.BigDecimal?, precision: PrecisionGetCurrencyConversion?) : ApiResponse<GetCurrencyConversion200Response?> {
        val localVariableConfig = getCurrencyConversionRequestConfig(from = from, to = to, amount = amount, precision = precision)

        return request<Unit, GetCurrencyConversion200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCurrencyConversion
     *
     * @param from The \&quot;from\&quot; symbol of the pair.
     * @param to The \&quot;to\&quot; symbol of the pair.
     * @param amount The amount to convert, with a decimal. (optional, default to 1)
     * @param precision The decimal precision of the conversion. Defaults to 2 which is 2 decimal places accuracy. (optional, default to 2)
     * @return RequestConfig
     */
    fun getCurrencyConversionRequestConfig(from: kotlin.String, to: kotlin.String, amount: java.math.BigDecimal?, precision: PrecisionGetCurrencyConversion?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (amount != null) {
                    put("amount", listOf(amount.toString()))
                }
                if (precision != null) {
                    put("precision", listOf(precision.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/conversion/{from}/{to}".replace("{"+"from"+"}", encodeURIComponent(from.toString())).replace("{"+"to"+"}", encodeURIComponent(to.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /vX/reference/tickers/{id}/events
     * Ticker Events
     * Get a timeline of events for the entity associated with the given ticker, CUSIP, or Composite FIGI.
     * @param id Identifier of an asset. This can currently be a Ticker, CUSIP, or Composite FIGI. When given a ticker, we return events for the entity currently represented by that ticker. To find events for entities previously associated with a ticker, find the relevant identifier using the  [Ticker Details Endpoint](https://polygon.io/docs/stocks/get_v3_reference_tickers__ticker)
     * @param types A comma-separated list of the types of event to include. Currently ticker_change is the only supported event_type. Leave blank to return all supported event_types. (optional)
     * @return GetEvents200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getEvents(id: kotlin.String, types: kotlin.String? = null) : GetEvents200Response {
        val localVarResponse = getEventsWithHttpInfo(id = id, types = types)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetEvents200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /vX/reference/tickers/{id}/events
     * Ticker Events
     * Get a timeline of events for the entity associated with the given ticker, CUSIP, or Composite FIGI.
     * @param id Identifier of an asset. This can currently be a Ticker, CUSIP, or Composite FIGI. When given a ticker, we return events for the entity currently represented by that ticker. To find events for entities previously associated with a ticker, find the relevant identifier using the  [Ticker Details Endpoint](https://polygon.io/docs/stocks/get_v3_reference_tickers__ticker)
     * @param types A comma-separated list of the types of event to include. Currently ticker_change is the only supported event_type. Leave blank to return all supported event_types. (optional)
     * @return ApiResponse<GetEvents200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getEventsWithHttpInfo(id: kotlin.String, types: kotlin.String?) : ApiResponse<GetEvents200Response?> {
        val localVariableConfig = getEventsRequestConfig(id = id, types = types)

        return request<Unit, GetEvents200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getEvents
     *
     * @param id Identifier of an asset. This can currently be a Ticker, CUSIP, or Composite FIGI. When given a ticker, we return events for the entity currently represented by that ticker. To find events for entities previously associated with a ticker, find the relevant identifier using the  [Ticker Details Endpoint](https://polygon.io/docs/stocks/get_v3_reference_tickers__ticker)
     * @param types A comma-separated list of the types of event to include. Currently ticker_change is the only supported event_type. Leave blank to return all supported event_types. (optional)
     * @return RequestConfig
     */
    fun getEventsRequestConfig(id: kotlin.String, types: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (types != null) {
                    put("types", listOf(types.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/vX/reference/tickers/{id}/events".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /fed/v1/treasury-yields
     * 
     * 
     * @param date Calendar date of the yield observation (YYYY‑MM‑DD). (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;date&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "date.asc")
     * @return GetFedV1TreasuryYields200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getFedV1TreasuryYields(date: kotlin.String? = null, dateAnyOf: kotlin.String? = null, dateGt: kotlin.String? = null, dateGte: kotlin.String? = null, dateLt: kotlin.String? = null, dateLte: kotlin.String? = null, limit: kotlin.Int? = 100, sort: kotlin.String? = "date.asc") : GetFedV1TreasuryYields200Response {
        val localVarResponse = getFedV1TreasuryYieldsWithHttpInfo(date = date, dateAnyOf = dateAnyOf, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetFedV1TreasuryYields200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /fed/v1/treasury-yields
     * 
     * 
     * @param date Calendar date of the yield observation (YYYY‑MM‑DD). (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;date&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "date.asc")
     * @return ApiResponse<GetFedV1TreasuryYields200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getFedV1TreasuryYieldsWithHttpInfo(date: kotlin.String?, dateAnyOf: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetFedV1TreasuryYields200Response?> {
        val localVariableConfig = getFedV1TreasuryYieldsRequestConfig(date = date, dateAnyOf = dateAnyOf, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, limit = limit, sort = sort)

        return request<Unit, GetFedV1TreasuryYields200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getFedV1TreasuryYields
     *
     * @param date Calendar date of the yield observation (YYYY‑MM‑DD). (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;date&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "date.asc")
     * @return RequestConfig
     */
    fun getFedV1TreasuryYieldsRequestConfig(date: kotlin.String?, dateAnyOf: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (date != null) {
                    put("date", listOf(date.toString()))
                }
                if (dateAnyOf != null) {
                    put("date.any_of", listOf(dateAnyOf.toString()))
                }
                if (dateGt != null) {
                    put("date.gt", listOf(dateGt.toString()))
                }
                if (dateGte != null) {
                    put("date.gte", listOf(dateGte.toString()))
                }
                if (dateLt != null) {
                    put("date.lt", listOf(dateLt.toString()))
                }
                if (dateLte != null) {
                    put("date.lte", listOf(dateLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/fed/v1/treasury-yields",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter timespan
     */
     enum class TimespanGetForexAggregates(val value: kotlin.String) {
         @Json(name = "second") second("second"),
         @Json(name = "minute") minute("minute"),
         @Json(name = "hour") hour("hour"),
         @Json(name = "day") day("day"),
         @Json(name = "week") week("week"),
         @Json(name = "month") month("month"),
         @Json(name = "quarter") quarter("quarter"),
         @Json(name = "year") year("year");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortGetForexAggregates(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v2/aggs/ticker/{forexTicker}/range/{multiplier}/{timespan}/{from}/{to}
     * Aggregates (Bars)
     * Get aggregate bars for a forex pair over a given date range in custom time window sizes. &lt;br /&gt; &lt;br /&gt; For example, if timespan &#x3D; ‘minute’ and multiplier &#x3D; ‘5’ then 5-minute bars will be returned. 
     * @param forexTicker The ticker symbol of the currency pair.
     * @param multiplier The size of the timespan multiplier.
     * @param timespan The size of the time window.
     * @param from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @param sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top).  (optional)
     * @param limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;.  (optional)
     * @return GetCryptoAggregates200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getForexAggregates(forexTicker: kotlin.String, multiplier: kotlin.Int, timespan: TimespanGetForexAggregates, from: kotlin.String, to: kotlin.String, adjusted: kotlin.Boolean? = null, sort: SortGetForexAggregates? = null, limit: kotlin.Int? = null) : GetCryptoAggregates200Response {
        val localVarResponse = getForexAggregatesWithHttpInfo(forexTicker = forexTicker, multiplier = multiplier, timespan = timespan, from = from, to = to, adjusted = adjusted, sort = sort, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoAggregates200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/aggs/ticker/{forexTicker}/range/{multiplier}/{timespan}/{from}/{to}
     * Aggregates (Bars)
     * Get aggregate bars for a forex pair over a given date range in custom time window sizes. &lt;br /&gt; &lt;br /&gt; For example, if timespan &#x3D; ‘minute’ and multiplier &#x3D; ‘5’ then 5-minute bars will be returned. 
     * @param forexTicker The ticker symbol of the currency pair.
     * @param multiplier The size of the timespan multiplier.
     * @param timespan The size of the time window.
     * @param from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @param sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top).  (optional)
     * @param limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;.  (optional)
     * @return ApiResponse<GetCryptoAggregates200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getForexAggregatesWithHttpInfo(forexTicker: kotlin.String, multiplier: kotlin.Int, timespan: TimespanGetForexAggregates, from: kotlin.String, to: kotlin.String, adjusted: kotlin.Boolean?, sort: SortGetForexAggregates?, limit: kotlin.Int?) : ApiResponse<GetCryptoAggregates200Response?> {
        val localVariableConfig = getForexAggregatesRequestConfig(forexTicker = forexTicker, multiplier = multiplier, timespan = timespan, from = from, to = to, adjusted = adjusted, sort = sort, limit = limit)

        return request<Unit, GetCryptoAggregates200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getForexAggregates
     *
     * @param forexTicker The ticker symbol of the currency pair.
     * @param multiplier The size of the timespan multiplier.
     * @param timespan The size of the time window.
     * @param from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @param sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top).  (optional)
     * @param limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;.  (optional)
     * @return RequestConfig
     */
    fun getForexAggregatesRequestConfig(forexTicker: kotlin.String, multiplier: kotlin.Int, timespan: TimespanGetForexAggregates, from: kotlin.String, to: kotlin.String, adjusted: kotlin.Boolean?, sort: SortGetForexAggregates?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/aggs/ticker/{forexTicker}/range/{multiplier}/{timespan}/{from}/{to}".replace("{"+"forexTicker"+"}", encodeURIComponent(forexTicker.toString())).replace("{"+"multiplier"+"}", encodeURIComponent(multiplier.toString())).replace("{"+"timespan"+"}", encodeURIComponent(timespan.value.toString())).replace("{"+"from"+"}", encodeURIComponent(from.toString())).replace("{"+"to"+"}", encodeURIComponent(to.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter timespan
     */
     enum class TimespanGetForexEMA(val value: kotlin.String) {
         @Json(name = "minute") minute("minute"),
         @Json(name = "hour") hour("hour"),
         @Json(name = "day") day("day"),
         @Json(name = "week") week("week"),
         @Json(name = "month") month("month"),
         @Json(name = "quarter") quarter("quarter"),
         @Json(name = "year") year("year");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter seriesType
     */
     enum class SeriesTypeGetForexEMA(val value: kotlin.String) {
         @Json(name = "open") `open`("open"),
         @Json(name = "high") high("high"),
         @Json(name = "low") low("low"),
         @Json(name = "close") close("close");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderGetForexEMA(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v1/indicators/ema/{fxTicker}
     * Exponential Moving Average (EMA)
     * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
     * @param fxTicker The ticker symbol for which to get exponential moving average (EMA) data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param seriesType The price in the aggregate which will be used to calculate the exponential moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the exponential moving average (EMA). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return GetCryptoEMA200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getForexEMA(fxTicker: kotlin.String, timestamp: kotlin.String? = null, timespan: TimespanGetForexEMA? = TimespanGetForexEMA.day, adjusted: kotlin.Boolean? = true, window: kotlin.Int? = 50, seriesType: SeriesTypeGetForexEMA? = SeriesTypeGetForexEMA.close, expandUnderlying: kotlin.Boolean? = false, order: OrderGetForexEMA? = OrderGetForexEMA.desc, limit: kotlin.Int? = 10, timestampGte: kotlin.String? = null, timestampGt: kotlin.String? = null, timestampLte: kotlin.String? = null, timestampLt: kotlin.String? = null) : GetCryptoEMA200Response {
        val localVarResponse = getForexEMAWithHttpInfo(fxTicker = fxTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, window = window, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoEMA200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/indicators/ema/{fxTicker}
     * Exponential Moving Average (EMA)
     * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
     * @param fxTicker The ticker symbol for which to get exponential moving average (EMA) data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param seriesType The price in the aggregate which will be used to calculate the exponential moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the exponential moving average (EMA). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return ApiResponse<GetCryptoEMA200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getForexEMAWithHttpInfo(fxTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetForexEMA?, adjusted: kotlin.Boolean?, window: kotlin.Int?, seriesType: SeriesTypeGetForexEMA?, expandUnderlying: kotlin.Boolean?, order: OrderGetForexEMA?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : ApiResponse<GetCryptoEMA200Response?> {
        val localVariableConfig = getForexEMARequestConfig(fxTicker = fxTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, window = window, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return request<Unit, GetCryptoEMA200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getForexEMA
     *
     * @param fxTicker The ticker symbol for which to get exponential moving average (EMA) data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param seriesType The price in the aggregate which will be used to calculate the exponential moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the exponential moving average (EMA). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return RequestConfig
     */
    fun getForexEMARequestConfig(fxTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetForexEMA?, adjusted: kotlin.Boolean?, window: kotlin.Int?, seriesType: SeriesTypeGetForexEMA?, expandUnderlying: kotlin.Boolean?, order: OrderGetForexEMA?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (timespan != null) {
                    put("timespan", listOf(timespan.value))
                }
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
                if (window != null) {
                    put("window", listOf(window.toString()))
                }
                if (seriesType != null) {
                    put("series_type", listOf(seriesType.value))
                }
                if (expandUnderlying != null) {
                    put("expand_underlying", listOf(expandUnderlying.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (timestampGte != null) {
                    put("timestamp.gte", listOf(timestampGte.toString()))
                }
                if (timestampGt != null) {
                    put("timestamp.gt", listOf(timestampGt.toString()))
                }
                if (timestampLte != null) {
                    put("timestamp.lte", listOf(timestampLte.toString()))
                }
                if (timestampLt != null) {
                    put("timestamp.lt", listOf(timestampLt.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/indicators/ema/{fxTicker}".replace("{"+"fxTicker"+"}", encodeURIComponent(fxTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter timespan
     */
     enum class TimespanGetForexMACD(val value: kotlin.String) {
         @Json(name = "minute") minute("minute"),
         @Json(name = "hour") hour("hour"),
         @Json(name = "day") day("day"),
         @Json(name = "week") week("week"),
         @Json(name = "month") month("month"),
         @Json(name = "quarter") quarter("quarter"),
         @Json(name = "year") year("year");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter seriesType
     */
     enum class SeriesTypeGetForexMACD(val value: kotlin.String) {
         @Json(name = "open") `open`("open"),
         @Json(name = "high") high("high"),
         @Json(name = "low") low("low"),
         @Json(name = "close") close("close");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderGetForexMACD(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v1/indicators/macd/{fxTicker}
     * Moving Average Convergence/Divergence (MACD)
     * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
     * @param fxTicker The ticker symbol for which to get MACD data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param shortWindow The short window size used to calculate MACD data. (optional, default to 12)
     * @param longWindow The long window size used to calculate MACD data. (optional, default to 26)
     * @param signalWindow The window size used to calculate the MACD signal line. (optional, default to 9)
     * @param seriesType The price in the aggregate which will be used to calculate the MACD. i.e. &#39;close&#39; will result in using close prices to  calculate the MACD. (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return GetCryptoMACD200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getForexMACD(fxTicker: kotlin.String, timestamp: kotlin.String? = null, timespan: TimespanGetForexMACD? = TimespanGetForexMACD.day, adjusted: kotlin.Boolean? = true, shortWindow: kotlin.Int? = 12, longWindow: kotlin.Int? = 26, signalWindow: kotlin.Int? = 9, seriesType: SeriesTypeGetForexMACD? = SeriesTypeGetForexMACD.close, expandUnderlying: kotlin.Boolean? = false, order: OrderGetForexMACD? = OrderGetForexMACD.desc, limit: kotlin.Int? = 10, timestampGte: kotlin.String? = null, timestampGt: kotlin.String? = null, timestampLte: kotlin.String? = null, timestampLt: kotlin.String? = null) : GetCryptoMACD200Response {
        val localVarResponse = getForexMACDWithHttpInfo(fxTicker = fxTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, shortWindow = shortWindow, longWindow = longWindow, signalWindow = signalWindow, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoMACD200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/indicators/macd/{fxTicker}
     * Moving Average Convergence/Divergence (MACD)
     * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
     * @param fxTicker The ticker symbol for which to get MACD data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param shortWindow The short window size used to calculate MACD data. (optional, default to 12)
     * @param longWindow The long window size used to calculate MACD data. (optional, default to 26)
     * @param signalWindow The window size used to calculate the MACD signal line. (optional, default to 9)
     * @param seriesType The price in the aggregate which will be used to calculate the MACD. i.e. &#39;close&#39; will result in using close prices to  calculate the MACD. (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return ApiResponse<GetCryptoMACD200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getForexMACDWithHttpInfo(fxTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetForexMACD?, adjusted: kotlin.Boolean?, shortWindow: kotlin.Int?, longWindow: kotlin.Int?, signalWindow: kotlin.Int?, seriesType: SeriesTypeGetForexMACD?, expandUnderlying: kotlin.Boolean?, order: OrderGetForexMACD?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : ApiResponse<GetCryptoMACD200Response?> {
        val localVariableConfig = getForexMACDRequestConfig(fxTicker = fxTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, shortWindow = shortWindow, longWindow = longWindow, signalWindow = signalWindow, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return request<Unit, GetCryptoMACD200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getForexMACD
     *
     * @param fxTicker The ticker symbol for which to get MACD data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param shortWindow The short window size used to calculate MACD data. (optional, default to 12)
     * @param longWindow The long window size used to calculate MACD data. (optional, default to 26)
     * @param signalWindow The window size used to calculate the MACD signal line. (optional, default to 9)
     * @param seriesType The price in the aggregate which will be used to calculate the MACD. i.e. &#39;close&#39; will result in using close prices to  calculate the MACD. (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return RequestConfig
     */
    fun getForexMACDRequestConfig(fxTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetForexMACD?, adjusted: kotlin.Boolean?, shortWindow: kotlin.Int?, longWindow: kotlin.Int?, signalWindow: kotlin.Int?, seriesType: SeriesTypeGetForexMACD?, expandUnderlying: kotlin.Boolean?, order: OrderGetForexMACD?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (timespan != null) {
                    put("timespan", listOf(timespan.value))
                }
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
                if (shortWindow != null) {
                    put("short_window", listOf(shortWindow.toString()))
                }
                if (longWindow != null) {
                    put("long_window", listOf(longWindow.toString()))
                }
                if (signalWindow != null) {
                    put("signal_window", listOf(signalWindow.toString()))
                }
                if (seriesType != null) {
                    put("series_type", listOf(seriesType.value))
                }
                if (expandUnderlying != null) {
                    put("expand_underlying", listOf(expandUnderlying.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (timestampGte != null) {
                    put("timestamp.gte", listOf(timestampGte.toString()))
                }
                if (timestampGt != null) {
                    put("timestamp.gt", listOf(timestampGt.toString()))
                }
                if (timestampLte != null) {
                    put("timestamp.lte", listOf(timestampLte.toString()))
                }
                if (timestampLt != null) {
                    put("timestamp.lt", listOf(timestampLt.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/indicators/macd/{fxTicker}".replace("{"+"fxTicker"+"}", encodeURIComponent(fxTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter order
     */
     enum class OrderGetForexQuotes(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortGetForexQuotes(val value: kotlin.String) {
         @Json(name = "timestamp") timestamp("timestamp");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v3/quotes/{fxTicker}
     * Quotes (BBO)
     * Get BBO quotes for a ticker symbol in a given time range.
     * @param fxTicker The ticker symbol to get quotes for.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp. (optional)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 1000 and max is 50000. (optional, default to 1000)
     * @param sort Sort field used for ordering. (optional, default to timestamp)
     * @return GetForexQuotes200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getForexQuotes(fxTicker: kotlin.String, timestamp: kotlin.String? = null, timestampGte: kotlin.String? = null, timestampGt: kotlin.String? = null, timestampLte: kotlin.String? = null, timestampLt: kotlin.String? = null, order: OrderGetForexQuotes? = OrderGetForexQuotes.desc, limit: kotlin.Int? = 1000, sort: SortGetForexQuotes? = SortGetForexQuotes.timestamp) : GetForexQuotes200Response {
        val localVarResponse = getForexQuotesWithHttpInfo(fxTicker = fxTicker, timestamp = timestamp, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt, order = order, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetForexQuotes200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v3/quotes/{fxTicker}
     * Quotes (BBO)
     * Get BBO quotes for a ticker symbol in a given time range.
     * @param fxTicker The ticker symbol to get quotes for.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp. (optional)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 1000 and max is 50000. (optional, default to 1000)
     * @param sort Sort field used for ordering. (optional, default to timestamp)
     * @return ApiResponse<GetForexQuotes200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getForexQuotesWithHttpInfo(fxTicker: kotlin.String, timestamp: kotlin.String?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?, order: OrderGetForexQuotes?, limit: kotlin.Int?, sort: SortGetForexQuotes?) : ApiResponse<GetForexQuotes200Response?> {
        val localVariableConfig = getForexQuotesRequestConfig(fxTicker = fxTicker, timestamp = timestamp, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt, order = order, limit = limit, sort = sort)

        return request<Unit, GetForexQuotes200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getForexQuotes
     *
     * @param fxTicker The ticker symbol to get quotes for.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp. (optional)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 1000 and max is 50000. (optional, default to 1000)
     * @param sort Sort field used for ordering. (optional, default to timestamp)
     * @return RequestConfig
     */
    fun getForexQuotesRequestConfig(fxTicker: kotlin.String, timestamp: kotlin.String?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?, order: OrderGetForexQuotes?, limit: kotlin.Int?, sort: SortGetForexQuotes?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (timestampGte != null) {
                    put("timestamp.gte", listOf(timestampGte.toString()))
                }
                if (timestampGt != null) {
                    put("timestamp.gt", listOf(timestampGt.toString()))
                }
                if (timestampLte != null) {
                    put("timestamp.lte", listOf(timestampLte.toString()))
                }
                if (timestampLt != null) {
                    put("timestamp.lt", listOf(timestampLt.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v3/quotes/{fxTicker}".replace("{"+"fxTicker"+"}", encodeURIComponent(fxTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter timespan
     */
     enum class TimespanGetForexRSI(val value: kotlin.String) {
         @Json(name = "minute") minute("minute"),
         @Json(name = "hour") hour("hour"),
         @Json(name = "day") day("day"),
         @Json(name = "week") week("week"),
         @Json(name = "month") month("month"),
         @Json(name = "quarter") quarter("quarter"),
         @Json(name = "year") year("year");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter seriesType
     */
     enum class SeriesTypeGetForexRSI(val value: kotlin.String) {
         @Json(name = "open") `open`("open"),
         @Json(name = "high") high("high"),
         @Json(name = "low") low("low"),
         @Json(name = "close") close("close");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderGetForexRSI(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v1/indicators/rsi/{fxTicker}
     * Relative Strength Index (RSI)
     * Get the relative strength index (RSI) for a ticker symbol over a given time range.
     * @param fxTicker The ticker symbol for which to get relative strength index (RSI) data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the relative strength index (RSI). (optional, default to 14)
     * @param seriesType The price in the aggregate which will be used to calculate the relative strength index. i.e. &#39;close&#39; will result in using close prices to  calculate the relative strength index (RSI). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return GetCryptoRSI200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getForexRSI(fxTicker: kotlin.String, timestamp: kotlin.String? = null, timespan: TimespanGetForexRSI? = TimespanGetForexRSI.day, adjusted: kotlin.Boolean? = true, window: kotlin.Int? = 14, seriesType: SeriesTypeGetForexRSI? = SeriesTypeGetForexRSI.close, expandUnderlying: kotlin.Boolean? = false, order: OrderGetForexRSI? = OrderGetForexRSI.desc, limit: kotlin.Int? = 10, timestampGte: kotlin.String? = null, timestampGt: kotlin.String? = null, timestampLte: kotlin.String? = null, timestampLt: kotlin.String? = null) : GetCryptoRSI200Response {
        val localVarResponse = getForexRSIWithHttpInfo(fxTicker = fxTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, window = window, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoRSI200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/indicators/rsi/{fxTicker}
     * Relative Strength Index (RSI)
     * Get the relative strength index (RSI) for a ticker symbol over a given time range.
     * @param fxTicker The ticker symbol for which to get relative strength index (RSI) data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the relative strength index (RSI). (optional, default to 14)
     * @param seriesType The price in the aggregate which will be used to calculate the relative strength index. i.e. &#39;close&#39; will result in using close prices to  calculate the relative strength index (RSI). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return ApiResponse<GetCryptoRSI200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getForexRSIWithHttpInfo(fxTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetForexRSI?, adjusted: kotlin.Boolean?, window: kotlin.Int?, seriesType: SeriesTypeGetForexRSI?, expandUnderlying: kotlin.Boolean?, order: OrderGetForexRSI?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : ApiResponse<GetCryptoRSI200Response?> {
        val localVariableConfig = getForexRSIRequestConfig(fxTicker = fxTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, window = window, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return request<Unit, GetCryptoRSI200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getForexRSI
     *
     * @param fxTicker The ticker symbol for which to get relative strength index (RSI) data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the relative strength index (RSI). (optional, default to 14)
     * @param seriesType The price in the aggregate which will be used to calculate the relative strength index. i.e. &#39;close&#39; will result in using close prices to  calculate the relative strength index (RSI). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return RequestConfig
     */
    fun getForexRSIRequestConfig(fxTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetForexRSI?, adjusted: kotlin.Boolean?, window: kotlin.Int?, seriesType: SeriesTypeGetForexRSI?, expandUnderlying: kotlin.Boolean?, order: OrderGetForexRSI?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (timespan != null) {
                    put("timespan", listOf(timespan.value))
                }
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
                if (window != null) {
                    put("window", listOf(window.toString()))
                }
                if (seriesType != null) {
                    put("series_type", listOf(seriesType.value))
                }
                if (expandUnderlying != null) {
                    put("expand_underlying", listOf(expandUnderlying.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (timestampGte != null) {
                    put("timestamp.gte", listOf(timestampGte.toString()))
                }
                if (timestampGt != null) {
                    put("timestamp.gt", listOf(timestampGt.toString()))
                }
                if (timestampLte != null) {
                    put("timestamp.lte", listOf(timestampLte.toString()))
                }
                if (timestampLt != null) {
                    put("timestamp.lt", listOf(timestampLt.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/indicators/rsi/{fxTicker}".replace("{"+"fxTicker"+"}", encodeURIComponent(fxTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter timespan
     */
     enum class TimespanGetForexSMA(val value: kotlin.String) {
         @Json(name = "minute") minute("minute"),
         @Json(name = "hour") hour("hour"),
         @Json(name = "day") day("day"),
         @Json(name = "week") week("week"),
         @Json(name = "month") month("month"),
         @Json(name = "quarter") quarter("quarter"),
         @Json(name = "year") year("year");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter seriesType
     */
     enum class SeriesTypeGetForexSMA(val value: kotlin.String) {
         @Json(name = "open") `open`("open"),
         @Json(name = "high") high("high"),
         @Json(name = "low") low("low"),
         @Json(name = "close") close("close");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderGetForexSMA(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v1/indicators/sma/{fxTicker}
     * Simple Moving Average (SMA)
     * Get the simple moving average (SMA) for a ticker symbol over a given time range.
     * @param fxTicker The ticker symbol for which to get simple moving average (SMA) data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param seriesType The price in the aggregate which will be used to calculate the simple moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the simple moving average (SMA). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return GetCryptoSMA200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getForexSMA(fxTicker: kotlin.String, timestamp: kotlin.String? = null, timespan: TimespanGetForexSMA? = TimespanGetForexSMA.day, adjusted: kotlin.Boolean? = true, window: kotlin.Int? = 50, seriesType: SeriesTypeGetForexSMA? = SeriesTypeGetForexSMA.close, expandUnderlying: kotlin.Boolean? = false, order: OrderGetForexSMA? = OrderGetForexSMA.desc, limit: kotlin.Int? = 10, timestampGte: kotlin.String? = null, timestampGt: kotlin.String? = null, timestampLte: kotlin.String? = null, timestampLt: kotlin.String? = null) : GetCryptoSMA200Response {
        val localVarResponse = getForexSMAWithHttpInfo(fxTicker = fxTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, window = window, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoSMA200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/indicators/sma/{fxTicker}
     * Simple Moving Average (SMA)
     * Get the simple moving average (SMA) for a ticker symbol over a given time range.
     * @param fxTicker The ticker symbol for which to get simple moving average (SMA) data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param seriesType The price in the aggregate which will be used to calculate the simple moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the simple moving average (SMA). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return ApiResponse<GetCryptoSMA200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getForexSMAWithHttpInfo(fxTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetForexSMA?, adjusted: kotlin.Boolean?, window: kotlin.Int?, seriesType: SeriesTypeGetForexSMA?, expandUnderlying: kotlin.Boolean?, order: OrderGetForexSMA?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : ApiResponse<GetCryptoSMA200Response?> {
        val localVariableConfig = getForexSMARequestConfig(fxTicker = fxTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, window = window, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return request<Unit, GetCryptoSMA200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getForexSMA
     *
     * @param fxTicker The ticker symbol for which to get simple moving average (SMA) data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param seriesType The price in the aggregate which will be used to calculate the simple moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the simple moving average (SMA). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return RequestConfig
     */
    fun getForexSMARequestConfig(fxTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetForexSMA?, adjusted: kotlin.Boolean?, window: kotlin.Int?, seriesType: SeriesTypeGetForexSMA?, expandUnderlying: kotlin.Boolean?, order: OrderGetForexSMA?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (timespan != null) {
                    put("timespan", listOf(timespan.value))
                }
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
                if (window != null) {
                    put("window", listOf(window.toString()))
                }
                if (seriesType != null) {
                    put("series_type", listOf(seriesType.value))
                }
                if (expandUnderlying != null) {
                    put("expand_underlying", listOf(expandUnderlying.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (timestampGte != null) {
                    put("timestamp.gte", listOf(timestampGte.toString()))
                }
                if (timestampGt != null) {
                    put("timestamp.gt", listOf(timestampGt.toString()))
                }
                if (timestampLte != null) {
                    put("timestamp.lte", listOf(timestampLte.toString()))
                }
                if (timestampLt != null) {
                    put("timestamp.lt", listOf(timestampLt.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/indicators/sma/{fxTicker}".replace("{"+"fxTicker"+"}", encodeURIComponent(fxTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter direction
     */
     enum class DirectionGetForexSnapshotDirection(val value: kotlin.String) {
         @Json(name = "gainers") gainers("gainers"),
         @Json(name = "losers") losers("losers");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v2/snapshot/locale/global/markets/forex/{direction}
     * Gainers/Losers
     * Get the current top 20 gainers or losers of the day in forex markets. &lt;br /&gt; &lt;br /&gt; Top gainers are those tickers whose price has increased by the highest percentage since the previous day&#39;s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day&#39;s close. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
     * @param direction The direction of the snapshot results to return. 
     * @return GetForexSnapshotTickers200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getForexSnapshotDirection(direction: DirectionGetForexSnapshotDirection) : GetForexSnapshotTickers200Response {
        val localVarResponse = getForexSnapshotDirectionWithHttpInfo(direction = direction)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetForexSnapshotTickers200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/snapshot/locale/global/markets/forex/{direction}
     * Gainers/Losers
     * Get the current top 20 gainers or losers of the day in forex markets. &lt;br /&gt; &lt;br /&gt; Top gainers are those tickers whose price has increased by the highest percentage since the previous day&#39;s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day&#39;s close. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
     * @param direction The direction of the snapshot results to return. 
     * @return ApiResponse<GetForexSnapshotTickers200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getForexSnapshotDirectionWithHttpInfo(direction: DirectionGetForexSnapshotDirection) : ApiResponse<GetForexSnapshotTickers200Response?> {
        val localVariableConfig = getForexSnapshotDirectionRequestConfig(direction = direction)

        return request<Unit, GetForexSnapshotTickers200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getForexSnapshotDirection
     *
     * @param direction The direction of the snapshot results to return. 
     * @return RequestConfig
     */
    fun getForexSnapshotDirectionRequestConfig(direction: DirectionGetForexSnapshotDirection) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/snapshot/locale/global/markets/forex/{direction}".replace("{"+"direction"+"}", encodeURIComponent(direction.value.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/snapshot/locale/global/markets/forex/tickers/{ticker}
     * Ticker
     * Get the current minute, day, and previous day’s aggregate, as well as the last trade and quote for a single traded currency symbol. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
     * @param ticker The forex ticker.
     * @return GetForexSnapshotTicker200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getForexSnapshotTicker(ticker: kotlin.String) : GetForexSnapshotTicker200Response {
        val localVarResponse = getForexSnapshotTickerWithHttpInfo(ticker = ticker)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetForexSnapshotTicker200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/snapshot/locale/global/markets/forex/tickers/{ticker}
     * Ticker
     * Get the current minute, day, and previous day’s aggregate, as well as the last trade and quote for a single traded currency symbol. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
     * @param ticker The forex ticker.
     * @return ApiResponse<GetForexSnapshotTicker200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getForexSnapshotTickerWithHttpInfo(ticker: kotlin.String) : ApiResponse<GetForexSnapshotTicker200Response?> {
        val localVariableConfig = getForexSnapshotTickerRequestConfig(ticker = ticker)

        return request<Unit, GetForexSnapshotTicker200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getForexSnapshotTicker
     *
     * @param ticker The forex ticker.
     * @return RequestConfig
     */
    fun getForexSnapshotTickerRequestConfig(ticker: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/snapshot/locale/global/markets/forex/tickers/{ticker}".replace("{"+"ticker"+"}", encodeURIComponent(ticker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/snapshot/locale/global/markets/forex/tickers
     * All Tickers
     * Get the current minute, day, and previous day’s aggregate, as well as the last trade and quote for all traded forex symbols. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
     * @param tickers A case-sensitive comma separated list of tickers to get snapshots for. For example, C:EURUSD, C:GBPCAD, and C:AUDINR. Empty string defaults to querying all tickers. (optional)
     * @return GetForexSnapshotTickers200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getForexSnapshotTickers(tickers: kotlin.collections.List<kotlin.String>? = null) : GetForexSnapshotTickers200Response {
        val localVarResponse = getForexSnapshotTickersWithHttpInfo(tickers = tickers)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetForexSnapshotTickers200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/snapshot/locale/global/markets/forex/tickers
     * All Tickers
     * Get the current minute, day, and previous day’s aggregate, as well as the last trade and quote for all traded forex symbols. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
     * @param tickers A case-sensitive comma separated list of tickers to get snapshots for. For example, C:EURUSD, C:GBPCAD, and C:AUDINR. Empty string defaults to querying all tickers. (optional)
     * @return ApiResponse<GetForexSnapshotTickers200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getForexSnapshotTickersWithHttpInfo(tickers: kotlin.collections.List<kotlin.String>?) : ApiResponse<GetForexSnapshotTickers200Response?> {
        val localVariableConfig = getForexSnapshotTickersRequestConfig(tickers = tickers)

        return request<Unit, GetForexSnapshotTickers200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getForexSnapshotTickers
     *
     * @param tickers A case-sensitive comma separated list of tickers to get snapshots for. For example, C:EURUSD, C:GBPCAD, and C:AUDINR. Empty string defaults to querying all tickers. (optional)
     * @return RequestConfig
     */
    fun getForexSnapshotTickersRequestConfig(tickers: kotlin.collections.List<kotlin.String>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (tickers != null) {
                    put("tickers", toMultiValue(tickers.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/snapshot/locale/global/markets/forex/tickers",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/aggs/grouped/locale/global/market/crypto/{date}
     * Grouped Daily (Bars)
     * Get the daily open, high, low, and close (OHLC) for the entire cryptocurrency markets. 
     * @param date The beginning date for the aggregate window.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return GetGroupedCryptoAggregates200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getGroupedCryptoAggregates(date: kotlin.String, adjusted: kotlin.Boolean? = null) : GetGroupedCryptoAggregates200Response {
        val localVarResponse = getGroupedCryptoAggregatesWithHttpInfo(date = date, adjusted = adjusted)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetGroupedCryptoAggregates200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/aggs/grouped/locale/global/market/crypto/{date}
     * Grouped Daily (Bars)
     * Get the daily open, high, low, and close (OHLC) for the entire cryptocurrency markets. 
     * @param date The beginning date for the aggregate window.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return ApiResponse<GetGroupedCryptoAggregates200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getGroupedCryptoAggregatesWithHttpInfo(date: kotlin.String, adjusted: kotlin.Boolean?) : ApiResponse<GetGroupedCryptoAggregates200Response?> {
        val localVariableConfig = getGroupedCryptoAggregatesRequestConfig(date = date, adjusted = adjusted)

        return request<Unit, GetGroupedCryptoAggregates200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getGroupedCryptoAggregates
     *
     * @param date The beginning date for the aggregate window.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return RequestConfig
     */
    fun getGroupedCryptoAggregatesRequestConfig(date: kotlin.String, adjusted: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/aggs/grouped/locale/global/market/crypto/{date}".replace("{"+"date"+"}", encodeURIComponent(date.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/aggs/grouped/locale/global/market/fx/{date}
     * Grouped Daily (Bars)
     * Get the daily open, high, low, and close (OHLC) for the entire forex markets. 
     * @param date The beginning date for the aggregate window.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return GetGroupedCryptoAggregates200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getGroupedForexAggregates(date: kotlin.String, adjusted: kotlin.Boolean? = null) : GetGroupedCryptoAggregates200Response {
        val localVarResponse = getGroupedForexAggregatesWithHttpInfo(date = date, adjusted = adjusted)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetGroupedCryptoAggregates200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/aggs/grouped/locale/global/market/fx/{date}
     * Grouped Daily (Bars)
     * Get the daily open, high, low, and close (OHLC) for the entire forex markets. 
     * @param date The beginning date for the aggregate window.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return ApiResponse<GetGroupedCryptoAggregates200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getGroupedForexAggregatesWithHttpInfo(date: kotlin.String, adjusted: kotlin.Boolean?) : ApiResponse<GetGroupedCryptoAggregates200Response?> {
        val localVariableConfig = getGroupedForexAggregatesRequestConfig(date = date, adjusted = adjusted)

        return request<Unit, GetGroupedCryptoAggregates200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getGroupedForexAggregates
     *
     * @param date The beginning date for the aggregate window.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return RequestConfig
     */
    fun getGroupedForexAggregatesRequestConfig(date: kotlin.String, adjusted: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/aggs/grouped/locale/global/market/fx/{date}".replace("{"+"date"+"}", encodeURIComponent(date.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/aggs/grouped/locale/us/market/stocks/{date}
     * Grouped Daily (Bars)
     * Get the daily open, high, low, and close (OHLC) for the entire stocks/equities markets. 
     * @param date The beginning date for the aggregate window.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @param includeOtc Include OTC securities in the response. Default is false (don&#39;t include OTC securities).  (optional)
     * @return GetGroupedStocksAggregates200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getGroupedStocksAggregates(date: kotlin.String, adjusted: kotlin.Boolean? = null, includeOtc: kotlin.Boolean? = null) : GetGroupedStocksAggregates200Response {
        val localVarResponse = getGroupedStocksAggregatesWithHttpInfo(date = date, adjusted = adjusted, includeOtc = includeOtc)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetGroupedStocksAggregates200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/aggs/grouped/locale/us/market/stocks/{date}
     * Grouped Daily (Bars)
     * Get the daily open, high, low, and close (OHLC) for the entire stocks/equities markets. 
     * @param date The beginning date for the aggregate window.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @param includeOtc Include OTC securities in the response. Default is false (don&#39;t include OTC securities).  (optional)
     * @return ApiResponse<GetGroupedStocksAggregates200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getGroupedStocksAggregatesWithHttpInfo(date: kotlin.String, adjusted: kotlin.Boolean?, includeOtc: kotlin.Boolean?) : ApiResponse<GetGroupedStocksAggregates200Response?> {
        val localVariableConfig = getGroupedStocksAggregatesRequestConfig(date = date, adjusted = adjusted, includeOtc = includeOtc)

        return request<Unit, GetGroupedStocksAggregates200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getGroupedStocksAggregates
     *
     * @param date The beginning date for the aggregate window.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @param includeOtc Include OTC securities in the response. Default is false (don&#39;t include OTC securities).  (optional)
     * @return RequestConfig
     */
    fun getGroupedStocksAggregatesRequestConfig(date: kotlin.String, adjusted: kotlin.Boolean?, includeOtc: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
                if (includeOtc != null) {
                    put("include_otc", listOf(includeOtc.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/aggs/grouped/locale/us/market/stocks/{date}".replace("{"+"date"+"}", encodeURIComponent(date.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter timespan
     */
     enum class TimespanGetIndicesAggregates(val value: kotlin.String) {
         @Json(name = "second") second("second"),
         @Json(name = "minute") minute("minute"),
         @Json(name = "hour") hour("hour"),
         @Json(name = "day") day("day"),
         @Json(name = "week") week("week"),
         @Json(name = "month") month("month"),
         @Json(name = "quarter") quarter("quarter"),
         @Json(name = "year") year("year");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortGetIndicesAggregates(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v2/aggs/ticker/{indicesTicker}/range/{multiplier}/{timespan}/{from}/{to}
     * Aggregates (Bars)
     * Get aggregate bars for an index over a given date range in custom time window sizes. &lt;br /&gt; &lt;br /&gt; For example, if timespan &#x3D; ‘minute’ and multiplier &#x3D; ‘5’ then 5-minute bars will be returned. 
     * @param indicesTicker The ticker symbol of Index.
     * @param multiplier The size of the timespan multiplier.
     * @param timespan The size of the time window.
     * @param from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top).  (optional)
     * @param limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;.  (optional)
     * @return GetPreviousIndicesAggregates200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getIndicesAggregates(indicesTicker: kotlin.String, multiplier: kotlin.Int, timespan: TimespanGetIndicesAggregates, from: kotlin.String, to: kotlin.String, sort: SortGetIndicesAggregates? = null, limit: kotlin.Int? = null) : GetPreviousIndicesAggregates200Response {
        val localVarResponse = getIndicesAggregatesWithHttpInfo(indicesTicker = indicesTicker, multiplier = multiplier, timespan = timespan, from = from, to = to, sort = sort, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetPreviousIndicesAggregates200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/aggs/ticker/{indicesTicker}/range/{multiplier}/{timespan}/{from}/{to}
     * Aggregates (Bars)
     * Get aggregate bars for an index over a given date range in custom time window sizes. &lt;br /&gt; &lt;br /&gt; For example, if timespan &#x3D; ‘minute’ and multiplier &#x3D; ‘5’ then 5-minute bars will be returned. 
     * @param indicesTicker The ticker symbol of Index.
     * @param multiplier The size of the timespan multiplier.
     * @param timespan The size of the time window.
     * @param from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top).  (optional)
     * @param limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;.  (optional)
     * @return ApiResponse<GetPreviousIndicesAggregates200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getIndicesAggregatesWithHttpInfo(indicesTicker: kotlin.String, multiplier: kotlin.Int, timespan: TimespanGetIndicesAggregates, from: kotlin.String, to: kotlin.String, sort: SortGetIndicesAggregates?, limit: kotlin.Int?) : ApiResponse<GetPreviousIndicesAggregates200Response?> {
        val localVariableConfig = getIndicesAggregatesRequestConfig(indicesTicker = indicesTicker, multiplier = multiplier, timespan = timespan, from = from, to = to, sort = sort, limit = limit)

        return request<Unit, GetPreviousIndicesAggregates200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getIndicesAggregates
     *
     * @param indicesTicker The ticker symbol of Index.
     * @param multiplier The size of the timespan multiplier.
     * @param timespan The size of the time window.
     * @param from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top).  (optional)
     * @param limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;.  (optional)
     * @return RequestConfig
     */
    fun getIndicesAggregatesRequestConfig(indicesTicker: kotlin.String, multiplier: kotlin.Int, timespan: TimespanGetIndicesAggregates, from: kotlin.String, to: kotlin.String, sort: SortGetIndicesAggregates?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/aggs/ticker/{indicesTicker}/range/{multiplier}/{timespan}/{from}/{to}".replace("{"+"indicesTicker"+"}", encodeURIComponent(indicesTicker.toString())).replace("{"+"multiplier"+"}", encodeURIComponent(multiplier.toString())).replace("{"+"timespan"+"}", encodeURIComponent(timespan.value.toString())).replace("{"+"from"+"}", encodeURIComponent(from.toString())).replace("{"+"to"+"}", encodeURIComponent(to.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter timespan
     */
     enum class TimespanGetIndicesEMA(val value: kotlin.String) {
         @Json(name = "minute") minute("minute"),
         @Json(name = "hour") hour("hour"),
         @Json(name = "day") day("day"),
         @Json(name = "week") week("week"),
         @Json(name = "month") month("month"),
         @Json(name = "quarter") quarter("quarter"),
         @Json(name = "year") year("year");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter seriesType
     */
     enum class SeriesTypeGetIndicesEMA(val value: kotlin.String) {
         @Json(name = "open") `open`("open"),
         @Json(name = "high") high("high"),
         @Json(name = "low") low("low"),
         @Json(name = "close") close("close");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderGetIndicesEMA(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v1/indicators/ema/{indicesTicker}
     * Exponential Moving Average (EMA)
     * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
     * @param indicesTicker The ticker symbol for which to get exponential moving average (EMA) data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param seriesType The value in the aggregate which will be used to calculate the exponential moving average. i.e. &#39;close&#39; will result in using close values to  calculate the exponential moving average (EMA). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return GetCryptoEMA200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getIndicesEMA(indicesTicker: kotlin.String, timestamp: kotlin.String? = null, timespan: TimespanGetIndicesEMA? = TimespanGetIndicesEMA.day, adjusted: kotlin.Boolean? = true, window: kotlin.Int? = 50, seriesType: SeriesTypeGetIndicesEMA? = SeriesTypeGetIndicesEMA.close, expandUnderlying: kotlin.Boolean? = false, order: OrderGetIndicesEMA? = OrderGetIndicesEMA.desc, limit: kotlin.Int? = 10, timestampGte: kotlin.String? = null, timestampGt: kotlin.String? = null, timestampLte: kotlin.String? = null, timestampLt: kotlin.String? = null) : GetCryptoEMA200Response {
        val localVarResponse = getIndicesEMAWithHttpInfo(indicesTicker = indicesTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, window = window, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoEMA200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/indicators/ema/{indicesTicker}
     * Exponential Moving Average (EMA)
     * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
     * @param indicesTicker The ticker symbol for which to get exponential moving average (EMA) data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param seriesType The value in the aggregate which will be used to calculate the exponential moving average. i.e. &#39;close&#39; will result in using close values to  calculate the exponential moving average (EMA). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return ApiResponse<GetCryptoEMA200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getIndicesEMAWithHttpInfo(indicesTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetIndicesEMA?, adjusted: kotlin.Boolean?, window: kotlin.Int?, seriesType: SeriesTypeGetIndicesEMA?, expandUnderlying: kotlin.Boolean?, order: OrderGetIndicesEMA?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : ApiResponse<GetCryptoEMA200Response?> {
        val localVariableConfig = getIndicesEMARequestConfig(indicesTicker = indicesTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, window = window, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return request<Unit, GetCryptoEMA200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getIndicesEMA
     *
     * @param indicesTicker The ticker symbol for which to get exponential moving average (EMA) data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param seriesType The value in the aggregate which will be used to calculate the exponential moving average. i.e. &#39;close&#39; will result in using close values to  calculate the exponential moving average (EMA). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return RequestConfig
     */
    fun getIndicesEMARequestConfig(indicesTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetIndicesEMA?, adjusted: kotlin.Boolean?, window: kotlin.Int?, seriesType: SeriesTypeGetIndicesEMA?, expandUnderlying: kotlin.Boolean?, order: OrderGetIndicesEMA?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (timespan != null) {
                    put("timespan", listOf(timespan.value))
                }
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
                if (window != null) {
                    put("window", listOf(window.toString()))
                }
                if (seriesType != null) {
                    put("series_type", listOf(seriesType.value))
                }
                if (expandUnderlying != null) {
                    put("expand_underlying", listOf(expandUnderlying.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (timestampGte != null) {
                    put("timestamp.gte", listOf(timestampGte.toString()))
                }
                if (timestampGt != null) {
                    put("timestamp.gt", listOf(timestampGt.toString()))
                }
                if (timestampLte != null) {
                    put("timestamp.lte", listOf(timestampLte.toString()))
                }
                if (timestampLt != null) {
                    put("timestamp.lt", listOf(timestampLt.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/indicators/ema/{indicesTicker}".replace("{"+"indicesTicker"+"}", encodeURIComponent(indicesTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter timespan
     */
     enum class TimespanGetIndicesMACD(val value: kotlin.String) {
         @Json(name = "minute") minute("minute"),
         @Json(name = "hour") hour("hour"),
         @Json(name = "day") day("day"),
         @Json(name = "week") week("week"),
         @Json(name = "month") month("month"),
         @Json(name = "quarter") quarter("quarter"),
         @Json(name = "year") year("year");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter seriesType
     */
     enum class SeriesTypeGetIndicesMACD(val value: kotlin.String) {
         @Json(name = "open") `open`("open"),
         @Json(name = "high") high("high"),
         @Json(name = "low") low("low"),
         @Json(name = "close") close("close");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderGetIndicesMACD(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v1/indicators/macd/{indicesTicker}
     * Moving Average Convergence/Divergence (MACD)
     * Get moving average convergence/divergence (MACD) for a ticker symbol over a given time range.
     * @param indicesTicker The ticker symbol for which to get MACD data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param shortWindow The short window size used to calculate MACD data. (optional, default to 12)
     * @param longWindow The long window size used to calculate MACD data. (optional, default to 26)
     * @param signalWindow The window size used to calculate the MACD signal line. (optional, default to 9)
     * @param seriesType The value in the aggregate which will be used to calculate the MACD. i.e. &#39;close&#39; will result in using close values to  calculate the MACD. (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return GetCryptoMACD200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getIndicesMACD(indicesTicker: kotlin.String, timestamp: kotlin.String? = null, timespan: TimespanGetIndicesMACD? = TimespanGetIndicesMACD.day, adjusted: kotlin.Boolean? = true, shortWindow: kotlin.Int? = 12, longWindow: kotlin.Int? = 26, signalWindow: kotlin.Int? = 9, seriesType: SeriesTypeGetIndicesMACD? = SeriesTypeGetIndicesMACD.close, expandUnderlying: kotlin.Boolean? = false, order: OrderGetIndicesMACD? = OrderGetIndicesMACD.desc, limit: kotlin.Int? = 10, timestampGte: kotlin.String? = null, timestampGt: kotlin.String? = null, timestampLte: kotlin.String? = null, timestampLt: kotlin.String? = null) : GetCryptoMACD200Response {
        val localVarResponse = getIndicesMACDWithHttpInfo(indicesTicker = indicesTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, shortWindow = shortWindow, longWindow = longWindow, signalWindow = signalWindow, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoMACD200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/indicators/macd/{indicesTicker}
     * Moving Average Convergence/Divergence (MACD)
     * Get moving average convergence/divergence (MACD) for a ticker symbol over a given time range.
     * @param indicesTicker The ticker symbol for which to get MACD data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param shortWindow The short window size used to calculate MACD data. (optional, default to 12)
     * @param longWindow The long window size used to calculate MACD data. (optional, default to 26)
     * @param signalWindow The window size used to calculate the MACD signal line. (optional, default to 9)
     * @param seriesType The value in the aggregate which will be used to calculate the MACD. i.e. &#39;close&#39; will result in using close values to  calculate the MACD. (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return ApiResponse<GetCryptoMACD200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getIndicesMACDWithHttpInfo(indicesTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetIndicesMACD?, adjusted: kotlin.Boolean?, shortWindow: kotlin.Int?, longWindow: kotlin.Int?, signalWindow: kotlin.Int?, seriesType: SeriesTypeGetIndicesMACD?, expandUnderlying: kotlin.Boolean?, order: OrderGetIndicesMACD?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : ApiResponse<GetCryptoMACD200Response?> {
        val localVariableConfig = getIndicesMACDRequestConfig(indicesTicker = indicesTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, shortWindow = shortWindow, longWindow = longWindow, signalWindow = signalWindow, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return request<Unit, GetCryptoMACD200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getIndicesMACD
     *
     * @param indicesTicker The ticker symbol for which to get MACD data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param shortWindow The short window size used to calculate MACD data. (optional, default to 12)
     * @param longWindow The long window size used to calculate MACD data. (optional, default to 26)
     * @param signalWindow The window size used to calculate the MACD signal line. (optional, default to 9)
     * @param seriesType The value in the aggregate which will be used to calculate the MACD. i.e. &#39;close&#39; will result in using close values to  calculate the MACD. (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return RequestConfig
     */
    fun getIndicesMACDRequestConfig(indicesTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetIndicesMACD?, adjusted: kotlin.Boolean?, shortWindow: kotlin.Int?, longWindow: kotlin.Int?, signalWindow: kotlin.Int?, seriesType: SeriesTypeGetIndicesMACD?, expandUnderlying: kotlin.Boolean?, order: OrderGetIndicesMACD?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (timespan != null) {
                    put("timespan", listOf(timespan.value))
                }
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
                if (shortWindow != null) {
                    put("short_window", listOf(shortWindow.toString()))
                }
                if (longWindow != null) {
                    put("long_window", listOf(longWindow.toString()))
                }
                if (signalWindow != null) {
                    put("signal_window", listOf(signalWindow.toString()))
                }
                if (seriesType != null) {
                    put("series_type", listOf(seriesType.value))
                }
                if (expandUnderlying != null) {
                    put("expand_underlying", listOf(expandUnderlying.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (timestampGte != null) {
                    put("timestamp.gte", listOf(timestampGte.toString()))
                }
                if (timestampGt != null) {
                    put("timestamp.gt", listOf(timestampGt.toString()))
                }
                if (timestampLte != null) {
                    put("timestamp.lte", listOf(timestampLte.toString()))
                }
                if (timestampLt != null) {
                    put("timestamp.lt", listOf(timestampLt.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/indicators/macd/{indicesTicker}".replace("{"+"indicesTicker"+"}", encodeURIComponent(indicesTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/open-close/{indicesTicker}/{date}
     * Daily Open/Close
     * Get the open, close and afterhours values of a index symbol on a certain date. 
     * @param indicesTicker The ticker symbol of Index.
     * @param date The date of the requested open/close in the format YYYY-MM-DD.
     * @return GetIndicesOpenClose200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getIndicesOpenClose(indicesTicker: kotlin.String, date: kotlin.String) : GetIndicesOpenClose200Response {
        val localVarResponse = getIndicesOpenCloseWithHttpInfo(indicesTicker = indicesTicker, date = date)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetIndicesOpenClose200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/open-close/{indicesTicker}/{date}
     * Daily Open/Close
     * Get the open, close and afterhours values of a index symbol on a certain date. 
     * @param indicesTicker The ticker symbol of Index.
     * @param date The date of the requested open/close in the format YYYY-MM-DD.
     * @return ApiResponse<GetIndicesOpenClose200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getIndicesOpenCloseWithHttpInfo(indicesTicker: kotlin.String, date: kotlin.String) : ApiResponse<GetIndicesOpenClose200Response?> {
        val localVariableConfig = getIndicesOpenCloseRequestConfig(indicesTicker = indicesTicker, date = date)

        return request<Unit, GetIndicesOpenClose200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getIndicesOpenClose
     *
     * @param indicesTicker The ticker symbol of Index.
     * @param date The date of the requested open/close in the format YYYY-MM-DD.
     * @return RequestConfig
     */
    fun getIndicesOpenCloseRequestConfig(indicesTicker: kotlin.String, date: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/open-close/{indicesTicker}/{date}".replace("{"+"indicesTicker"+"}", encodeURIComponent(indicesTicker.toString())).replace("{"+"date"+"}", encodeURIComponent(date.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter timespan
     */
     enum class TimespanGetIndicesRSI(val value: kotlin.String) {
         @Json(name = "minute") minute("minute"),
         @Json(name = "hour") hour("hour"),
         @Json(name = "day") day("day"),
         @Json(name = "week") week("week"),
         @Json(name = "month") month("month"),
         @Json(name = "quarter") quarter("quarter"),
         @Json(name = "year") year("year");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter seriesType
     */
     enum class SeriesTypeGetIndicesRSI(val value: kotlin.String) {
         @Json(name = "open") `open`("open"),
         @Json(name = "high") high("high"),
         @Json(name = "low") low("low"),
         @Json(name = "close") close("close");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderGetIndicesRSI(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v1/indicators/rsi/{indicesTicker}
     * Relative Strength Index (RSI)
     * Get the relative strength index (RSI) for a ticker symbol over a given time range.
     * @param indicesTicker The ticker symbol for which to get relative strength index (RSI) data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the relative strength index (RSI). (optional, default to 14)
     * @param seriesType The value in the aggregate which will be used to calculate the relative strength index. i.e. &#39;close&#39; will result in using close values to  calculate the relative strength index (RSI). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return GetCryptoRSI200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getIndicesRSI(indicesTicker: kotlin.String, timestamp: kotlin.String? = null, timespan: TimespanGetIndicesRSI? = TimespanGetIndicesRSI.day, adjusted: kotlin.Boolean? = true, window: kotlin.Int? = 14, seriesType: SeriesTypeGetIndicesRSI? = SeriesTypeGetIndicesRSI.close, expandUnderlying: kotlin.Boolean? = false, order: OrderGetIndicesRSI? = OrderGetIndicesRSI.desc, limit: kotlin.Int? = 10, timestampGte: kotlin.String? = null, timestampGt: kotlin.String? = null, timestampLte: kotlin.String? = null, timestampLt: kotlin.String? = null) : GetCryptoRSI200Response {
        val localVarResponse = getIndicesRSIWithHttpInfo(indicesTicker = indicesTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, window = window, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoRSI200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/indicators/rsi/{indicesTicker}
     * Relative Strength Index (RSI)
     * Get the relative strength index (RSI) for a ticker symbol over a given time range.
     * @param indicesTicker The ticker symbol for which to get relative strength index (RSI) data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the relative strength index (RSI). (optional, default to 14)
     * @param seriesType The value in the aggregate which will be used to calculate the relative strength index. i.e. &#39;close&#39; will result in using close values to  calculate the relative strength index (RSI). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return ApiResponse<GetCryptoRSI200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getIndicesRSIWithHttpInfo(indicesTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetIndicesRSI?, adjusted: kotlin.Boolean?, window: kotlin.Int?, seriesType: SeriesTypeGetIndicesRSI?, expandUnderlying: kotlin.Boolean?, order: OrderGetIndicesRSI?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : ApiResponse<GetCryptoRSI200Response?> {
        val localVariableConfig = getIndicesRSIRequestConfig(indicesTicker = indicesTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, window = window, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return request<Unit, GetCryptoRSI200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getIndicesRSI
     *
     * @param indicesTicker The ticker symbol for which to get relative strength index (RSI) data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the relative strength index (RSI). (optional, default to 14)
     * @param seriesType The value in the aggregate which will be used to calculate the relative strength index. i.e. &#39;close&#39; will result in using close values to  calculate the relative strength index (RSI). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return RequestConfig
     */
    fun getIndicesRSIRequestConfig(indicesTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetIndicesRSI?, adjusted: kotlin.Boolean?, window: kotlin.Int?, seriesType: SeriesTypeGetIndicesRSI?, expandUnderlying: kotlin.Boolean?, order: OrderGetIndicesRSI?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (timespan != null) {
                    put("timespan", listOf(timespan.value))
                }
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
                if (window != null) {
                    put("window", listOf(window.toString()))
                }
                if (seriesType != null) {
                    put("series_type", listOf(seriesType.value))
                }
                if (expandUnderlying != null) {
                    put("expand_underlying", listOf(expandUnderlying.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (timestampGte != null) {
                    put("timestamp.gte", listOf(timestampGte.toString()))
                }
                if (timestampGt != null) {
                    put("timestamp.gt", listOf(timestampGt.toString()))
                }
                if (timestampLte != null) {
                    put("timestamp.lte", listOf(timestampLte.toString()))
                }
                if (timestampLt != null) {
                    put("timestamp.lt", listOf(timestampLt.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/indicators/rsi/{indicesTicker}".replace("{"+"indicesTicker"+"}", encodeURIComponent(indicesTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter timespan
     */
     enum class TimespanGetIndicesSMA(val value: kotlin.String) {
         @Json(name = "minute") minute("minute"),
         @Json(name = "hour") hour("hour"),
         @Json(name = "day") day("day"),
         @Json(name = "week") week("week"),
         @Json(name = "month") month("month"),
         @Json(name = "quarter") quarter("quarter"),
         @Json(name = "year") year("year");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter seriesType
     */
     enum class SeriesTypeGetIndicesSMA(val value: kotlin.String) {
         @Json(name = "open") `open`("open"),
         @Json(name = "high") high("high"),
         @Json(name = "low") low("low"),
         @Json(name = "close") close("close");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderGetIndicesSMA(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v1/indicators/sma/{indicesTicker}
     * Simple Moving Average (SMA)
     * Get the simple moving average (SMA) for a ticker symbol over a given time range.
     * @param indicesTicker The ticker symbol for which to get simple moving average (SMA) data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param seriesType The value in the aggregate which will be used to calculate the simple moving average. i.e. &#39;close&#39; will result in using close values to  calculate the simple moving average (SMA). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return GetCryptoSMA200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getIndicesSMA(indicesTicker: kotlin.String, timestamp: kotlin.String? = null, timespan: TimespanGetIndicesSMA? = TimespanGetIndicesSMA.day, adjusted: kotlin.Boolean? = true, window: kotlin.Int? = 50, seriesType: SeriesTypeGetIndicesSMA? = SeriesTypeGetIndicesSMA.close, expandUnderlying: kotlin.Boolean? = false, order: OrderGetIndicesSMA? = OrderGetIndicesSMA.desc, limit: kotlin.Int? = 10, timestampGte: kotlin.String? = null, timestampGt: kotlin.String? = null, timestampLte: kotlin.String? = null, timestampLt: kotlin.String? = null) : GetCryptoSMA200Response {
        val localVarResponse = getIndicesSMAWithHttpInfo(indicesTicker = indicesTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, window = window, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoSMA200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/indicators/sma/{indicesTicker}
     * Simple Moving Average (SMA)
     * Get the simple moving average (SMA) for a ticker symbol over a given time range.
     * @param indicesTicker The ticker symbol for which to get simple moving average (SMA) data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param seriesType The value in the aggregate which will be used to calculate the simple moving average. i.e. &#39;close&#39; will result in using close values to  calculate the simple moving average (SMA). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return ApiResponse<GetCryptoSMA200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getIndicesSMAWithHttpInfo(indicesTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetIndicesSMA?, adjusted: kotlin.Boolean?, window: kotlin.Int?, seriesType: SeriesTypeGetIndicesSMA?, expandUnderlying: kotlin.Boolean?, order: OrderGetIndicesSMA?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : ApiResponse<GetCryptoSMA200Response?> {
        val localVariableConfig = getIndicesSMARequestConfig(indicesTicker = indicesTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, window = window, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return request<Unit, GetCryptoSMA200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getIndicesSMA
     *
     * @param indicesTicker The ticker symbol for which to get simple moving average (SMA) data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param seriesType The value in the aggregate which will be used to calculate the simple moving average. i.e. &#39;close&#39; will result in using close values to  calculate the simple moving average (SMA). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return RequestConfig
     */
    fun getIndicesSMARequestConfig(indicesTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetIndicesSMA?, adjusted: kotlin.Boolean?, window: kotlin.Int?, seriesType: SeriesTypeGetIndicesSMA?, expandUnderlying: kotlin.Boolean?, order: OrderGetIndicesSMA?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (timespan != null) {
                    put("timespan", listOf(timespan.value))
                }
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
                if (window != null) {
                    put("window", listOf(window.toString()))
                }
                if (seriesType != null) {
                    put("series_type", listOf(seriesType.value))
                }
                if (expandUnderlying != null) {
                    put("expand_underlying", listOf(expandUnderlying.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (timestampGte != null) {
                    put("timestamp.gte", listOf(timestampGte.toString()))
                }
                if (timestampGt != null) {
                    put("timestamp.gt", listOf(timestampGt.toString()))
                }
                if (timestampLte != null) {
                    put("timestamp.lte", listOf(timestampLte.toString()))
                }
                if (timestampLt != null) {
                    put("timestamp.lt", listOf(timestampLt.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/indicators/sma/{indicesTicker}".replace("{"+"indicesTicker"+"}", encodeURIComponent(indicesTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter order
     */
     enum class OrderGetIndicesSnapshot(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortGetIndicesSnapshot(val value: kotlin.String) {
         @Json(name = "ticker") ticker("ticker");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v3/snapshot/indices
     * Indices Snapshot
     * Get a Snapshot of indices data for said tickers
     * @param tickerAnyOf Comma separated list of tickers, up to a maximum of 250. If no tickers are passed then all results will be returned in a paginated manner.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack. (optional)
     * @param ticker Search a range of tickers lexicographically. (optional)
     * @param tickerGte Range by ticker. (optional)
     * @param tickerGt Range by ticker. (optional)
     * @param tickerLte Range by ticker. (optional)
     * @param tickerLt Range by ticker. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 250. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to ticker)
     * @return GetIndicesSnapshot200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getIndicesSnapshot(tickerAnyOf: kotlin.String? = null, ticker: kotlin.String? = null, tickerGte: kotlin.String? = null, tickerGt: kotlin.String? = null, tickerLte: kotlin.String? = null, tickerLt: kotlin.String? = null, order: OrderGetIndicesSnapshot? = null, limit: kotlin.Int? = 10, sort: SortGetIndicesSnapshot? = SortGetIndicesSnapshot.ticker) : GetIndicesSnapshot200Response {
        val localVarResponse = getIndicesSnapshotWithHttpInfo(tickerAnyOf = tickerAnyOf, ticker = ticker, tickerGte = tickerGte, tickerGt = tickerGt, tickerLte = tickerLte, tickerLt = tickerLt, order = order, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetIndicesSnapshot200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v3/snapshot/indices
     * Indices Snapshot
     * Get a Snapshot of indices data for said tickers
     * @param tickerAnyOf Comma separated list of tickers, up to a maximum of 250. If no tickers are passed then all results will be returned in a paginated manner.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack. (optional)
     * @param ticker Search a range of tickers lexicographically. (optional)
     * @param tickerGte Range by ticker. (optional)
     * @param tickerGt Range by ticker. (optional)
     * @param tickerLte Range by ticker. (optional)
     * @param tickerLt Range by ticker. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 250. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to ticker)
     * @return ApiResponse<GetIndicesSnapshot200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getIndicesSnapshotWithHttpInfo(tickerAnyOf: kotlin.String?, ticker: kotlin.String?, tickerGte: kotlin.String?, tickerGt: kotlin.String?, tickerLte: kotlin.String?, tickerLt: kotlin.String?, order: OrderGetIndicesSnapshot?, limit: kotlin.Int?, sort: SortGetIndicesSnapshot?) : ApiResponse<GetIndicesSnapshot200Response?> {
        val localVariableConfig = getIndicesSnapshotRequestConfig(tickerAnyOf = tickerAnyOf, ticker = ticker, tickerGte = tickerGte, tickerGt = tickerGt, tickerLte = tickerLte, tickerLt = tickerLt, order = order, limit = limit, sort = sort)

        return request<Unit, GetIndicesSnapshot200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getIndicesSnapshot
     *
     * @param tickerAnyOf Comma separated list of tickers, up to a maximum of 250. If no tickers are passed then all results will be returned in a paginated manner.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack. (optional)
     * @param ticker Search a range of tickers lexicographically. (optional)
     * @param tickerGte Range by ticker. (optional)
     * @param tickerGt Range by ticker. (optional)
     * @param tickerLte Range by ticker. (optional)
     * @param tickerLt Range by ticker. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 250. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to ticker)
     * @return RequestConfig
     */
    fun getIndicesSnapshotRequestConfig(tickerAnyOf: kotlin.String?, ticker: kotlin.String?, tickerGte: kotlin.String?, tickerGt: kotlin.String?, tickerLte: kotlin.String?, tickerLt: kotlin.String?, order: OrderGetIndicesSnapshot?, limit: kotlin.Int?, sort: SortGetIndicesSnapshot?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (tickerAnyOf != null) {
                    put("ticker.any_of", listOf(tickerAnyOf.toString()))
                }
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
                if (tickerGte != null) {
                    put("ticker.gte", listOf(tickerGte.toString()))
                }
                if (tickerGt != null) {
                    put("ticker.gt", listOf(tickerGt.toString()))
                }
                if (tickerLte != null) {
                    put("ticker.lte", listOf(tickerLte.toString()))
                }
                if (tickerLt != null) {
                    put("ticker.lt", listOf(tickerLt.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v3/snapshot/indices",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/last/crypto/{from}/{to}
     * Last Trade for a Crypto Pair
     * Get the last trade tick for a cryptocurrency pair.
     * @param from The \&quot;from\&quot; symbol of the pair.
     * @param to The \&quot;to\&quot; symbol of the pair.
     * @return GetLastCryptoTrade200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getLastCryptoTrade(from: kotlin.String, to: kotlin.String) : GetLastCryptoTrade200Response {
        val localVarResponse = getLastCryptoTradeWithHttpInfo(from = from, to = to)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetLastCryptoTrade200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/last/crypto/{from}/{to}
     * Last Trade for a Crypto Pair
     * Get the last trade tick for a cryptocurrency pair.
     * @param from The \&quot;from\&quot; symbol of the pair.
     * @param to The \&quot;to\&quot; symbol of the pair.
     * @return ApiResponse<GetLastCryptoTrade200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getLastCryptoTradeWithHttpInfo(from: kotlin.String, to: kotlin.String) : ApiResponse<GetLastCryptoTrade200Response?> {
        val localVariableConfig = getLastCryptoTradeRequestConfig(from = from, to = to)

        return request<Unit, GetLastCryptoTrade200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getLastCryptoTrade
     *
     * @param from The \&quot;from\&quot; symbol of the pair.
     * @param to The \&quot;to\&quot; symbol of the pair.
     * @return RequestConfig
     */
    fun getLastCryptoTradeRequestConfig(from: kotlin.String, to: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/last/crypto/{from}/{to}".replace("{"+"from"+"}", encodeURIComponent(from.toString())).replace("{"+"to"+"}", encodeURIComponent(to.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/last_quote/currencies/{from}/{to}
     * Last Quote for a Currency Pair
     * Get the last quote tick for a forex currency pair.
     * @param from The \&quot;from\&quot; symbol of the pair.
     * @param to The \&quot;to\&quot; symbol of the pair.
     * @return GetLastCurrencyQuote200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getLastCurrencyQuote(from: kotlin.String, to: kotlin.String) : GetLastCurrencyQuote200Response {
        val localVarResponse = getLastCurrencyQuoteWithHttpInfo(from = from, to = to)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetLastCurrencyQuote200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/last_quote/currencies/{from}/{to}
     * Last Quote for a Currency Pair
     * Get the last quote tick for a forex currency pair.
     * @param from The \&quot;from\&quot; symbol of the pair.
     * @param to The \&quot;to\&quot; symbol of the pair.
     * @return ApiResponse<GetLastCurrencyQuote200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getLastCurrencyQuoteWithHttpInfo(from: kotlin.String, to: kotlin.String) : ApiResponse<GetLastCurrencyQuote200Response?> {
        val localVariableConfig = getLastCurrencyQuoteRequestConfig(from = from, to = to)

        return request<Unit, GetLastCurrencyQuote200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getLastCurrencyQuote
     *
     * @param from The \&quot;from\&quot; symbol of the pair.
     * @param to The \&quot;to\&quot; symbol of the pair.
     * @return RequestConfig
     */
    fun getLastCurrencyQuoteRequestConfig(from: kotlin.String, to: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/last_quote/currencies/{from}/{to}".replace("{"+"from"+"}", encodeURIComponent(from.toString())).replace("{"+"to"+"}", encodeURIComponent(to.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/last/trade/{optionsTicker}
     * Last Trade
     * Get the most recent trade for a given options contract.
     * @param optionsTicker The ticker symbol of the options contract.
     * @return GetLastOptionsTrade200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getLastOptionsTrade(optionsTicker: kotlin.String) : GetLastOptionsTrade200Response {
        val localVarResponse = getLastOptionsTradeWithHttpInfo(optionsTicker = optionsTicker)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetLastOptionsTrade200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/last/trade/{optionsTicker}
     * Last Trade
     * Get the most recent trade for a given options contract.
     * @param optionsTicker The ticker symbol of the options contract.
     * @return ApiResponse<GetLastOptionsTrade200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getLastOptionsTradeWithHttpInfo(optionsTicker: kotlin.String) : ApiResponse<GetLastOptionsTrade200Response?> {
        val localVariableConfig = getLastOptionsTradeRequestConfig(optionsTicker = optionsTicker)

        return request<Unit, GetLastOptionsTrade200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getLastOptionsTrade
     *
     * @param optionsTicker The ticker symbol of the options contract.
     * @return RequestConfig
     */
    fun getLastOptionsTradeRequestConfig(optionsTicker: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/last/trade/{optionsTicker}".replace("{"+"optionsTicker"+"}", encodeURIComponent(optionsTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/last/nbbo/{stocksTicker}
     * Last Quote
     * Get the most recent NBBO (Quote) tick for a given stock.
     * @param stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @return GetLastStocksQuote200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getLastStocksQuote(stocksTicker: kotlin.String) : GetLastStocksQuote200Response {
        val localVarResponse = getLastStocksQuoteWithHttpInfo(stocksTicker = stocksTicker)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetLastStocksQuote200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/last/nbbo/{stocksTicker}
     * Last Quote
     * Get the most recent NBBO (Quote) tick for a given stock.
     * @param stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @return ApiResponse<GetLastStocksQuote200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getLastStocksQuoteWithHttpInfo(stocksTicker: kotlin.String) : ApiResponse<GetLastStocksQuote200Response?> {
        val localVariableConfig = getLastStocksQuoteRequestConfig(stocksTicker = stocksTicker)

        return request<Unit, GetLastStocksQuote200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getLastStocksQuote
     *
     * @param stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @return RequestConfig
     */
    fun getLastStocksQuoteRequestConfig(stocksTicker: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/last/nbbo/{stocksTicker}".replace("{"+"stocksTicker"+"}", encodeURIComponent(stocksTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/last/trade/{stocksTicker}
     * Last Trade
     * Get the most recent trade for a given stock.
     * @param stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @return GetLastOptionsTrade200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getLastStocksTrade(stocksTicker: kotlin.String) : GetLastOptionsTrade200Response {
        val localVarResponse = getLastStocksTradeWithHttpInfo(stocksTicker = stocksTicker)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetLastOptionsTrade200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/last/trade/{stocksTicker}
     * Last Trade
     * Get the most recent trade for a given stock.
     * @param stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @return ApiResponse<GetLastOptionsTrade200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getLastStocksTradeWithHttpInfo(stocksTicker: kotlin.String) : ApiResponse<GetLastOptionsTrade200Response?> {
        val localVariableConfig = getLastStocksTradeRequestConfig(stocksTicker = stocksTicker)

        return request<Unit, GetLastOptionsTrade200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getLastStocksTrade
     *
     * @param stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @return RequestConfig
     */
    fun getLastStocksTradeRequestConfig(stocksTicker: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/last/trade/{stocksTicker}".replace("{"+"stocksTicker"+"}", encodeURIComponent(stocksTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/marketstatus/upcoming
     * Market Holidays
     * Get upcoming market holidays and their open/close times.
     * @return kotlin.collections.List<GetMarketHolidays200ResponseInner>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMarketHolidays() : kotlin.collections.List<GetMarketHolidays200ResponseInner> {
        val localVarResponse = getMarketHolidaysWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<GetMarketHolidays200ResponseInner>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/marketstatus/upcoming
     * Market Holidays
     * Get upcoming market holidays and their open/close times.
     * @return ApiResponse<kotlin.collections.List<GetMarketHolidays200ResponseInner>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMarketHolidaysWithHttpInfo() : ApiResponse<kotlin.collections.List<GetMarketHolidays200ResponseInner>?> {
        val localVariableConfig = getMarketHolidaysRequestConfig()

        return request<Unit, kotlin.collections.List<GetMarketHolidays200ResponseInner>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMarketHolidays
     *
     * @return RequestConfig
     */
    fun getMarketHolidaysRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/marketstatus/upcoming",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/marketstatus/now
     * Market Status
     * Get the current trading status of the exchanges and overall financial markets.
     * @return GetMarketStatus200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMarketStatus() : GetMarketStatus200Response {
        val localVarResponse = getMarketStatusWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetMarketStatus200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/marketstatus/now
     * Market Status
     * Get the current trading status of the exchanges and overall financial markets.
     * @return ApiResponse<GetMarketStatus200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMarketStatusWithHttpInfo() : ApiResponse<GetMarketStatus200Response?> {
        val localVariableConfig = getMarketStatusRequestConfig()

        return request<Unit, GetMarketStatus200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMarketStatus
     *
     * @return RequestConfig
     */
    fun getMarketStatusRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/marketstatus/now",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v3/snapshot/options/{underlyingAsset}/{optionContract}
     * Option Contract
     * Get the snapshot of an option contract for a stock equity.
     * @param underlyingAsset The underlying ticker symbol of the option contract.
     * @param optionContract The option contract identifier.
     * @return GetOptionContract200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getOptionContract(underlyingAsset: kotlin.String, optionContract: kotlin.String) : GetOptionContract200Response {
        val localVarResponse = getOptionContractWithHttpInfo(underlyingAsset = underlyingAsset, optionContract = optionContract)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetOptionContract200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v3/snapshot/options/{underlyingAsset}/{optionContract}
     * Option Contract
     * Get the snapshot of an option contract for a stock equity.
     * @param underlyingAsset The underlying ticker symbol of the option contract.
     * @param optionContract The option contract identifier.
     * @return ApiResponse<GetOptionContract200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getOptionContractWithHttpInfo(underlyingAsset: kotlin.String, optionContract: kotlin.String) : ApiResponse<GetOptionContract200Response?> {
        val localVariableConfig = getOptionContractRequestConfig(underlyingAsset = underlyingAsset, optionContract = optionContract)

        return request<Unit, GetOptionContract200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getOptionContract
     *
     * @param underlyingAsset The underlying ticker symbol of the option contract.
     * @param optionContract The option contract identifier.
     * @return RequestConfig
     */
    fun getOptionContractRequestConfig(underlyingAsset: kotlin.String, optionContract: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v3/snapshot/options/{underlyingAsset}/{optionContract}".replace("{"+"underlyingAsset"+"}", encodeURIComponent(underlyingAsset.toString())).replace("{"+"optionContract"+"}", encodeURIComponent(optionContract.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter timespan
     */
     enum class TimespanGetOptionsAggregates(val value: kotlin.String) {
         @Json(name = "second") second("second"),
         @Json(name = "minute") minute("minute"),
         @Json(name = "hour") hour("hour"),
         @Json(name = "day") day("day"),
         @Json(name = "week") week("week"),
         @Json(name = "month") month("month"),
         @Json(name = "quarter") quarter("quarter"),
         @Json(name = "year") year("year");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortGetOptionsAggregates(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v2/aggs/ticker/{optionsTicker}/range/{multiplier}/{timespan}/{from}/{to}
     * Aggregates (Bars)
     * Get aggregate bars for an option contract over a given date range in custom time window sizes. &lt;br /&gt; &lt;br /&gt; For example, if timespan &#x3D; ‘minute’ and multiplier &#x3D; ‘5’ then 5-minute bars will be returned. 
     * @param optionsTicker The ticker symbol of the options contract.
     * @param multiplier The size of the timespan multiplier.
     * @param timespan The size of the time window.
     * @param from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @param sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top).  (optional)
     * @param limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;.  (optional)
     * @return GetCryptoAggregates200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getOptionsAggregates(optionsTicker: kotlin.String, multiplier: kotlin.Int, timespan: TimespanGetOptionsAggregates, from: kotlin.String, to: kotlin.String, adjusted: kotlin.Boolean? = null, sort: SortGetOptionsAggregates? = null, limit: kotlin.Int? = null) : GetCryptoAggregates200Response {
        val localVarResponse = getOptionsAggregatesWithHttpInfo(optionsTicker = optionsTicker, multiplier = multiplier, timespan = timespan, from = from, to = to, adjusted = adjusted, sort = sort, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoAggregates200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/aggs/ticker/{optionsTicker}/range/{multiplier}/{timespan}/{from}/{to}
     * Aggregates (Bars)
     * Get aggregate bars for an option contract over a given date range in custom time window sizes. &lt;br /&gt; &lt;br /&gt; For example, if timespan &#x3D; ‘minute’ and multiplier &#x3D; ‘5’ then 5-minute bars will be returned. 
     * @param optionsTicker The ticker symbol of the options contract.
     * @param multiplier The size of the timespan multiplier.
     * @param timespan The size of the time window.
     * @param from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @param sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top).  (optional)
     * @param limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;.  (optional)
     * @return ApiResponse<GetCryptoAggregates200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getOptionsAggregatesWithHttpInfo(optionsTicker: kotlin.String, multiplier: kotlin.Int, timespan: TimespanGetOptionsAggregates, from: kotlin.String, to: kotlin.String, adjusted: kotlin.Boolean?, sort: SortGetOptionsAggregates?, limit: kotlin.Int?) : ApiResponse<GetCryptoAggregates200Response?> {
        val localVariableConfig = getOptionsAggregatesRequestConfig(optionsTicker = optionsTicker, multiplier = multiplier, timespan = timespan, from = from, to = to, adjusted = adjusted, sort = sort, limit = limit)

        return request<Unit, GetCryptoAggregates200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getOptionsAggregates
     *
     * @param optionsTicker The ticker symbol of the options contract.
     * @param multiplier The size of the timespan multiplier.
     * @param timespan The size of the time window.
     * @param from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @param sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top).  (optional)
     * @param limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;.  (optional)
     * @return RequestConfig
     */
    fun getOptionsAggregatesRequestConfig(optionsTicker: kotlin.String, multiplier: kotlin.Int, timespan: TimespanGetOptionsAggregates, from: kotlin.String, to: kotlin.String, adjusted: kotlin.Boolean?, sort: SortGetOptionsAggregates?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/aggs/ticker/{optionsTicker}/range/{multiplier}/{timespan}/{from}/{to}".replace("{"+"optionsTicker"+"}", encodeURIComponent(optionsTicker.toString())).replace("{"+"multiplier"+"}", encodeURIComponent(multiplier.toString())).replace("{"+"timespan"+"}", encodeURIComponent(timespan.value.toString())).replace("{"+"from"+"}", encodeURIComponent(from.toString())).replace("{"+"to"+"}", encodeURIComponent(to.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter contractType
     */
     enum class ContractTypeGetOptionsChain(val value: kotlin.String) {
         @Json(name = "call") call("call"),
         @Json(name = "put") put("put");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderGetOptionsChain(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortGetOptionsChain(val value: kotlin.String) {
         @Json(name = "ticker") ticker("ticker"),
         @Json(name = "expiration_date") expirationDate("expiration_date"),
         @Json(name = "strike_price") strikePrice("strike_price");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v3/snapshot/options/{underlyingAsset}
     * Options Chain
     * Get the snapshot of all options contracts for an underlying ticker.
     * @param underlyingAsset The underlying ticker symbol of the option contract.
     * @param strikePrice Query by strike price of a contract. (optional)
     * @param expirationDate Query by contract expiration with date format YYYY-MM-DD. (optional)
     * @param contractType Query by the type of contract. (optional)
     * @param strikePriceGte Range by strike_price. (optional)
     * @param strikePriceGt Range by strike_price. (optional)
     * @param strikePriceLte Range by strike_price. (optional)
     * @param strikePriceLt Range by strike_price. (optional)
     * @param expirationDateGte Range by expiration_date. (optional)
     * @param expirationDateGt Range by expiration_date. (optional)
     * @param expirationDateLte Range by expiration_date. (optional)
     * @param expirationDateLt Range by expiration_date. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 250. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to ticker)
     * @return GetOptionsChain200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getOptionsChain(underlyingAsset: kotlin.String, strikePrice: java.math.BigDecimal? = null, expirationDate: kotlin.String? = null, contractType: ContractTypeGetOptionsChain? = null, strikePriceGte: java.math.BigDecimal? = null, strikePriceGt: java.math.BigDecimal? = null, strikePriceLte: java.math.BigDecimal? = null, strikePriceLt: java.math.BigDecimal? = null, expirationDateGte: kotlin.String? = null, expirationDateGt: kotlin.String? = null, expirationDateLte: kotlin.String? = null, expirationDateLt: kotlin.String? = null, order: OrderGetOptionsChain? = null, limit: kotlin.Int? = 10, sort: SortGetOptionsChain? = SortGetOptionsChain.ticker) : GetOptionsChain200Response {
        val localVarResponse = getOptionsChainWithHttpInfo(underlyingAsset = underlyingAsset, strikePrice = strikePrice, expirationDate = expirationDate, contractType = contractType, strikePriceGte = strikePriceGte, strikePriceGt = strikePriceGt, strikePriceLte = strikePriceLte, strikePriceLt = strikePriceLt, expirationDateGte = expirationDateGte, expirationDateGt = expirationDateGt, expirationDateLte = expirationDateLte, expirationDateLt = expirationDateLt, order = order, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetOptionsChain200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v3/snapshot/options/{underlyingAsset}
     * Options Chain
     * Get the snapshot of all options contracts for an underlying ticker.
     * @param underlyingAsset The underlying ticker symbol of the option contract.
     * @param strikePrice Query by strike price of a contract. (optional)
     * @param expirationDate Query by contract expiration with date format YYYY-MM-DD. (optional)
     * @param contractType Query by the type of contract. (optional)
     * @param strikePriceGte Range by strike_price. (optional)
     * @param strikePriceGt Range by strike_price. (optional)
     * @param strikePriceLte Range by strike_price. (optional)
     * @param strikePriceLt Range by strike_price. (optional)
     * @param expirationDateGte Range by expiration_date. (optional)
     * @param expirationDateGt Range by expiration_date. (optional)
     * @param expirationDateLte Range by expiration_date. (optional)
     * @param expirationDateLt Range by expiration_date. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 250. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to ticker)
     * @return ApiResponse<GetOptionsChain200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getOptionsChainWithHttpInfo(underlyingAsset: kotlin.String, strikePrice: java.math.BigDecimal?, expirationDate: kotlin.String?, contractType: ContractTypeGetOptionsChain?, strikePriceGte: java.math.BigDecimal?, strikePriceGt: java.math.BigDecimal?, strikePriceLte: java.math.BigDecimal?, strikePriceLt: java.math.BigDecimal?, expirationDateGte: kotlin.String?, expirationDateGt: kotlin.String?, expirationDateLte: kotlin.String?, expirationDateLt: kotlin.String?, order: OrderGetOptionsChain?, limit: kotlin.Int?, sort: SortGetOptionsChain?) : ApiResponse<GetOptionsChain200Response?> {
        val localVariableConfig = getOptionsChainRequestConfig(underlyingAsset = underlyingAsset, strikePrice = strikePrice, expirationDate = expirationDate, contractType = contractType, strikePriceGte = strikePriceGte, strikePriceGt = strikePriceGt, strikePriceLte = strikePriceLte, strikePriceLt = strikePriceLt, expirationDateGte = expirationDateGte, expirationDateGt = expirationDateGt, expirationDateLte = expirationDateLte, expirationDateLt = expirationDateLt, order = order, limit = limit, sort = sort)

        return request<Unit, GetOptionsChain200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getOptionsChain
     *
     * @param underlyingAsset The underlying ticker symbol of the option contract.
     * @param strikePrice Query by strike price of a contract. (optional)
     * @param expirationDate Query by contract expiration with date format YYYY-MM-DD. (optional)
     * @param contractType Query by the type of contract. (optional)
     * @param strikePriceGte Range by strike_price. (optional)
     * @param strikePriceGt Range by strike_price. (optional)
     * @param strikePriceLte Range by strike_price. (optional)
     * @param strikePriceLt Range by strike_price. (optional)
     * @param expirationDateGte Range by expiration_date. (optional)
     * @param expirationDateGt Range by expiration_date. (optional)
     * @param expirationDateLte Range by expiration_date. (optional)
     * @param expirationDateLt Range by expiration_date. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 250. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to ticker)
     * @return RequestConfig
     */
    fun getOptionsChainRequestConfig(underlyingAsset: kotlin.String, strikePrice: java.math.BigDecimal?, expirationDate: kotlin.String?, contractType: ContractTypeGetOptionsChain?, strikePriceGte: java.math.BigDecimal?, strikePriceGt: java.math.BigDecimal?, strikePriceLte: java.math.BigDecimal?, strikePriceLt: java.math.BigDecimal?, expirationDateGte: kotlin.String?, expirationDateGt: kotlin.String?, expirationDateLte: kotlin.String?, expirationDateLt: kotlin.String?, order: OrderGetOptionsChain?, limit: kotlin.Int?, sort: SortGetOptionsChain?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (strikePrice != null) {
                    put("strike_price", listOf(strikePrice.toString()))
                }
                if (expirationDate != null) {
                    put("expiration_date", listOf(expirationDate.toString()))
                }
                if (contractType != null) {
                    put("contract_type", listOf(contractType.value))
                }
                if (strikePriceGte != null) {
                    put("strike_price.gte", listOf(strikePriceGte.toString()))
                }
                if (strikePriceGt != null) {
                    put("strike_price.gt", listOf(strikePriceGt.toString()))
                }
                if (strikePriceLte != null) {
                    put("strike_price.lte", listOf(strikePriceLte.toString()))
                }
                if (strikePriceLt != null) {
                    put("strike_price.lt", listOf(strikePriceLt.toString()))
                }
                if (expirationDateGte != null) {
                    put("expiration_date.gte", listOf(expirationDateGte.toString()))
                }
                if (expirationDateGt != null) {
                    put("expiration_date.gt", listOf(expirationDateGt.toString()))
                }
                if (expirationDateLte != null) {
                    put("expiration_date.lte", listOf(expirationDateLte.toString()))
                }
                if (expirationDateLt != null) {
                    put("expiration_date.lt", listOf(expirationDateLt.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v3/snapshot/options/{underlyingAsset}".replace("{"+"underlyingAsset"+"}", encodeURIComponent(underlyingAsset.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v3/reference/options/contracts/{options_ticker}
     * Options Contract
     * Get an options contract
     * @param optionsTicker Query for a contract by options ticker. You can learn more about the structure of options tickers [here](https://polygon.io/blog/how-to-read-a-stock-options-ticker/).
     * @param asOf Specify a point in time for the contract as of this date with format YYYY-MM-DD. Defaults to today&#39;s date. (optional)
     * @return GetOptionsContract200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getOptionsContract(optionsTicker: kotlin.String, asOf: kotlin.String? = null) : GetOptionsContract200Response {
        val localVarResponse = getOptionsContractWithHttpInfo(optionsTicker = optionsTicker, asOf = asOf)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetOptionsContract200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v3/reference/options/contracts/{options_ticker}
     * Options Contract
     * Get an options contract
     * @param optionsTicker Query for a contract by options ticker. You can learn more about the structure of options tickers [here](https://polygon.io/blog/how-to-read-a-stock-options-ticker/).
     * @param asOf Specify a point in time for the contract as of this date with format YYYY-MM-DD. Defaults to today&#39;s date. (optional)
     * @return ApiResponse<GetOptionsContract200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getOptionsContractWithHttpInfo(optionsTicker: kotlin.String, asOf: kotlin.String?) : ApiResponse<GetOptionsContract200Response?> {
        val localVariableConfig = getOptionsContractRequestConfig(optionsTicker = optionsTicker, asOf = asOf)

        return request<Unit, GetOptionsContract200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getOptionsContract
     *
     * @param optionsTicker Query for a contract by options ticker. You can learn more about the structure of options tickers [here](https://polygon.io/blog/how-to-read-a-stock-options-ticker/).
     * @param asOf Specify a point in time for the contract as of this date with format YYYY-MM-DD. Defaults to today&#39;s date. (optional)
     * @return RequestConfig
     */
    fun getOptionsContractRequestConfig(optionsTicker: kotlin.String, asOf: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (asOf != null) {
                    put("as_of", listOf(asOf.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v3/reference/options/contracts/{options_ticker}".replace("{"+"options_ticker"+"}", encodeURIComponent(optionsTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter timespan
     */
     enum class TimespanGetOptionsEMA(val value: kotlin.String) {
         @Json(name = "minute") minute("minute"),
         @Json(name = "hour") hour("hour"),
         @Json(name = "day") day("day"),
         @Json(name = "week") week("week"),
         @Json(name = "month") month("month"),
         @Json(name = "quarter") quarter("quarter"),
         @Json(name = "year") year("year");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter seriesType
     */
     enum class SeriesTypeGetOptionsEMA(val value: kotlin.String) {
         @Json(name = "open") `open`("open"),
         @Json(name = "high") high("high"),
         @Json(name = "low") low("low"),
         @Json(name = "close") close("close");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderGetOptionsEMA(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v1/indicators/ema/{optionsTicker}
     * Exponential Moving Average (EMA)
     * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
     * @param optionsTicker The ticker symbol for which to get exponential moving average (EMA) data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param seriesType The price in the aggregate which will be used to calculate the exponential moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the exponential moving average (EMA). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return GetCryptoEMA200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getOptionsEMA(optionsTicker: kotlin.String, timestamp: kotlin.String? = null, timespan: TimespanGetOptionsEMA? = TimespanGetOptionsEMA.day, adjusted: kotlin.Boolean? = true, window: kotlin.Int? = 50, seriesType: SeriesTypeGetOptionsEMA? = SeriesTypeGetOptionsEMA.close, expandUnderlying: kotlin.Boolean? = false, order: OrderGetOptionsEMA? = OrderGetOptionsEMA.desc, limit: kotlin.Int? = 10, timestampGte: kotlin.String? = null, timestampGt: kotlin.String? = null, timestampLte: kotlin.String? = null, timestampLt: kotlin.String? = null) : GetCryptoEMA200Response {
        val localVarResponse = getOptionsEMAWithHttpInfo(optionsTicker = optionsTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, window = window, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoEMA200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/indicators/ema/{optionsTicker}
     * Exponential Moving Average (EMA)
     * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
     * @param optionsTicker The ticker symbol for which to get exponential moving average (EMA) data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param seriesType The price in the aggregate which will be used to calculate the exponential moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the exponential moving average (EMA). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return ApiResponse<GetCryptoEMA200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getOptionsEMAWithHttpInfo(optionsTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetOptionsEMA?, adjusted: kotlin.Boolean?, window: kotlin.Int?, seriesType: SeriesTypeGetOptionsEMA?, expandUnderlying: kotlin.Boolean?, order: OrderGetOptionsEMA?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : ApiResponse<GetCryptoEMA200Response?> {
        val localVariableConfig = getOptionsEMARequestConfig(optionsTicker = optionsTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, window = window, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return request<Unit, GetCryptoEMA200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getOptionsEMA
     *
     * @param optionsTicker The ticker symbol for which to get exponential moving average (EMA) data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param seriesType The price in the aggregate which will be used to calculate the exponential moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the exponential moving average (EMA). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return RequestConfig
     */
    fun getOptionsEMARequestConfig(optionsTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetOptionsEMA?, adjusted: kotlin.Boolean?, window: kotlin.Int?, seriesType: SeriesTypeGetOptionsEMA?, expandUnderlying: kotlin.Boolean?, order: OrderGetOptionsEMA?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (timespan != null) {
                    put("timespan", listOf(timespan.value))
                }
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
                if (window != null) {
                    put("window", listOf(window.toString()))
                }
                if (seriesType != null) {
                    put("series_type", listOf(seriesType.value))
                }
                if (expandUnderlying != null) {
                    put("expand_underlying", listOf(expandUnderlying.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (timestampGte != null) {
                    put("timestamp.gte", listOf(timestampGte.toString()))
                }
                if (timestampGt != null) {
                    put("timestamp.gt", listOf(timestampGt.toString()))
                }
                if (timestampLte != null) {
                    put("timestamp.lte", listOf(timestampLte.toString()))
                }
                if (timestampLt != null) {
                    put("timestamp.lt", listOf(timestampLt.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/indicators/ema/{optionsTicker}".replace("{"+"optionsTicker"+"}", encodeURIComponent(optionsTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter timespan
     */
     enum class TimespanGetOptionsMACD(val value: kotlin.String) {
         @Json(name = "minute") minute("minute"),
         @Json(name = "hour") hour("hour"),
         @Json(name = "day") day("day"),
         @Json(name = "week") week("week"),
         @Json(name = "month") month("month"),
         @Json(name = "quarter") quarter("quarter"),
         @Json(name = "year") year("year");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter seriesType
     */
     enum class SeriesTypeGetOptionsMACD(val value: kotlin.String) {
         @Json(name = "open") `open`("open"),
         @Json(name = "high") high("high"),
         @Json(name = "low") low("low"),
         @Json(name = "close") close("close");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderGetOptionsMACD(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v1/indicators/macd/{optionsTicker}
     * Moving Average Convergence/Divergence (MACD)
     * Get moving average convergence/divergence (MACD) for a ticker symbol over a given time range.
     * @param optionsTicker The ticker symbol for which to get MACD data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param shortWindow The short window size used to calculate MACD data. (optional, default to 12)
     * @param longWindow The long window size used to calculate MACD data. (optional, default to 26)
     * @param signalWindow The window size used to calculate the MACD signal line. (optional, default to 9)
     * @param seriesType The price in the aggregate which will be used to calculate the MACD. i.e. &#39;close&#39; will result in using close prices to  calculate the MACD. (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return GetCryptoMACD200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getOptionsMACD(optionsTicker: kotlin.String, timestamp: kotlin.String? = null, timespan: TimespanGetOptionsMACD? = TimespanGetOptionsMACD.day, adjusted: kotlin.Boolean? = true, shortWindow: kotlin.Int? = 12, longWindow: kotlin.Int? = 26, signalWindow: kotlin.Int? = 9, seriesType: SeriesTypeGetOptionsMACD? = SeriesTypeGetOptionsMACD.close, expandUnderlying: kotlin.Boolean? = false, order: OrderGetOptionsMACD? = OrderGetOptionsMACD.desc, limit: kotlin.Int? = 10, timestampGte: kotlin.String? = null, timestampGt: kotlin.String? = null, timestampLte: kotlin.String? = null, timestampLt: kotlin.String? = null) : GetCryptoMACD200Response {
        val localVarResponse = getOptionsMACDWithHttpInfo(optionsTicker = optionsTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, shortWindow = shortWindow, longWindow = longWindow, signalWindow = signalWindow, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoMACD200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/indicators/macd/{optionsTicker}
     * Moving Average Convergence/Divergence (MACD)
     * Get moving average convergence/divergence (MACD) for a ticker symbol over a given time range.
     * @param optionsTicker The ticker symbol for which to get MACD data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param shortWindow The short window size used to calculate MACD data. (optional, default to 12)
     * @param longWindow The long window size used to calculate MACD data. (optional, default to 26)
     * @param signalWindow The window size used to calculate the MACD signal line. (optional, default to 9)
     * @param seriesType The price in the aggregate which will be used to calculate the MACD. i.e. &#39;close&#39; will result in using close prices to  calculate the MACD. (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return ApiResponse<GetCryptoMACD200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getOptionsMACDWithHttpInfo(optionsTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetOptionsMACD?, adjusted: kotlin.Boolean?, shortWindow: kotlin.Int?, longWindow: kotlin.Int?, signalWindow: kotlin.Int?, seriesType: SeriesTypeGetOptionsMACD?, expandUnderlying: kotlin.Boolean?, order: OrderGetOptionsMACD?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : ApiResponse<GetCryptoMACD200Response?> {
        val localVariableConfig = getOptionsMACDRequestConfig(optionsTicker = optionsTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, shortWindow = shortWindow, longWindow = longWindow, signalWindow = signalWindow, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return request<Unit, GetCryptoMACD200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getOptionsMACD
     *
     * @param optionsTicker The ticker symbol for which to get MACD data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param shortWindow The short window size used to calculate MACD data. (optional, default to 12)
     * @param longWindow The long window size used to calculate MACD data. (optional, default to 26)
     * @param signalWindow The window size used to calculate the MACD signal line. (optional, default to 9)
     * @param seriesType The price in the aggregate which will be used to calculate the MACD. i.e. &#39;close&#39; will result in using close prices to  calculate the MACD. (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return RequestConfig
     */
    fun getOptionsMACDRequestConfig(optionsTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetOptionsMACD?, adjusted: kotlin.Boolean?, shortWindow: kotlin.Int?, longWindow: kotlin.Int?, signalWindow: kotlin.Int?, seriesType: SeriesTypeGetOptionsMACD?, expandUnderlying: kotlin.Boolean?, order: OrderGetOptionsMACD?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (timespan != null) {
                    put("timespan", listOf(timespan.value))
                }
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
                if (shortWindow != null) {
                    put("short_window", listOf(shortWindow.toString()))
                }
                if (longWindow != null) {
                    put("long_window", listOf(longWindow.toString()))
                }
                if (signalWindow != null) {
                    put("signal_window", listOf(signalWindow.toString()))
                }
                if (seriesType != null) {
                    put("series_type", listOf(seriesType.value))
                }
                if (expandUnderlying != null) {
                    put("expand_underlying", listOf(expandUnderlying.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (timestampGte != null) {
                    put("timestamp.gte", listOf(timestampGte.toString()))
                }
                if (timestampGt != null) {
                    put("timestamp.gt", listOf(timestampGt.toString()))
                }
                if (timestampLte != null) {
                    put("timestamp.lte", listOf(timestampLte.toString()))
                }
                if (timestampLt != null) {
                    put("timestamp.lt", listOf(timestampLt.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/indicators/macd/{optionsTicker}".replace("{"+"optionsTicker"+"}", encodeURIComponent(optionsTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/open-close/{optionsTicker}/{date}
     * Daily Open/Close
     * Get the open, close and afterhours prices of an options contract on a certain date. 
     * @param optionsTicker The ticker symbol of the options contract.
     * @param date The date of the requested open/close in the format YYYY-MM-DD.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return GetOptionsOpenClose200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getOptionsOpenClose(optionsTicker: kotlin.String, date: java.time.LocalDate, adjusted: kotlin.Boolean? = null) : GetOptionsOpenClose200Response {
        val localVarResponse = getOptionsOpenCloseWithHttpInfo(optionsTicker = optionsTicker, date = date, adjusted = adjusted)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetOptionsOpenClose200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/open-close/{optionsTicker}/{date}
     * Daily Open/Close
     * Get the open, close and afterhours prices of an options contract on a certain date. 
     * @param optionsTicker The ticker symbol of the options contract.
     * @param date The date of the requested open/close in the format YYYY-MM-DD.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return ApiResponse<GetOptionsOpenClose200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getOptionsOpenCloseWithHttpInfo(optionsTicker: kotlin.String, date: java.time.LocalDate, adjusted: kotlin.Boolean?) : ApiResponse<GetOptionsOpenClose200Response?> {
        val localVariableConfig = getOptionsOpenCloseRequestConfig(optionsTicker = optionsTicker, date = date, adjusted = adjusted)

        return request<Unit, GetOptionsOpenClose200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getOptionsOpenClose
     *
     * @param optionsTicker The ticker symbol of the options contract.
     * @param date The date of the requested open/close in the format YYYY-MM-DD.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return RequestConfig
     */
    fun getOptionsOpenCloseRequestConfig(optionsTicker: kotlin.String, date: java.time.LocalDate, adjusted: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/open-close/{optionsTicker}/{date}".replace("{"+"optionsTicker"+"}", encodeURIComponent(optionsTicker.toString())).replace("{"+"date"+"}", encodeURIComponent(date.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter order
     */
     enum class OrderGetOptionsQuotes(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortGetOptionsQuotes(val value: kotlin.String) {
         @Json(name = "timestamp") timestamp("timestamp");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v3/quotes/{optionsTicker}
     * Quotes
     * Get quotes for an options ticker symbol in a given time range.
     * @param optionsTicker The ticker symbol to get quotes for.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp. (optional)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 1000 and max is 50000. (optional, default to 1000)
     * @param sort Sort field used for ordering. (optional, default to timestamp)
     * @return GetOptionsQuotes200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getOptionsQuotes(optionsTicker: kotlin.String, timestamp: kotlin.String? = null, timestampGte: kotlin.String? = null, timestampGt: kotlin.String? = null, timestampLte: kotlin.String? = null, timestampLt: kotlin.String? = null, order: OrderGetOptionsQuotes? = OrderGetOptionsQuotes.desc, limit: kotlin.Int? = 1000, sort: SortGetOptionsQuotes? = SortGetOptionsQuotes.timestamp) : GetOptionsQuotes200Response {
        val localVarResponse = getOptionsQuotesWithHttpInfo(optionsTicker = optionsTicker, timestamp = timestamp, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt, order = order, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetOptionsQuotes200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v3/quotes/{optionsTicker}
     * Quotes
     * Get quotes for an options ticker symbol in a given time range.
     * @param optionsTicker The ticker symbol to get quotes for.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp. (optional)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 1000 and max is 50000. (optional, default to 1000)
     * @param sort Sort field used for ordering. (optional, default to timestamp)
     * @return ApiResponse<GetOptionsQuotes200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getOptionsQuotesWithHttpInfo(optionsTicker: kotlin.String, timestamp: kotlin.String?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?, order: OrderGetOptionsQuotes?, limit: kotlin.Int?, sort: SortGetOptionsQuotes?) : ApiResponse<GetOptionsQuotes200Response?> {
        val localVariableConfig = getOptionsQuotesRequestConfig(optionsTicker = optionsTicker, timestamp = timestamp, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt, order = order, limit = limit, sort = sort)

        return request<Unit, GetOptionsQuotes200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getOptionsQuotes
     *
     * @param optionsTicker The ticker symbol to get quotes for.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp. (optional)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 1000 and max is 50000. (optional, default to 1000)
     * @param sort Sort field used for ordering. (optional, default to timestamp)
     * @return RequestConfig
     */
    fun getOptionsQuotesRequestConfig(optionsTicker: kotlin.String, timestamp: kotlin.String?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?, order: OrderGetOptionsQuotes?, limit: kotlin.Int?, sort: SortGetOptionsQuotes?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (timestampGte != null) {
                    put("timestamp.gte", listOf(timestampGte.toString()))
                }
                if (timestampGt != null) {
                    put("timestamp.gt", listOf(timestampGt.toString()))
                }
                if (timestampLte != null) {
                    put("timestamp.lte", listOf(timestampLte.toString()))
                }
                if (timestampLt != null) {
                    put("timestamp.lt", listOf(timestampLt.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v3/quotes/{optionsTicker}".replace("{"+"optionsTicker"+"}", encodeURIComponent(optionsTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter timespan
     */
     enum class TimespanGetOptionsRSI(val value: kotlin.String) {
         @Json(name = "minute") minute("minute"),
         @Json(name = "hour") hour("hour"),
         @Json(name = "day") day("day"),
         @Json(name = "week") week("week"),
         @Json(name = "month") month("month"),
         @Json(name = "quarter") quarter("quarter"),
         @Json(name = "year") year("year");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter seriesType
     */
     enum class SeriesTypeGetOptionsRSI(val value: kotlin.String) {
         @Json(name = "open") `open`("open"),
         @Json(name = "high") high("high"),
         @Json(name = "low") low("low"),
         @Json(name = "close") close("close");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderGetOptionsRSI(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v1/indicators/rsi/{optionsTicker}
     * Relative Strength Index (RSI)
     * Get the relative strength index (RSI) for a ticker symbol over a given time range.
     * @param optionsTicker The ticker symbol for which to get relative strength index (RSI) data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the relative strength index (RSI). (optional, default to 14)
     * @param seriesType The price in the aggregate which will be used to calculate the relative strength index. i.e. &#39;close&#39; will result in using close prices to  calculate the relative strength index (RSI). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return GetCryptoRSI200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getOptionsRSI(optionsTicker: kotlin.String, timestamp: kotlin.String? = null, timespan: TimespanGetOptionsRSI? = TimespanGetOptionsRSI.day, adjusted: kotlin.Boolean? = true, window: kotlin.Int? = 14, seriesType: SeriesTypeGetOptionsRSI? = SeriesTypeGetOptionsRSI.close, expandUnderlying: kotlin.Boolean? = false, order: OrderGetOptionsRSI? = OrderGetOptionsRSI.desc, limit: kotlin.Int? = 10, timestampGte: kotlin.String? = null, timestampGt: kotlin.String? = null, timestampLte: kotlin.String? = null, timestampLt: kotlin.String? = null) : GetCryptoRSI200Response {
        val localVarResponse = getOptionsRSIWithHttpInfo(optionsTicker = optionsTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, window = window, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoRSI200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/indicators/rsi/{optionsTicker}
     * Relative Strength Index (RSI)
     * Get the relative strength index (RSI) for a ticker symbol over a given time range.
     * @param optionsTicker The ticker symbol for which to get relative strength index (RSI) data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the relative strength index (RSI). (optional, default to 14)
     * @param seriesType The price in the aggregate which will be used to calculate the relative strength index. i.e. &#39;close&#39; will result in using close prices to  calculate the relative strength index (RSI). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return ApiResponse<GetCryptoRSI200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getOptionsRSIWithHttpInfo(optionsTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetOptionsRSI?, adjusted: kotlin.Boolean?, window: kotlin.Int?, seriesType: SeriesTypeGetOptionsRSI?, expandUnderlying: kotlin.Boolean?, order: OrderGetOptionsRSI?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : ApiResponse<GetCryptoRSI200Response?> {
        val localVariableConfig = getOptionsRSIRequestConfig(optionsTicker = optionsTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, window = window, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return request<Unit, GetCryptoRSI200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getOptionsRSI
     *
     * @param optionsTicker The ticker symbol for which to get relative strength index (RSI) data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the relative strength index (RSI). (optional, default to 14)
     * @param seriesType The price in the aggregate which will be used to calculate the relative strength index. i.e. &#39;close&#39; will result in using close prices to  calculate the relative strength index (RSI). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return RequestConfig
     */
    fun getOptionsRSIRequestConfig(optionsTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetOptionsRSI?, adjusted: kotlin.Boolean?, window: kotlin.Int?, seriesType: SeriesTypeGetOptionsRSI?, expandUnderlying: kotlin.Boolean?, order: OrderGetOptionsRSI?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (timespan != null) {
                    put("timespan", listOf(timespan.value))
                }
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
                if (window != null) {
                    put("window", listOf(window.toString()))
                }
                if (seriesType != null) {
                    put("series_type", listOf(seriesType.value))
                }
                if (expandUnderlying != null) {
                    put("expand_underlying", listOf(expandUnderlying.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (timestampGte != null) {
                    put("timestamp.gte", listOf(timestampGte.toString()))
                }
                if (timestampGt != null) {
                    put("timestamp.gt", listOf(timestampGt.toString()))
                }
                if (timestampLte != null) {
                    put("timestamp.lte", listOf(timestampLte.toString()))
                }
                if (timestampLt != null) {
                    put("timestamp.lt", listOf(timestampLt.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/indicators/rsi/{optionsTicker}".replace("{"+"optionsTicker"+"}", encodeURIComponent(optionsTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter timespan
     */
     enum class TimespanGetOptionsSMA(val value: kotlin.String) {
         @Json(name = "minute") minute("minute"),
         @Json(name = "hour") hour("hour"),
         @Json(name = "day") day("day"),
         @Json(name = "week") week("week"),
         @Json(name = "month") month("month"),
         @Json(name = "quarter") quarter("quarter"),
         @Json(name = "year") year("year");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter seriesType
     */
     enum class SeriesTypeGetOptionsSMA(val value: kotlin.String) {
         @Json(name = "open") `open`("open"),
         @Json(name = "high") high("high"),
         @Json(name = "low") low("low"),
         @Json(name = "close") close("close");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderGetOptionsSMA(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v1/indicators/sma/{optionsTicker}
     * Simple Moving Average (SMA)
     * Get the simple moving average (SMA) for a ticker symbol over a given time range.
     * @param optionsTicker The ticker symbol for which to get simple moving average (SMA) data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param seriesType The price in the aggregate which will be used to calculate the simple moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the simple moving average (SMA). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return GetCryptoSMA200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getOptionsSMA(optionsTicker: kotlin.String, timestamp: kotlin.String? = null, timespan: TimespanGetOptionsSMA? = TimespanGetOptionsSMA.day, adjusted: kotlin.Boolean? = true, window: kotlin.Int? = 50, seriesType: SeriesTypeGetOptionsSMA? = SeriesTypeGetOptionsSMA.close, expandUnderlying: kotlin.Boolean? = false, order: OrderGetOptionsSMA? = OrderGetOptionsSMA.desc, limit: kotlin.Int? = 10, timestampGte: kotlin.String? = null, timestampGt: kotlin.String? = null, timestampLte: kotlin.String? = null, timestampLt: kotlin.String? = null) : GetCryptoSMA200Response {
        val localVarResponse = getOptionsSMAWithHttpInfo(optionsTicker = optionsTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, window = window, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoSMA200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/indicators/sma/{optionsTicker}
     * Simple Moving Average (SMA)
     * Get the simple moving average (SMA) for a ticker symbol over a given time range.
     * @param optionsTicker The ticker symbol for which to get simple moving average (SMA) data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param seriesType The price in the aggregate which will be used to calculate the simple moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the simple moving average (SMA). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return ApiResponse<GetCryptoSMA200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getOptionsSMAWithHttpInfo(optionsTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetOptionsSMA?, adjusted: kotlin.Boolean?, window: kotlin.Int?, seriesType: SeriesTypeGetOptionsSMA?, expandUnderlying: kotlin.Boolean?, order: OrderGetOptionsSMA?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : ApiResponse<GetCryptoSMA200Response?> {
        val localVariableConfig = getOptionsSMARequestConfig(optionsTicker = optionsTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, window = window, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return request<Unit, GetCryptoSMA200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getOptionsSMA
     *
     * @param optionsTicker The ticker symbol for which to get simple moving average (SMA) data.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param seriesType The price in the aggregate which will be used to calculate the simple moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the simple moving average (SMA). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return RequestConfig
     */
    fun getOptionsSMARequestConfig(optionsTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetOptionsSMA?, adjusted: kotlin.Boolean?, window: kotlin.Int?, seriesType: SeriesTypeGetOptionsSMA?, expandUnderlying: kotlin.Boolean?, order: OrderGetOptionsSMA?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (timespan != null) {
                    put("timespan", listOf(timespan.value))
                }
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
                if (window != null) {
                    put("window", listOf(window.toString()))
                }
                if (seriesType != null) {
                    put("series_type", listOf(seriesType.value))
                }
                if (expandUnderlying != null) {
                    put("expand_underlying", listOf(expandUnderlying.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (timestampGte != null) {
                    put("timestamp.gte", listOf(timestampGte.toString()))
                }
                if (timestampGt != null) {
                    put("timestamp.gt", listOf(timestampGt.toString()))
                }
                if (timestampLte != null) {
                    put("timestamp.lte", listOf(timestampLte.toString()))
                }
                if (timestampLt != null) {
                    put("timestamp.lt", listOf(timestampLt.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/indicators/sma/{optionsTicker}".replace("{"+"optionsTicker"+"}", encodeURIComponent(optionsTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter order
     */
     enum class OrderGetOptionsTrades(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortGetOptionsTrades(val value: kotlin.String) {
         @Json(name = "timestamp") timestamp("timestamp");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v3/trades/{optionsTicker}
     * Trades
     * Get trades for an options ticker symbol in a given time range.
     * @param optionsTicker The options ticker symbol to get trades for.
     * @param timestamp Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp. (optional)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 1000 and max is 50000. (optional, default to 1000)
     * @param sort Sort field used for ordering. (optional, default to timestamp)
     * @return GetOptionsTrades200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getOptionsTrades(optionsTicker: kotlin.String, timestamp: kotlin.String? = null, timestampGte: kotlin.String? = null, timestampGt: kotlin.String? = null, timestampLte: kotlin.String? = null, timestampLt: kotlin.String? = null, order: OrderGetOptionsTrades? = OrderGetOptionsTrades.desc, limit: kotlin.Int? = 1000, sort: SortGetOptionsTrades? = SortGetOptionsTrades.timestamp) : GetOptionsTrades200Response {
        val localVarResponse = getOptionsTradesWithHttpInfo(optionsTicker = optionsTicker, timestamp = timestamp, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt, order = order, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetOptionsTrades200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v3/trades/{optionsTicker}
     * Trades
     * Get trades for an options ticker symbol in a given time range.
     * @param optionsTicker The options ticker symbol to get trades for.
     * @param timestamp Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp. (optional)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 1000 and max is 50000. (optional, default to 1000)
     * @param sort Sort field used for ordering. (optional, default to timestamp)
     * @return ApiResponse<GetOptionsTrades200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getOptionsTradesWithHttpInfo(optionsTicker: kotlin.String, timestamp: kotlin.String?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?, order: OrderGetOptionsTrades?, limit: kotlin.Int?, sort: SortGetOptionsTrades?) : ApiResponse<GetOptionsTrades200Response?> {
        val localVariableConfig = getOptionsTradesRequestConfig(optionsTicker = optionsTicker, timestamp = timestamp, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt, order = order, limit = limit, sort = sort)

        return request<Unit, GetOptionsTrades200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getOptionsTrades
     *
     * @param optionsTicker The options ticker symbol to get trades for.
     * @param timestamp Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp. (optional)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 1000 and max is 50000. (optional, default to 1000)
     * @param sort Sort field used for ordering. (optional, default to timestamp)
     * @return RequestConfig
     */
    fun getOptionsTradesRequestConfig(optionsTicker: kotlin.String, timestamp: kotlin.String?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?, order: OrderGetOptionsTrades?, limit: kotlin.Int?, sort: SortGetOptionsTrades?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (timestampGte != null) {
                    put("timestamp.gte", listOf(timestampGte.toString()))
                }
                if (timestampGt != null) {
                    put("timestamp.gt", listOf(timestampGt.toString()))
                }
                if (timestampLte != null) {
                    put("timestamp.lte", listOf(timestampLte.toString()))
                }
                if (timestampLt != null) {
                    put("timestamp.lt", listOf(timestampLt.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v3/trades/{optionsTicker}".replace("{"+"optionsTicker"+"}", encodeURIComponent(optionsTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/aggs/ticker/{cryptoTicker}/prev
     * Previous Close
     * Get the previous day&#39;s open, high, low, and close (OHLC) for the specified cryptocurrency pair. 
     * @param cryptoTicker The ticker symbol of the currency pair.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return GetPreviousCryptoAggregates200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPreviousCryptoAggregates(cryptoTicker: kotlin.String, adjusted: kotlin.Boolean? = null) : GetPreviousCryptoAggregates200Response {
        val localVarResponse = getPreviousCryptoAggregatesWithHttpInfo(cryptoTicker = cryptoTicker, adjusted = adjusted)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetPreviousCryptoAggregates200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/aggs/ticker/{cryptoTicker}/prev
     * Previous Close
     * Get the previous day&#39;s open, high, low, and close (OHLC) for the specified cryptocurrency pair. 
     * @param cryptoTicker The ticker symbol of the currency pair.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return ApiResponse<GetPreviousCryptoAggregates200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPreviousCryptoAggregatesWithHttpInfo(cryptoTicker: kotlin.String, adjusted: kotlin.Boolean?) : ApiResponse<GetPreviousCryptoAggregates200Response?> {
        val localVariableConfig = getPreviousCryptoAggregatesRequestConfig(cryptoTicker = cryptoTicker, adjusted = adjusted)

        return request<Unit, GetPreviousCryptoAggregates200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPreviousCryptoAggregates
     *
     * @param cryptoTicker The ticker symbol of the currency pair.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return RequestConfig
     */
    fun getPreviousCryptoAggregatesRequestConfig(cryptoTicker: kotlin.String, adjusted: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/aggs/ticker/{cryptoTicker}/prev".replace("{"+"cryptoTicker"+"}", encodeURIComponent(cryptoTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/aggs/ticker/{forexTicker}/prev
     * Previous Close
     * Get the previous day&#39;s open, high, low, and close (OHLC) for the specified forex pair. 
     * @param forexTicker The ticker symbol of the currency pair.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return GetPreviousForexAggregates200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPreviousForexAggregates(forexTicker: kotlin.String, adjusted: kotlin.Boolean? = null) : GetPreviousForexAggregates200Response {
        val localVarResponse = getPreviousForexAggregatesWithHttpInfo(forexTicker = forexTicker, adjusted = adjusted)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetPreviousForexAggregates200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/aggs/ticker/{forexTicker}/prev
     * Previous Close
     * Get the previous day&#39;s open, high, low, and close (OHLC) for the specified forex pair. 
     * @param forexTicker The ticker symbol of the currency pair.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return ApiResponse<GetPreviousForexAggregates200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPreviousForexAggregatesWithHttpInfo(forexTicker: kotlin.String, adjusted: kotlin.Boolean?) : ApiResponse<GetPreviousForexAggregates200Response?> {
        val localVariableConfig = getPreviousForexAggregatesRequestConfig(forexTicker = forexTicker, adjusted = adjusted)

        return request<Unit, GetPreviousForexAggregates200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPreviousForexAggregates
     *
     * @param forexTicker The ticker symbol of the currency pair.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return RequestConfig
     */
    fun getPreviousForexAggregatesRequestConfig(forexTicker: kotlin.String, adjusted: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/aggs/ticker/{forexTicker}/prev".replace("{"+"forexTicker"+"}", encodeURIComponent(forexTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/aggs/ticker/{indicesTicker}/prev
     * Previous Close
     * Get the previous day&#39;s open, high, low, and close (OHLC) for the specified index. 
     * @param indicesTicker The ticker symbol of Index.
     * @return GetPreviousIndicesAggregates200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPreviousIndicesAggregates(indicesTicker: kotlin.String) : GetPreviousIndicesAggregates200Response {
        val localVarResponse = getPreviousIndicesAggregatesWithHttpInfo(indicesTicker = indicesTicker)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetPreviousIndicesAggregates200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/aggs/ticker/{indicesTicker}/prev
     * Previous Close
     * Get the previous day&#39;s open, high, low, and close (OHLC) for the specified index. 
     * @param indicesTicker The ticker symbol of Index.
     * @return ApiResponse<GetPreviousIndicesAggregates200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPreviousIndicesAggregatesWithHttpInfo(indicesTicker: kotlin.String) : ApiResponse<GetPreviousIndicesAggregates200Response?> {
        val localVariableConfig = getPreviousIndicesAggregatesRequestConfig(indicesTicker = indicesTicker)

        return request<Unit, GetPreviousIndicesAggregates200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPreviousIndicesAggregates
     *
     * @param indicesTicker The ticker symbol of Index.
     * @return RequestConfig
     */
    fun getPreviousIndicesAggregatesRequestConfig(indicesTicker: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/aggs/ticker/{indicesTicker}/prev".replace("{"+"indicesTicker"+"}", encodeURIComponent(indicesTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/aggs/ticker/{optionsTicker}/prev
     * Previous Close
     * Get the previous day&#39;s open, high, low, and close (OHLC) for the specified option contract. 
     * @param optionsTicker The ticker symbol of the options contract.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return GetCryptoAggregates200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPreviousOptionsAggregates(optionsTicker: kotlin.String, adjusted: kotlin.Boolean? = null) : GetCryptoAggregates200Response {
        val localVarResponse = getPreviousOptionsAggregatesWithHttpInfo(optionsTicker = optionsTicker, adjusted = adjusted)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoAggregates200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/aggs/ticker/{optionsTicker}/prev
     * Previous Close
     * Get the previous day&#39;s open, high, low, and close (OHLC) for the specified option contract. 
     * @param optionsTicker The ticker symbol of the options contract.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return ApiResponse<GetCryptoAggregates200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPreviousOptionsAggregatesWithHttpInfo(optionsTicker: kotlin.String, adjusted: kotlin.Boolean?) : ApiResponse<GetCryptoAggregates200Response?> {
        val localVariableConfig = getPreviousOptionsAggregatesRequestConfig(optionsTicker = optionsTicker, adjusted = adjusted)

        return request<Unit, GetCryptoAggregates200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPreviousOptionsAggregates
     *
     * @param optionsTicker The ticker symbol of the options contract.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return RequestConfig
     */
    fun getPreviousOptionsAggregatesRequestConfig(optionsTicker: kotlin.String, adjusted: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/aggs/ticker/{optionsTicker}/prev".replace("{"+"optionsTicker"+"}", encodeURIComponent(optionsTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/aggs/ticker/{stocksTicker}/prev
     * Previous Close
     * Get the previous day&#39;s open, high, low, and close (OHLC) for the specified stock ticker. 
     * @param stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return GetCryptoAggregates200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPreviousStocksAggregates(stocksTicker: kotlin.String, adjusted: kotlin.Boolean? = null) : GetCryptoAggregates200Response {
        val localVarResponse = getPreviousStocksAggregatesWithHttpInfo(stocksTicker = stocksTicker, adjusted = adjusted)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoAggregates200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/aggs/ticker/{stocksTicker}/prev
     * Previous Close
     * Get the previous day&#39;s open, high, low, and close (OHLC) for the specified stock ticker. 
     * @param stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return ApiResponse<GetCryptoAggregates200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPreviousStocksAggregatesWithHttpInfo(stocksTicker: kotlin.String, adjusted: kotlin.Boolean?) : ApiResponse<GetCryptoAggregates200Response?> {
        val localVariableConfig = getPreviousStocksAggregatesRequestConfig(stocksTicker = stocksTicker, adjusted = adjusted)

        return request<Unit, GetCryptoAggregates200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPreviousStocksAggregates
     *
     * @param stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return RequestConfig
     */
    fun getPreviousStocksAggregatesRequestConfig(stocksTicker: kotlin.String, adjusted: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/aggs/ticker/{stocksTicker}/prev".replace("{"+"stocksTicker"+"}", encodeURIComponent(stocksTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/related-companies/{ticker}
     * Related Companies
     * Get a list of tickers related to the queried ticker based on News and Returns data.
     * @param ticker The ticker symbol to search.
     * @return GetRelatedCompanies200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRelatedCompanies(ticker: kotlin.String) : GetRelatedCompanies200Response {
        val localVarResponse = getRelatedCompaniesWithHttpInfo(ticker = ticker)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetRelatedCompanies200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/related-companies/{ticker}
     * Related Companies
     * Get a list of tickers related to the queried ticker based on News and Returns data.
     * @param ticker The ticker symbol to search.
     * @return ApiResponse<GetRelatedCompanies200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRelatedCompaniesWithHttpInfo(ticker: kotlin.String) : ApiResponse<GetRelatedCompanies200Response?> {
        val localVariableConfig = getRelatedCompaniesRequestConfig(ticker = ticker)

        return request<Unit, GetRelatedCompanies200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRelatedCompanies
     *
     * @param ticker The ticker symbol to search.
     * @return RequestConfig
     */
    fun getRelatedCompaniesRequestConfig(ticker: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/related-companies/{ticker}".replace("{"+"ticker"+"}", encodeURIComponent(ticker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/summaries
     * Summaries
     * Get everything needed to visualize the tick-by-tick movement of a list of tickers.
     * @param tickerAnyOf Comma separated list of tickers. This API currently supports Stocks/Equities, Crypto, Options, and Forex. See &lt;a rel&#x3D;\&quot;nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://polygon.io/docs/stocks/get_v3_reference_tickers\&quot;&gt;the tickers endpoint&lt;/a&gt; for more details on supported tickers. If no tickers are passed then no results will be returned.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack. (optional)
     * @return GetSnapshotSummary200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSnapshotSummary(tickerAnyOf: kotlin.String? = null) : GetSnapshotSummary200Response {
        val localVarResponse = getSnapshotSummaryWithHttpInfo(tickerAnyOf = tickerAnyOf)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetSnapshotSummary200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/summaries
     * Summaries
     * Get everything needed to visualize the tick-by-tick movement of a list of tickers.
     * @param tickerAnyOf Comma separated list of tickers. This API currently supports Stocks/Equities, Crypto, Options, and Forex. See &lt;a rel&#x3D;\&quot;nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://polygon.io/docs/stocks/get_v3_reference_tickers\&quot;&gt;the tickers endpoint&lt;/a&gt; for more details on supported tickers. If no tickers are passed then no results will be returned.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack. (optional)
     * @return ApiResponse<GetSnapshotSummary200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getSnapshotSummaryWithHttpInfo(tickerAnyOf: kotlin.String?) : ApiResponse<GetSnapshotSummary200Response?> {
        val localVariableConfig = getSnapshotSummaryRequestConfig(tickerAnyOf = tickerAnyOf)

        return request<Unit, GetSnapshotSummary200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getSnapshotSummary
     *
     * @param tickerAnyOf Comma separated list of tickers. This API currently supports Stocks/Equities, Crypto, Options, and Forex. See &lt;a rel&#x3D;\&quot;nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://polygon.io/docs/stocks/get_v3_reference_tickers\&quot;&gt;the tickers endpoint&lt;/a&gt; for more details on supported tickers. If no tickers are passed then no results will be returned.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack. (optional)
     * @return RequestConfig
     */
    fun getSnapshotSummaryRequestConfig(tickerAnyOf: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (tickerAnyOf != null) {
                    put("ticker.any_of", listOf(tickerAnyOf.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/summaries",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter type
     */
     enum class TypeGetSnapshots(val value: kotlin.String) {
         @Json(name = "stocks") stocks("stocks"),
         @Json(name = "options") options("options"),
         @Json(name = "crypto") crypto("crypto"),
         @Json(name = "fx") fx("fx"),
         @Json(name = "indices") indices("indices");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderGetSnapshots(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortGetSnapshots(val value: kotlin.String) {
         @Json(name = "ticker") ticker("ticker");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v3/snapshot
     * Universal Snapshot
     * Get snapshots for assets of all types
     * @param ticker Search a range of tickers lexicographically. (optional)
     * @param type Query by the type of asset. (optional)
     * @param tickerGte Range by ticker. (optional)
     * @param tickerGt Range by ticker. (optional)
     * @param tickerLte Range by ticker. (optional)
     * @param tickerLt Range by ticker. (optional)
     * @param tickerAnyOf Comma separated list of tickers, up to a maximum of 250. If no tickers are passed then all results will be returned in a paginated manner.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack.  (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 250. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to ticker)
     * @return GetSnapshots200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSnapshots(ticker: kotlin.String? = null, type: TypeGetSnapshots? = null, tickerGte: kotlin.String? = null, tickerGt: kotlin.String? = null, tickerLte: kotlin.String? = null, tickerLt: kotlin.String? = null, tickerAnyOf: kotlin.String? = null, order: OrderGetSnapshots? = null, limit: kotlin.Int? = 10, sort: SortGetSnapshots? = SortGetSnapshots.ticker) : GetSnapshots200Response {
        val localVarResponse = getSnapshotsWithHttpInfo(ticker = ticker, type = type, tickerGte = tickerGte, tickerGt = tickerGt, tickerLte = tickerLte, tickerLt = tickerLt, tickerAnyOf = tickerAnyOf, order = order, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetSnapshots200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v3/snapshot
     * Universal Snapshot
     * Get snapshots for assets of all types
     * @param ticker Search a range of tickers lexicographically. (optional)
     * @param type Query by the type of asset. (optional)
     * @param tickerGte Range by ticker. (optional)
     * @param tickerGt Range by ticker. (optional)
     * @param tickerLte Range by ticker. (optional)
     * @param tickerLt Range by ticker. (optional)
     * @param tickerAnyOf Comma separated list of tickers, up to a maximum of 250. If no tickers are passed then all results will be returned in a paginated manner.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack.  (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 250. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to ticker)
     * @return ApiResponse<GetSnapshots200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getSnapshotsWithHttpInfo(ticker: kotlin.String?, type: TypeGetSnapshots?, tickerGte: kotlin.String?, tickerGt: kotlin.String?, tickerLte: kotlin.String?, tickerLt: kotlin.String?, tickerAnyOf: kotlin.String?, order: OrderGetSnapshots?, limit: kotlin.Int?, sort: SortGetSnapshots?) : ApiResponse<GetSnapshots200Response?> {
        val localVariableConfig = getSnapshotsRequestConfig(ticker = ticker, type = type, tickerGte = tickerGte, tickerGt = tickerGt, tickerLte = tickerLte, tickerLt = tickerLt, tickerAnyOf = tickerAnyOf, order = order, limit = limit, sort = sort)

        return request<Unit, GetSnapshots200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getSnapshots
     *
     * @param ticker Search a range of tickers lexicographically. (optional)
     * @param type Query by the type of asset. (optional)
     * @param tickerGte Range by ticker. (optional)
     * @param tickerGt Range by ticker. (optional)
     * @param tickerLte Range by ticker. (optional)
     * @param tickerLt Range by ticker. (optional)
     * @param tickerAnyOf Comma separated list of tickers, up to a maximum of 250. If no tickers are passed then all results will be returned in a paginated manner.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack.  (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 250. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to ticker)
     * @return RequestConfig
     */
    fun getSnapshotsRequestConfig(ticker: kotlin.String?, type: TypeGetSnapshots?, tickerGte: kotlin.String?, tickerGt: kotlin.String?, tickerLte: kotlin.String?, tickerLt: kotlin.String?, tickerAnyOf: kotlin.String?, order: OrderGetSnapshots?, limit: kotlin.Int?, sort: SortGetSnapshots?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
                if (type != null) {
                    put("type", listOf(type.value))
                }
                if (tickerGte != null) {
                    put("ticker.gte", listOf(tickerGte.toString()))
                }
                if (tickerGt != null) {
                    put("ticker.gt", listOf(tickerGt.toString()))
                }
                if (tickerLte != null) {
                    put("ticker.lte", listOf(tickerLte.toString()))
                }
                if (tickerLt != null) {
                    put("ticker.lt", listOf(tickerLt.toString()))
                }
                if (tickerAnyOf != null) {
                    put("ticker.any_of", listOf(tickerAnyOf.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v3/snapshot",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter timespan
     */
     enum class TimespanGetStocksAggregates(val value: kotlin.String) {
         @Json(name = "second") second("second"),
         @Json(name = "minute") minute("minute"),
         @Json(name = "hour") hour("hour"),
         @Json(name = "day") day("day"),
         @Json(name = "week") week("week"),
         @Json(name = "month") month("month"),
         @Json(name = "quarter") quarter("quarter"),
         @Json(name = "year") year("year");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortGetStocksAggregates(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v2/aggs/ticker/{stocksTicker}/range/{multiplier}/{timespan}/{from}/{to}
     * Aggregates (Bars)
     * Get aggregate bars for a stock over a given date range in custom time window sizes. &lt;br /&gt; &lt;br /&gt; For example, if timespan &#x3D; ‘minute’ and multiplier &#x3D; ‘5’ then 5-minute bars will be returned. 
     * @param stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param multiplier The size of the timespan multiplier.
     * @param timespan The size of the time window.
     * @param from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @param sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top).  (optional)
     * @param limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;.  (optional)
     * @return GetStocksAggregates200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStocksAggregates(stocksTicker: kotlin.String, multiplier: kotlin.Int, timespan: TimespanGetStocksAggregates, from: kotlin.String, to: kotlin.String, adjusted: kotlin.Boolean? = null, sort: SortGetStocksAggregates? = null, limit: kotlin.Int? = null) : GetStocksAggregates200Response {
        val localVarResponse = getStocksAggregatesWithHttpInfo(stocksTicker = stocksTicker, multiplier = multiplier, timespan = timespan, from = from, to = to, adjusted = adjusted, sort = sort, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetStocksAggregates200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/aggs/ticker/{stocksTicker}/range/{multiplier}/{timespan}/{from}/{to}
     * Aggregates (Bars)
     * Get aggregate bars for a stock over a given date range in custom time window sizes. &lt;br /&gt; &lt;br /&gt; For example, if timespan &#x3D; ‘minute’ and multiplier &#x3D; ‘5’ then 5-minute bars will be returned. 
     * @param stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param multiplier The size of the timespan multiplier.
     * @param timespan The size of the time window.
     * @param from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @param sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top).  (optional)
     * @param limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;.  (optional)
     * @return ApiResponse<GetStocksAggregates200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStocksAggregatesWithHttpInfo(stocksTicker: kotlin.String, multiplier: kotlin.Int, timespan: TimespanGetStocksAggregates, from: kotlin.String, to: kotlin.String, adjusted: kotlin.Boolean?, sort: SortGetStocksAggregates?, limit: kotlin.Int?) : ApiResponse<GetStocksAggregates200Response?> {
        val localVariableConfig = getStocksAggregatesRequestConfig(stocksTicker = stocksTicker, multiplier = multiplier, timespan = timespan, from = from, to = to, adjusted = adjusted, sort = sort, limit = limit)

        return request<Unit, GetStocksAggregates200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStocksAggregates
     *
     * @param stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param multiplier The size of the timespan multiplier.
     * @param timespan The size of the time window.
     * @param from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @param sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top).  (optional)
     * @param limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://polygon.io/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;.  (optional)
     * @return RequestConfig
     */
    fun getStocksAggregatesRequestConfig(stocksTicker: kotlin.String, multiplier: kotlin.Int, timespan: TimespanGetStocksAggregates, from: kotlin.String, to: kotlin.String, adjusted: kotlin.Boolean?, sort: SortGetStocksAggregates?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/aggs/ticker/{stocksTicker}/range/{multiplier}/{timespan}/{from}/{to}".replace("{"+"stocksTicker"+"}", encodeURIComponent(stocksTicker.toString())).replace("{"+"multiplier"+"}", encodeURIComponent(multiplier.toString())).replace("{"+"timespan"+"}", encodeURIComponent(timespan.value.toString())).replace("{"+"from"+"}", encodeURIComponent(from.toString())).replace("{"+"to"+"}", encodeURIComponent(to.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter timespan
     */
     enum class TimespanGetStocksEMA(val value: kotlin.String) {
         @Json(name = "minute") minute("minute"),
         @Json(name = "hour") hour("hour"),
         @Json(name = "day") day("day"),
         @Json(name = "week") week("week"),
         @Json(name = "month") month("month"),
         @Json(name = "quarter") quarter("quarter"),
         @Json(name = "year") year("year");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter seriesType
     */
     enum class SeriesTypeGetStocksEMA(val value: kotlin.String) {
         @Json(name = "open") `open`("open"),
         @Json(name = "high") high("high"),
         @Json(name = "low") low("low"),
         @Json(name = "close") close("close");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderGetStocksEMA(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v1/indicators/ema/{stockTicker}
     * Exponential Moving Average (EMA)
     * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
     * @param stockTicker Specify a case-sensitive ticker symbol for which to get exponential moving average (EMA) data. For example, AAPL represents Apple Inc.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param seriesType The price in the aggregate which will be used to calculate the exponential moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the exponential moving average (EMA). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return GetCryptoEMA200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStocksEMA(stockTicker: kotlin.String, timestamp: kotlin.String? = null, timespan: TimespanGetStocksEMA? = TimespanGetStocksEMA.day, adjusted: kotlin.Boolean? = true, window: kotlin.Int? = 50, seriesType: SeriesTypeGetStocksEMA? = SeriesTypeGetStocksEMA.close, expandUnderlying: kotlin.Boolean? = false, order: OrderGetStocksEMA? = OrderGetStocksEMA.desc, limit: kotlin.Int? = 10, timestampGte: kotlin.String? = null, timestampGt: kotlin.String? = null, timestampLte: kotlin.String? = null, timestampLt: kotlin.String? = null) : GetCryptoEMA200Response {
        val localVarResponse = getStocksEMAWithHttpInfo(stockTicker = stockTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, window = window, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoEMA200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/indicators/ema/{stockTicker}
     * Exponential Moving Average (EMA)
     * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
     * @param stockTicker Specify a case-sensitive ticker symbol for which to get exponential moving average (EMA) data. For example, AAPL represents Apple Inc.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param seriesType The price in the aggregate which will be used to calculate the exponential moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the exponential moving average (EMA). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return ApiResponse<GetCryptoEMA200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStocksEMAWithHttpInfo(stockTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetStocksEMA?, adjusted: kotlin.Boolean?, window: kotlin.Int?, seriesType: SeriesTypeGetStocksEMA?, expandUnderlying: kotlin.Boolean?, order: OrderGetStocksEMA?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : ApiResponse<GetCryptoEMA200Response?> {
        val localVariableConfig = getStocksEMARequestConfig(stockTicker = stockTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, window = window, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return request<Unit, GetCryptoEMA200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStocksEMA
     *
     * @param stockTicker Specify a case-sensitive ticker symbol for which to get exponential moving average (EMA) data. For example, AAPL represents Apple Inc.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param seriesType The price in the aggregate which will be used to calculate the exponential moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the exponential moving average (EMA). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return RequestConfig
     */
    fun getStocksEMARequestConfig(stockTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetStocksEMA?, adjusted: kotlin.Boolean?, window: kotlin.Int?, seriesType: SeriesTypeGetStocksEMA?, expandUnderlying: kotlin.Boolean?, order: OrderGetStocksEMA?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (timespan != null) {
                    put("timespan", listOf(timespan.value))
                }
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
                if (window != null) {
                    put("window", listOf(window.toString()))
                }
                if (seriesType != null) {
                    put("series_type", listOf(seriesType.value))
                }
                if (expandUnderlying != null) {
                    put("expand_underlying", listOf(expandUnderlying.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (timestampGte != null) {
                    put("timestamp.gte", listOf(timestampGte.toString()))
                }
                if (timestampGt != null) {
                    put("timestamp.gt", listOf(timestampGt.toString()))
                }
                if (timestampLte != null) {
                    put("timestamp.lte", listOf(timestampLte.toString()))
                }
                if (timestampLt != null) {
                    put("timestamp.lt", listOf(timestampLt.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/indicators/ema/{stockTicker}".replace("{"+"stockTicker"+"}", encodeURIComponent(stockTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter timespan
     */
     enum class TimespanGetStocksMACD(val value: kotlin.String) {
         @Json(name = "minute") minute("minute"),
         @Json(name = "hour") hour("hour"),
         @Json(name = "day") day("day"),
         @Json(name = "week") week("week"),
         @Json(name = "month") month("month"),
         @Json(name = "quarter") quarter("quarter"),
         @Json(name = "year") year("year");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter seriesType
     */
     enum class SeriesTypeGetStocksMACD(val value: kotlin.String) {
         @Json(name = "open") `open`("open"),
         @Json(name = "high") high("high"),
         @Json(name = "low") low("low"),
         @Json(name = "close") close("close");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderGetStocksMACD(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v1/indicators/macd/{stockTicker}
     * Moving Average Convergence/Divergence (MACD)
     * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
     * @param stockTicker Specify a case-sensitive ticker symbol for which to get moving average convergence/divergence (MACD) data. For example, AAPL represents Apple Inc.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param shortWindow The short window size used to calculate MACD data. (optional, default to 12)
     * @param longWindow The long window size used to calculate MACD data. (optional, default to 26)
     * @param signalWindow The window size used to calculate the MACD signal line. (optional, default to 9)
     * @param seriesType The price in the aggregate which will be used to calculate the MACD. i.e. &#39;close&#39; will result in using close prices to  calculate the MACD. (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return GetCryptoMACD200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStocksMACD(stockTicker: kotlin.String, timestamp: kotlin.String? = null, timespan: TimespanGetStocksMACD? = TimespanGetStocksMACD.day, adjusted: kotlin.Boolean? = true, shortWindow: kotlin.Int? = 12, longWindow: kotlin.Int? = 26, signalWindow: kotlin.Int? = 9, seriesType: SeriesTypeGetStocksMACD? = SeriesTypeGetStocksMACD.close, expandUnderlying: kotlin.Boolean? = false, order: OrderGetStocksMACD? = OrderGetStocksMACD.desc, limit: kotlin.Int? = 10, timestampGte: kotlin.String? = null, timestampGt: kotlin.String? = null, timestampLte: kotlin.String? = null, timestampLt: kotlin.String? = null) : GetCryptoMACD200Response {
        val localVarResponse = getStocksMACDWithHttpInfo(stockTicker = stockTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, shortWindow = shortWindow, longWindow = longWindow, signalWindow = signalWindow, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoMACD200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/indicators/macd/{stockTicker}
     * Moving Average Convergence/Divergence (MACD)
     * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
     * @param stockTicker Specify a case-sensitive ticker symbol for which to get moving average convergence/divergence (MACD) data. For example, AAPL represents Apple Inc.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param shortWindow The short window size used to calculate MACD data. (optional, default to 12)
     * @param longWindow The long window size used to calculate MACD data. (optional, default to 26)
     * @param signalWindow The window size used to calculate the MACD signal line. (optional, default to 9)
     * @param seriesType The price in the aggregate which will be used to calculate the MACD. i.e. &#39;close&#39; will result in using close prices to  calculate the MACD. (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return ApiResponse<GetCryptoMACD200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStocksMACDWithHttpInfo(stockTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetStocksMACD?, adjusted: kotlin.Boolean?, shortWindow: kotlin.Int?, longWindow: kotlin.Int?, signalWindow: kotlin.Int?, seriesType: SeriesTypeGetStocksMACD?, expandUnderlying: kotlin.Boolean?, order: OrderGetStocksMACD?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : ApiResponse<GetCryptoMACD200Response?> {
        val localVariableConfig = getStocksMACDRequestConfig(stockTicker = stockTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, shortWindow = shortWindow, longWindow = longWindow, signalWindow = signalWindow, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return request<Unit, GetCryptoMACD200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStocksMACD
     *
     * @param stockTicker Specify a case-sensitive ticker symbol for which to get moving average convergence/divergence (MACD) data. For example, AAPL represents Apple Inc.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param shortWindow The short window size used to calculate MACD data. (optional, default to 12)
     * @param longWindow The long window size used to calculate MACD data. (optional, default to 26)
     * @param signalWindow The window size used to calculate the MACD signal line. (optional, default to 9)
     * @param seriesType The price in the aggregate which will be used to calculate the MACD. i.e. &#39;close&#39; will result in using close prices to  calculate the MACD. (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return RequestConfig
     */
    fun getStocksMACDRequestConfig(stockTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetStocksMACD?, adjusted: kotlin.Boolean?, shortWindow: kotlin.Int?, longWindow: kotlin.Int?, signalWindow: kotlin.Int?, seriesType: SeriesTypeGetStocksMACD?, expandUnderlying: kotlin.Boolean?, order: OrderGetStocksMACD?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (timespan != null) {
                    put("timespan", listOf(timespan.value))
                }
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
                if (shortWindow != null) {
                    put("short_window", listOf(shortWindow.toString()))
                }
                if (longWindow != null) {
                    put("long_window", listOf(longWindow.toString()))
                }
                if (signalWindow != null) {
                    put("signal_window", listOf(signalWindow.toString()))
                }
                if (seriesType != null) {
                    put("series_type", listOf(seriesType.value))
                }
                if (expandUnderlying != null) {
                    put("expand_underlying", listOf(expandUnderlying.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (timestampGte != null) {
                    put("timestamp.gte", listOf(timestampGte.toString()))
                }
                if (timestampGt != null) {
                    put("timestamp.gt", listOf(timestampGt.toString()))
                }
                if (timestampLte != null) {
                    put("timestamp.lte", listOf(timestampLte.toString()))
                }
                if (timestampLt != null) {
                    put("timestamp.lt", listOf(timestampLt.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/indicators/macd/{stockTicker}".replace("{"+"stockTicker"+"}", encodeURIComponent(stockTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/open-close/{stocksTicker}/{date}
     * Daily Open/Close
     * Get the open, close and afterhours prices of a stock symbol on a certain date. 
     * @param stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param date The date of the requested open/close in the format YYYY-MM-DD.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return GetOptionsOpenClose200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStocksOpenClose(stocksTicker: kotlin.String, date: java.time.LocalDate, adjusted: kotlin.Boolean? = null) : GetOptionsOpenClose200Response {
        val localVarResponse = getStocksOpenCloseWithHttpInfo(stocksTicker = stocksTicker, date = date, adjusted = adjusted)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetOptionsOpenClose200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/open-close/{stocksTicker}/{date}
     * Daily Open/Close
     * Get the open, close and afterhours prices of a stock symbol on a certain date. 
     * @param stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param date The date of the requested open/close in the format YYYY-MM-DD.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return ApiResponse<GetOptionsOpenClose200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStocksOpenCloseWithHttpInfo(stocksTicker: kotlin.String, date: java.time.LocalDate, adjusted: kotlin.Boolean?) : ApiResponse<GetOptionsOpenClose200Response?> {
        val localVariableConfig = getStocksOpenCloseRequestConfig(stocksTicker = stocksTicker, date = date, adjusted = adjusted)

        return request<Unit, GetOptionsOpenClose200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStocksOpenClose
     *
     * @param stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param date The date of the requested open/close in the format YYYY-MM-DD.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return RequestConfig
     */
    fun getStocksOpenCloseRequestConfig(stocksTicker: kotlin.String, date: java.time.LocalDate, adjusted: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/open-close/{stocksTicker}/{date}".replace("{"+"stocksTicker"+"}", encodeURIComponent(stocksTicker.toString())).replace("{"+"date"+"}", encodeURIComponent(date.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter order
     */
     enum class OrderGetStocksQuotes(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortGetStocksQuotes(val value: kotlin.String) {
         @Json(name = "timestamp") timestamp("timestamp");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v3/quotes/{stockTicker}
     * Quotes (NBBO)
     * Get NBBO quotes for a ticker symbol in a given time range.
     * @param stockTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp. (optional)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 1000 and max is 50000. (optional, default to 1000)
     * @param sort Sort field used for ordering. (optional, default to timestamp)
     * @return GetStocksQuotes200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStocksQuotes(stockTicker: kotlin.String, timestamp: kotlin.String? = null, timestampGte: kotlin.String? = null, timestampGt: kotlin.String? = null, timestampLte: kotlin.String? = null, timestampLt: kotlin.String? = null, order: OrderGetStocksQuotes? = OrderGetStocksQuotes.desc, limit: kotlin.Int? = 1000, sort: SortGetStocksQuotes? = SortGetStocksQuotes.timestamp) : GetStocksQuotes200Response {
        val localVarResponse = getStocksQuotesWithHttpInfo(stockTicker = stockTicker, timestamp = timestamp, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt, order = order, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetStocksQuotes200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v3/quotes/{stockTicker}
     * Quotes (NBBO)
     * Get NBBO quotes for a ticker symbol in a given time range.
     * @param stockTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp. (optional)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 1000 and max is 50000. (optional, default to 1000)
     * @param sort Sort field used for ordering. (optional, default to timestamp)
     * @return ApiResponse<GetStocksQuotes200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStocksQuotesWithHttpInfo(stockTicker: kotlin.String, timestamp: kotlin.String?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?, order: OrderGetStocksQuotes?, limit: kotlin.Int?, sort: SortGetStocksQuotes?) : ApiResponse<GetStocksQuotes200Response?> {
        val localVariableConfig = getStocksQuotesRequestConfig(stockTicker = stockTicker, timestamp = timestamp, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt, order = order, limit = limit, sort = sort)

        return request<Unit, GetStocksQuotes200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStocksQuotes
     *
     * @param stockTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp. (optional)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 1000 and max is 50000. (optional, default to 1000)
     * @param sort Sort field used for ordering. (optional, default to timestamp)
     * @return RequestConfig
     */
    fun getStocksQuotesRequestConfig(stockTicker: kotlin.String, timestamp: kotlin.String?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?, order: OrderGetStocksQuotes?, limit: kotlin.Int?, sort: SortGetStocksQuotes?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (timestampGte != null) {
                    put("timestamp.gte", listOf(timestampGte.toString()))
                }
                if (timestampGt != null) {
                    put("timestamp.gt", listOf(timestampGt.toString()))
                }
                if (timestampLte != null) {
                    put("timestamp.lte", listOf(timestampLte.toString()))
                }
                if (timestampLt != null) {
                    put("timestamp.lt", listOf(timestampLt.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v3/quotes/{stockTicker}".replace("{"+"stockTicker"+"}", encodeURIComponent(stockTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter timespan
     */
     enum class TimespanGetStocksRSI(val value: kotlin.String) {
         @Json(name = "minute") minute("minute"),
         @Json(name = "hour") hour("hour"),
         @Json(name = "day") day("day"),
         @Json(name = "week") week("week"),
         @Json(name = "month") month("month"),
         @Json(name = "quarter") quarter("quarter"),
         @Json(name = "year") year("year");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter seriesType
     */
     enum class SeriesTypeGetStocksRSI(val value: kotlin.String) {
         @Json(name = "open") `open`("open"),
         @Json(name = "high") high("high"),
         @Json(name = "low") low("low"),
         @Json(name = "close") close("close");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderGetStocksRSI(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v1/indicators/rsi/{stockTicker}
     * Relative Strength Index (RSI)
     * Get the relative strength index (RSI) for a ticker symbol over a given time range.
     * @param stockTicker Specify a case-sensitive ticker symbol for which to get relative strength index (RSI) data. For example, AAPL represents Apple Inc.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the relative strength index (RSI). (optional, default to 14)
     * @param seriesType The price in the aggregate which will be used to calculate the relative strength index. i.e. &#39;close&#39; will result in using close prices to  calculate the relative strength index (RSI). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return GetCryptoRSI200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStocksRSI(stockTicker: kotlin.String, timestamp: kotlin.String? = null, timespan: TimespanGetStocksRSI? = TimespanGetStocksRSI.day, adjusted: kotlin.Boolean? = true, window: kotlin.Int? = 14, seriesType: SeriesTypeGetStocksRSI? = SeriesTypeGetStocksRSI.close, expandUnderlying: kotlin.Boolean? = false, order: OrderGetStocksRSI? = OrderGetStocksRSI.desc, limit: kotlin.Int? = 10, timestampGte: kotlin.String? = null, timestampGt: kotlin.String? = null, timestampLte: kotlin.String? = null, timestampLt: kotlin.String? = null) : GetCryptoRSI200Response {
        val localVarResponse = getStocksRSIWithHttpInfo(stockTicker = stockTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, window = window, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoRSI200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/indicators/rsi/{stockTicker}
     * Relative Strength Index (RSI)
     * Get the relative strength index (RSI) for a ticker symbol over a given time range.
     * @param stockTicker Specify a case-sensitive ticker symbol for which to get relative strength index (RSI) data. For example, AAPL represents Apple Inc.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the relative strength index (RSI). (optional, default to 14)
     * @param seriesType The price in the aggregate which will be used to calculate the relative strength index. i.e. &#39;close&#39; will result in using close prices to  calculate the relative strength index (RSI). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return ApiResponse<GetCryptoRSI200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStocksRSIWithHttpInfo(stockTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetStocksRSI?, adjusted: kotlin.Boolean?, window: kotlin.Int?, seriesType: SeriesTypeGetStocksRSI?, expandUnderlying: kotlin.Boolean?, order: OrderGetStocksRSI?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : ApiResponse<GetCryptoRSI200Response?> {
        val localVariableConfig = getStocksRSIRequestConfig(stockTicker = stockTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, window = window, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return request<Unit, GetCryptoRSI200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStocksRSI
     *
     * @param stockTicker Specify a case-sensitive ticker symbol for which to get relative strength index (RSI) data. For example, AAPL represents Apple Inc.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the relative strength index (RSI). (optional, default to 14)
     * @param seriesType The price in the aggregate which will be used to calculate the relative strength index. i.e. &#39;close&#39; will result in using close prices to  calculate the relative strength index (RSI). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return RequestConfig
     */
    fun getStocksRSIRequestConfig(stockTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetStocksRSI?, adjusted: kotlin.Boolean?, window: kotlin.Int?, seriesType: SeriesTypeGetStocksRSI?, expandUnderlying: kotlin.Boolean?, order: OrderGetStocksRSI?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (timespan != null) {
                    put("timespan", listOf(timespan.value))
                }
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
                if (window != null) {
                    put("window", listOf(window.toString()))
                }
                if (seriesType != null) {
                    put("series_type", listOf(seriesType.value))
                }
                if (expandUnderlying != null) {
                    put("expand_underlying", listOf(expandUnderlying.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (timestampGte != null) {
                    put("timestamp.gte", listOf(timestampGte.toString()))
                }
                if (timestampGt != null) {
                    put("timestamp.gt", listOf(timestampGt.toString()))
                }
                if (timestampLte != null) {
                    put("timestamp.lte", listOf(timestampLte.toString()))
                }
                if (timestampLt != null) {
                    put("timestamp.lt", listOf(timestampLt.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/indicators/rsi/{stockTicker}".replace("{"+"stockTicker"+"}", encodeURIComponent(stockTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter timespan
     */
     enum class TimespanGetStocksSMA(val value: kotlin.String) {
         @Json(name = "minute") minute("minute"),
         @Json(name = "hour") hour("hour"),
         @Json(name = "day") day("day"),
         @Json(name = "week") week("week"),
         @Json(name = "month") month("month"),
         @Json(name = "quarter") quarter("quarter"),
         @Json(name = "year") year("year");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter seriesType
     */
     enum class SeriesTypeGetStocksSMA(val value: kotlin.String) {
         @Json(name = "open") `open`("open"),
         @Json(name = "high") high("high"),
         @Json(name = "low") low("low"),
         @Json(name = "close") close("close");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderGetStocksSMA(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v1/indicators/sma/{stockTicker}
     * Simple Moving Average (SMA)
     * Get the simple moving average (SMA) for a ticker symbol over a given time range.
     * @param stockTicker Specify a case-sensitive ticker symbol for which to get simple moving average (SMA) data. For example, AAPL represents Apple Inc.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param seriesType The price in the aggregate which will be used to calculate the simple moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the simple moving average (SMA). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return GetCryptoSMA200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStocksSMA(stockTicker: kotlin.String, timestamp: kotlin.String? = null, timespan: TimespanGetStocksSMA? = TimespanGetStocksSMA.day, adjusted: kotlin.Boolean? = true, window: kotlin.Int? = 50, seriesType: SeriesTypeGetStocksSMA? = SeriesTypeGetStocksSMA.close, expandUnderlying: kotlin.Boolean? = false, order: OrderGetStocksSMA? = OrderGetStocksSMA.desc, limit: kotlin.Int? = 10, timestampGte: kotlin.String? = null, timestampGt: kotlin.String? = null, timestampLte: kotlin.String? = null, timestampLt: kotlin.String? = null) : GetCryptoSMA200Response {
        val localVarResponse = getStocksSMAWithHttpInfo(stockTicker = stockTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, window = window, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoSMA200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/indicators/sma/{stockTicker}
     * Simple Moving Average (SMA)
     * Get the simple moving average (SMA) for a ticker symbol over a given time range.
     * @param stockTicker Specify a case-sensitive ticker symbol for which to get simple moving average (SMA) data. For example, AAPL represents Apple Inc.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param seriesType The price in the aggregate which will be used to calculate the simple moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the simple moving average (SMA). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return ApiResponse<GetCryptoSMA200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStocksSMAWithHttpInfo(stockTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetStocksSMA?, adjusted: kotlin.Boolean?, window: kotlin.Int?, seriesType: SeriesTypeGetStocksSMA?, expandUnderlying: kotlin.Boolean?, order: OrderGetStocksSMA?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : ApiResponse<GetCryptoSMA200Response?> {
        val localVariableConfig = getStocksSMARequestConfig(stockTicker = stockTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, window = window, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return request<Unit, GetCryptoSMA200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStocksSMA
     *
     * @param stockTicker Specify a case-sensitive ticker symbol for which to get simple moving average (SMA) data. For example, AAPL represents Apple Inc.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param seriesType The price in the aggregate which will be used to calculate the simple moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the simple moving average (SMA). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return RequestConfig
     */
    fun getStocksSMARequestConfig(stockTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetStocksSMA?, adjusted: kotlin.Boolean?, window: kotlin.Int?, seriesType: SeriesTypeGetStocksSMA?, expandUnderlying: kotlin.Boolean?, order: OrderGetStocksSMA?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (timespan != null) {
                    put("timespan", listOf(timespan.value))
                }
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
                if (window != null) {
                    put("window", listOf(window.toString()))
                }
                if (seriesType != null) {
                    put("series_type", listOf(seriesType.value))
                }
                if (expandUnderlying != null) {
                    put("expand_underlying", listOf(expandUnderlying.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (timestampGte != null) {
                    put("timestamp.gte", listOf(timestampGte.toString()))
                }
                if (timestampGt != null) {
                    put("timestamp.gt", listOf(timestampGt.toString()))
                }
                if (timestampLte != null) {
                    put("timestamp.lte", listOf(timestampLte.toString()))
                }
                if (timestampLt != null) {
                    put("timestamp.lt", listOf(timestampLt.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/indicators/sma/{stockTicker}".replace("{"+"stockTicker"+"}", encodeURIComponent(stockTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter direction
     */
     enum class DirectionGetStocksSnapshotDirection(val value: kotlin.String) {
         @Json(name = "gainers") gainers("gainers"),
         @Json(name = "losers") losers("losers");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v2/snapshot/locale/us/markets/stocks/{direction}
     * Gainers/Losers
     * Get the most up-to-date market data for the current top 20 gainers or losers of the day in the stocks/equities markets. &lt;br /&gt; &lt;br /&gt; Top gainers are those tickers whose price has increased by the highest percentage since the previous day&#39;s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day&#39;s close. This output will only include tickers with a trading volume of 10,000 or more. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. 
     * @param direction The direction of the snapshot results to return. 
     * @param includeOtc Include OTC securities in the response. Default is false (don&#39;t include OTC securities).  (optional)
     * @return GetStocksSnapshotDirection200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStocksSnapshotDirection(direction: DirectionGetStocksSnapshotDirection, includeOtc: kotlin.Boolean? = null) : GetStocksSnapshotDirection200Response {
        val localVarResponse = getStocksSnapshotDirectionWithHttpInfo(direction = direction, includeOtc = includeOtc)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetStocksSnapshotDirection200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/snapshot/locale/us/markets/stocks/{direction}
     * Gainers/Losers
     * Get the most up-to-date market data for the current top 20 gainers or losers of the day in the stocks/equities markets. &lt;br /&gt; &lt;br /&gt; Top gainers are those tickers whose price has increased by the highest percentage since the previous day&#39;s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day&#39;s close. This output will only include tickers with a trading volume of 10,000 or more. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. 
     * @param direction The direction of the snapshot results to return. 
     * @param includeOtc Include OTC securities in the response. Default is false (don&#39;t include OTC securities).  (optional)
     * @return ApiResponse<GetStocksSnapshotDirection200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStocksSnapshotDirectionWithHttpInfo(direction: DirectionGetStocksSnapshotDirection, includeOtc: kotlin.Boolean?) : ApiResponse<GetStocksSnapshotDirection200Response?> {
        val localVariableConfig = getStocksSnapshotDirectionRequestConfig(direction = direction, includeOtc = includeOtc)

        return request<Unit, GetStocksSnapshotDirection200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStocksSnapshotDirection
     *
     * @param direction The direction of the snapshot results to return. 
     * @param includeOtc Include OTC securities in the response. Default is false (don&#39;t include OTC securities).  (optional)
     * @return RequestConfig
     */
    fun getStocksSnapshotDirectionRequestConfig(direction: DirectionGetStocksSnapshotDirection, includeOtc: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (includeOtc != null) {
                    put("include_otc", listOf(includeOtc.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/snapshot/locale/us/markets/stocks/{direction}".replace("{"+"direction"+"}", encodeURIComponent(direction.value.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/snapshot/locale/us/markets/stocks/tickers/{stocksTicker}
     * Ticker
     * Get the most up-to-date market data for a single traded stock ticker. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
     * @param stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @return GetStocksSnapshotTicker200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStocksSnapshotTicker(stocksTicker: kotlin.String) : GetStocksSnapshotTicker200Response {
        val localVarResponse = getStocksSnapshotTickerWithHttpInfo(stocksTicker = stocksTicker)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetStocksSnapshotTicker200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/snapshot/locale/us/markets/stocks/tickers/{stocksTicker}
     * Ticker
     * Get the most up-to-date market data for a single traded stock ticker. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
     * @param stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @return ApiResponse<GetStocksSnapshotTicker200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStocksSnapshotTickerWithHttpInfo(stocksTicker: kotlin.String) : ApiResponse<GetStocksSnapshotTicker200Response?> {
        val localVariableConfig = getStocksSnapshotTickerRequestConfig(stocksTicker = stocksTicker)

        return request<Unit, GetStocksSnapshotTicker200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStocksSnapshotTicker
     *
     * @param stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @return RequestConfig
     */
    fun getStocksSnapshotTickerRequestConfig(stocksTicker: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/snapshot/locale/us/markets/stocks/tickers/{stocksTicker}".replace("{"+"stocksTicker"+"}", encodeURIComponent(stocksTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/snapshot/locale/us/markets/stocks/tickers
     * All Tickers
     * Get the most up-to-date market data for all traded stock symbols. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
     * @param tickers A case-sensitive comma separated list of tickers to get snapshots for. For example, AAPL,TSLA,GOOG. Empty string defaults to querying all tickers. (optional)
     * @param includeOtc Include OTC securities in the response. Default is false (don&#39;t include OTC securities).  (optional)
     * @return GetStocksSnapshotTickers200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStocksSnapshotTickers(tickers: kotlin.collections.List<kotlin.String>? = null, includeOtc: kotlin.Boolean? = null) : GetStocksSnapshotTickers200Response {
        val localVarResponse = getStocksSnapshotTickersWithHttpInfo(tickers = tickers, includeOtc = includeOtc)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetStocksSnapshotTickers200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/snapshot/locale/us/markets/stocks/tickers
     * All Tickers
     * Get the most up-to-date market data for all traded stock symbols. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
     * @param tickers A case-sensitive comma separated list of tickers to get snapshots for. For example, AAPL,TSLA,GOOG. Empty string defaults to querying all tickers. (optional)
     * @param includeOtc Include OTC securities in the response. Default is false (don&#39;t include OTC securities).  (optional)
     * @return ApiResponse<GetStocksSnapshotTickers200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStocksSnapshotTickersWithHttpInfo(tickers: kotlin.collections.List<kotlin.String>?, includeOtc: kotlin.Boolean?) : ApiResponse<GetStocksSnapshotTickers200Response?> {
        val localVariableConfig = getStocksSnapshotTickersRequestConfig(tickers = tickers, includeOtc = includeOtc)

        return request<Unit, GetStocksSnapshotTickers200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStocksSnapshotTickers
     *
     * @param tickers A case-sensitive comma separated list of tickers to get snapshots for. For example, AAPL,TSLA,GOOG. Empty string defaults to querying all tickers. (optional)
     * @param includeOtc Include OTC securities in the response. Default is false (don&#39;t include OTC securities).  (optional)
     * @return RequestConfig
     */
    fun getStocksSnapshotTickersRequestConfig(tickers: kotlin.collections.List<kotlin.String>?, includeOtc: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (tickers != null) {
                    put("tickers", toMultiValue(tickers.toList(), "multi"))
                }
                if (includeOtc != null) {
                    put("include_otc", listOf(includeOtc.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/snapshot/locale/us/markets/stocks/tickers",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter order
     */
     enum class OrderGetStocksTrades(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortGetStocksTrades(val value: kotlin.String) {
         @Json(name = "timestamp") timestamp("timestamp");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v3/trades/{stockTicker}
     * Trades
     * Get trades for a ticker symbol in a given time range.
     * @param stockTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param timestamp Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp. (optional)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 1000 and max is 50000. (optional, default to 1000)
     * @param sort Sort field used for ordering. (optional, default to timestamp)
     * @return GetStocksTrades200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStocksTrades(stockTicker: kotlin.String, timestamp: kotlin.String? = null, timestampGte: kotlin.String? = null, timestampGt: kotlin.String? = null, timestampLte: kotlin.String? = null, timestampLt: kotlin.String? = null, order: OrderGetStocksTrades? = OrderGetStocksTrades.desc, limit: kotlin.Int? = 1000, sort: SortGetStocksTrades? = SortGetStocksTrades.timestamp) : GetStocksTrades200Response {
        val localVarResponse = getStocksTradesWithHttpInfo(stockTicker = stockTicker, timestamp = timestamp, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt, order = order, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetStocksTrades200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v3/trades/{stockTicker}
     * Trades
     * Get trades for a ticker symbol in a given time range.
     * @param stockTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param timestamp Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp. (optional)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 1000 and max is 50000. (optional, default to 1000)
     * @param sort Sort field used for ordering. (optional, default to timestamp)
     * @return ApiResponse<GetStocksTrades200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStocksTradesWithHttpInfo(stockTicker: kotlin.String, timestamp: kotlin.String?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?, order: OrderGetStocksTrades?, limit: kotlin.Int?, sort: SortGetStocksTrades?) : ApiResponse<GetStocksTrades200Response?> {
        val localVariableConfig = getStocksTradesRequestConfig(stockTicker = stockTicker, timestamp = timestamp, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt, order = order, limit = limit, sort = sort)

        return request<Unit, GetStocksTrades200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStocksTrades
     *
     * @param stockTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param timestamp Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp. (optional)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 1000 and max is 50000. (optional, default to 1000)
     * @param sort Sort field used for ordering. (optional, default to timestamp)
     * @return RequestConfig
     */
    fun getStocksTradesRequestConfig(stockTicker: kotlin.String, timestamp: kotlin.String?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?, order: OrderGetStocksTrades?, limit: kotlin.Int?, sort: SortGetStocksTrades?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (timestampGte != null) {
                    put("timestamp.gte", listOf(timestampGte.toString()))
                }
                if (timestampGt != null) {
                    put("timestamp.gt", listOf(timestampGt.toString()))
                }
                if (timestampLte != null) {
                    put("timestamp.lte", listOf(timestampLte.toString()))
                }
                if (timestampLt != null) {
                    put("timestamp.lt", listOf(timestampLt.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v3/trades/{stockTicker}".replace("{"+"stockTicker"+"}", encodeURIComponent(stockTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /stocks/v1/short-interest
     * 
     * 
     * @param ticker The primary ticker symbol for the stock. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param daysToCover Calculated as short_interest divided by avg_daily_volume, representing the estimated number of days it would take to cover all short positions based on average trading volume. Value must be a floating point number. (optional)
     * @param daysToCoverAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number. (optional)
     * @param daysToCoverGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param daysToCoverGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param daysToCoverLt Filter less than the value. Value must be a floating point number. (optional)
     * @param daysToCoverLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param settlementDate The date (formatted as YYYY-MM-DD) on which the short interest data is considered settled, typically based on exchange reporting schedules. (optional)
     * @param settlementDateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param settlementDateGt Filter greater than the value. (optional)
     * @param settlementDateGte Filter greater than or equal to the value. (optional)
     * @param settlementDateLt Filter less than the value. (optional)
     * @param settlementDateLte Filter less than or equal to the value. (optional)
     * @param avgDailyVolume The average daily trading volume for the stock over a specified period, typically used to contextualize short interest. Value must be an integer. (optional)
     * @param avgDailyVolumeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param avgDailyVolumeGt Filter greater than the value. Value must be an integer. (optional)
     * @param avgDailyVolumeGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param avgDailyVolumeLt Filter less than the value. Value must be an integer. (optional)
     * @param avgDailyVolumeLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;10&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 10)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;ticker&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "ticker.asc")
     * @return GetStocksV1ShortInterest200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStocksV1ShortInterest(ticker: kotlin.String? = null, tickerAnyOf: kotlin.String? = null, tickerGt: kotlin.String? = null, tickerGte: kotlin.String? = null, tickerLt: kotlin.String? = null, tickerLte: kotlin.String? = null, daysToCover: kotlin.Double? = null, daysToCoverAnyOf: kotlin.String? = null, daysToCoverGt: kotlin.Double? = null, daysToCoverGte: kotlin.Double? = null, daysToCoverLt: kotlin.Double? = null, daysToCoverLte: kotlin.Double? = null, settlementDate: kotlin.String? = null, settlementDateAnyOf: kotlin.String? = null, settlementDateGt: kotlin.String? = null, settlementDateGte: kotlin.String? = null, settlementDateLt: kotlin.String? = null, settlementDateLte: kotlin.String? = null, avgDailyVolume: kotlin.Long? = null, avgDailyVolumeAnyOf: kotlin.String? = null, avgDailyVolumeGt: kotlin.Long? = null, avgDailyVolumeGte: kotlin.Long? = null, avgDailyVolumeLt: kotlin.Long? = null, avgDailyVolumeLte: kotlin.Long? = null, limit: kotlin.Int? = 10, sort: kotlin.String? = "ticker.asc") : GetStocksV1ShortInterest200Response {
        val localVarResponse = getStocksV1ShortInterestWithHttpInfo(ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, daysToCover = daysToCover, daysToCoverAnyOf = daysToCoverAnyOf, daysToCoverGt = daysToCoverGt, daysToCoverGte = daysToCoverGte, daysToCoverLt = daysToCoverLt, daysToCoverLte = daysToCoverLte, settlementDate = settlementDate, settlementDateAnyOf = settlementDateAnyOf, settlementDateGt = settlementDateGt, settlementDateGte = settlementDateGte, settlementDateLt = settlementDateLt, settlementDateLte = settlementDateLte, avgDailyVolume = avgDailyVolume, avgDailyVolumeAnyOf = avgDailyVolumeAnyOf, avgDailyVolumeGt = avgDailyVolumeGt, avgDailyVolumeGte = avgDailyVolumeGte, avgDailyVolumeLt = avgDailyVolumeLt, avgDailyVolumeLte = avgDailyVolumeLte, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetStocksV1ShortInterest200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /stocks/v1/short-interest
     * 
     * 
     * @param ticker The primary ticker symbol for the stock. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param daysToCover Calculated as short_interest divided by avg_daily_volume, representing the estimated number of days it would take to cover all short positions based on average trading volume. Value must be a floating point number. (optional)
     * @param daysToCoverAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number. (optional)
     * @param daysToCoverGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param daysToCoverGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param daysToCoverLt Filter less than the value. Value must be a floating point number. (optional)
     * @param daysToCoverLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param settlementDate The date (formatted as YYYY-MM-DD) on which the short interest data is considered settled, typically based on exchange reporting schedules. (optional)
     * @param settlementDateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param settlementDateGt Filter greater than the value. (optional)
     * @param settlementDateGte Filter greater than or equal to the value. (optional)
     * @param settlementDateLt Filter less than the value. (optional)
     * @param settlementDateLte Filter less than or equal to the value. (optional)
     * @param avgDailyVolume The average daily trading volume for the stock over a specified period, typically used to contextualize short interest. Value must be an integer. (optional)
     * @param avgDailyVolumeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param avgDailyVolumeGt Filter greater than the value. Value must be an integer. (optional)
     * @param avgDailyVolumeGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param avgDailyVolumeLt Filter less than the value. Value must be an integer. (optional)
     * @param avgDailyVolumeLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;10&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 10)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;ticker&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "ticker.asc")
     * @return ApiResponse<GetStocksV1ShortInterest200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStocksV1ShortInterestWithHttpInfo(ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, daysToCover: kotlin.Double?, daysToCoverAnyOf: kotlin.String?, daysToCoverGt: kotlin.Double?, daysToCoverGte: kotlin.Double?, daysToCoverLt: kotlin.Double?, daysToCoverLte: kotlin.Double?, settlementDate: kotlin.String?, settlementDateAnyOf: kotlin.String?, settlementDateGt: kotlin.String?, settlementDateGte: kotlin.String?, settlementDateLt: kotlin.String?, settlementDateLte: kotlin.String?, avgDailyVolume: kotlin.Long?, avgDailyVolumeAnyOf: kotlin.String?, avgDailyVolumeGt: kotlin.Long?, avgDailyVolumeGte: kotlin.Long?, avgDailyVolumeLt: kotlin.Long?, avgDailyVolumeLte: kotlin.Long?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetStocksV1ShortInterest200Response?> {
        val localVariableConfig = getStocksV1ShortInterestRequestConfig(ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, daysToCover = daysToCover, daysToCoverAnyOf = daysToCoverAnyOf, daysToCoverGt = daysToCoverGt, daysToCoverGte = daysToCoverGte, daysToCoverLt = daysToCoverLt, daysToCoverLte = daysToCoverLte, settlementDate = settlementDate, settlementDateAnyOf = settlementDateAnyOf, settlementDateGt = settlementDateGt, settlementDateGte = settlementDateGte, settlementDateLt = settlementDateLt, settlementDateLte = settlementDateLte, avgDailyVolume = avgDailyVolume, avgDailyVolumeAnyOf = avgDailyVolumeAnyOf, avgDailyVolumeGt = avgDailyVolumeGt, avgDailyVolumeGte = avgDailyVolumeGte, avgDailyVolumeLt = avgDailyVolumeLt, avgDailyVolumeLte = avgDailyVolumeLte, limit = limit, sort = sort)

        return request<Unit, GetStocksV1ShortInterest200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStocksV1ShortInterest
     *
     * @param ticker The primary ticker symbol for the stock. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param daysToCover Calculated as short_interest divided by avg_daily_volume, representing the estimated number of days it would take to cover all short positions based on average trading volume. Value must be a floating point number. (optional)
     * @param daysToCoverAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number. (optional)
     * @param daysToCoverGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param daysToCoverGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param daysToCoverLt Filter less than the value. Value must be a floating point number. (optional)
     * @param daysToCoverLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param settlementDate The date (formatted as YYYY-MM-DD) on which the short interest data is considered settled, typically based on exchange reporting schedules. (optional)
     * @param settlementDateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param settlementDateGt Filter greater than the value. (optional)
     * @param settlementDateGte Filter greater than or equal to the value. (optional)
     * @param settlementDateLt Filter less than the value. (optional)
     * @param settlementDateLte Filter less than or equal to the value. (optional)
     * @param avgDailyVolume The average daily trading volume for the stock over a specified period, typically used to contextualize short interest. Value must be an integer. (optional)
     * @param avgDailyVolumeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param avgDailyVolumeGt Filter greater than the value. Value must be an integer. (optional)
     * @param avgDailyVolumeGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param avgDailyVolumeLt Filter less than the value. Value must be an integer. (optional)
     * @param avgDailyVolumeLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;10&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 10)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;ticker&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "ticker.asc")
     * @return RequestConfig
     */
    fun getStocksV1ShortInterestRequestConfig(ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, daysToCover: kotlin.Double?, daysToCoverAnyOf: kotlin.String?, daysToCoverGt: kotlin.Double?, daysToCoverGte: kotlin.Double?, daysToCoverLt: kotlin.Double?, daysToCoverLte: kotlin.Double?, settlementDate: kotlin.String?, settlementDateAnyOf: kotlin.String?, settlementDateGt: kotlin.String?, settlementDateGte: kotlin.String?, settlementDateLt: kotlin.String?, settlementDateLte: kotlin.String?, avgDailyVolume: kotlin.Long?, avgDailyVolumeAnyOf: kotlin.String?, avgDailyVolumeGt: kotlin.Long?, avgDailyVolumeGte: kotlin.Long?, avgDailyVolumeLt: kotlin.Long?, avgDailyVolumeLte: kotlin.Long?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
                if (tickerAnyOf != null) {
                    put("ticker.any_of", listOf(tickerAnyOf.toString()))
                }
                if (tickerGt != null) {
                    put("ticker.gt", listOf(tickerGt.toString()))
                }
                if (tickerGte != null) {
                    put("ticker.gte", listOf(tickerGte.toString()))
                }
                if (tickerLt != null) {
                    put("ticker.lt", listOf(tickerLt.toString()))
                }
                if (tickerLte != null) {
                    put("ticker.lte", listOf(tickerLte.toString()))
                }
                if (daysToCover != null) {
                    put("days_to_cover", listOf(daysToCover.toString()))
                }
                if (daysToCoverAnyOf != null) {
                    put("days_to_cover.any_of", listOf(daysToCoverAnyOf.toString()))
                }
                if (daysToCoverGt != null) {
                    put("days_to_cover.gt", listOf(daysToCoverGt.toString()))
                }
                if (daysToCoverGte != null) {
                    put("days_to_cover.gte", listOf(daysToCoverGte.toString()))
                }
                if (daysToCoverLt != null) {
                    put("days_to_cover.lt", listOf(daysToCoverLt.toString()))
                }
                if (daysToCoverLte != null) {
                    put("days_to_cover.lte", listOf(daysToCoverLte.toString()))
                }
                if (settlementDate != null) {
                    put("settlement_date", listOf(settlementDate.toString()))
                }
                if (settlementDateAnyOf != null) {
                    put("settlement_date.any_of", listOf(settlementDateAnyOf.toString()))
                }
                if (settlementDateGt != null) {
                    put("settlement_date.gt", listOf(settlementDateGt.toString()))
                }
                if (settlementDateGte != null) {
                    put("settlement_date.gte", listOf(settlementDateGte.toString()))
                }
                if (settlementDateLt != null) {
                    put("settlement_date.lt", listOf(settlementDateLt.toString()))
                }
                if (settlementDateLte != null) {
                    put("settlement_date.lte", listOf(settlementDateLte.toString()))
                }
                if (avgDailyVolume != null) {
                    put("avg_daily_volume", listOf(avgDailyVolume.toString()))
                }
                if (avgDailyVolumeAnyOf != null) {
                    put("avg_daily_volume.any_of", listOf(avgDailyVolumeAnyOf.toString()))
                }
                if (avgDailyVolumeGt != null) {
                    put("avg_daily_volume.gt", listOf(avgDailyVolumeGt.toString()))
                }
                if (avgDailyVolumeGte != null) {
                    put("avg_daily_volume.gte", listOf(avgDailyVolumeGte.toString()))
                }
                if (avgDailyVolumeLt != null) {
                    put("avg_daily_volume.lt", listOf(avgDailyVolumeLt.toString()))
                }
                if (avgDailyVolumeLte != null) {
                    put("avg_daily_volume.lte", listOf(avgDailyVolumeLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stocks/v1/short-interest",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /stocks/v1/short-volume
     * 
     * 
     * @param ticker The primary ticker symbol for the stock. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param date The date of trade activity reported in the format YYYY-MM-DD (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param shortVolumeRatio The percentage of total volume that was sold short. Calculated as (short_volume / total_volume) * 100. Value must be a floating point number. (optional)
     * @param shortVolumeRatioAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number. (optional)
     * @param shortVolumeRatioGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param shortVolumeRatioGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param shortVolumeRatioLt Filter less than the value. Value must be a floating point number. (optional)
     * @param shortVolumeRatioLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param totalVolume Total reported volume across all venues for the ticker on the given date. Value must be an integer. (optional)
     * @param totalVolumeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param totalVolumeGt Filter greater than the value. Value must be an integer. (optional)
     * @param totalVolumeGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param totalVolumeLt Filter less than the value. Value must be an integer. (optional)
     * @param totalVolumeLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;10&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 10)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;ticker&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "ticker.asc")
     * @return GetStocksV1ShortVolume200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStocksV1ShortVolume(ticker: kotlin.String? = null, tickerAnyOf: kotlin.String? = null, tickerGt: kotlin.String? = null, tickerGte: kotlin.String? = null, tickerLt: kotlin.String? = null, tickerLte: kotlin.String? = null, date: kotlin.String? = null, dateAnyOf: kotlin.String? = null, dateGt: kotlin.String? = null, dateGte: kotlin.String? = null, dateLt: kotlin.String? = null, dateLte: kotlin.String? = null, shortVolumeRatio: kotlin.Double? = null, shortVolumeRatioAnyOf: kotlin.String? = null, shortVolumeRatioGt: kotlin.Double? = null, shortVolumeRatioGte: kotlin.Double? = null, shortVolumeRatioLt: kotlin.Double? = null, shortVolumeRatioLte: kotlin.Double? = null, totalVolume: kotlin.Long? = null, totalVolumeAnyOf: kotlin.String? = null, totalVolumeGt: kotlin.Long? = null, totalVolumeGte: kotlin.Long? = null, totalVolumeLt: kotlin.Long? = null, totalVolumeLte: kotlin.Long? = null, limit: kotlin.Int? = 10, sort: kotlin.String? = "ticker.asc") : GetStocksV1ShortVolume200Response {
        val localVarResponse = getStocksV1ShortVolumeWithHttpInfo(ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, date = date, dateAnyOf = dateAnyOf, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, shortVolumeRatio = shortVolumeRatio, shortVolumeRatioAnyOf = shortVolumeRatioAnyOf, shortVolumeRatioGt = shortVolumeRatioGt, shortVolumeRatioGte = shortVolumeRatioGte, shortVolumeRatioLt = shortVolumeRatioLt, shortVolumeRatioLte = shortVolumeRatioLte, totalVolume = totalVolume, totalVolumeAnyOf = totalVolumeAnyOf, totalVolumeGt = totalVolumeGt, totalVolumeGte = totalVolumeGte, totalVolumeLt = totalVolumeLt, totalVolumeLte = totalVolumeLte, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetStocksV1ShortVolume200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /stocks/v1/short-volume
     * 
     * 
     * @param ticker The primary ticker symbol for the stock. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param date The date of trade activity reported in the format YYYY-MM-DD (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param shortVolumeRatio The percentage of total volume that was sold short. Calculated as (short_volume / total_volume) * 100. Value must be a floating point number. (optional)
     * @param shortVolumeRatioAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number. (optional)
     * @param shortVolumeRatioGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param shortVolumeRatioGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param shortVolumeRatioLt Filter less than the value. Value must be a floating point number. (optional)
     * @param shortVolumeRatioLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param totalVolume Total reported volume across all venues for the ticker on the given date. Value must be an integer. (optional)
     * @param totalVolumeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param totalVolumeGt Filter greater than the value. Value must be an integer. (optional)
     * @param totalVolumeGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param totalVolumeLt Filter less than the value. Value must be an integer. (optional)
     * @param totalVolumeLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;10&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 10)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;ticker&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "ticker.asc")
     * @return ApiResponse<GetStocksV1ShortVolume200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStocksV1ShortVolumeWithHttpInfo(ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, date: kotlin.String?, dateAnyOf: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, shortVolumeRatio: kotlin.Double?, shortVolumeRatioAnyOf: kotlin.String?, shortVolumeRatioGt: kotlin.Double?, shortVolumeRatioGte: kotlin.Double?, shortVolumeRatioLt: kotlin.Double?, shortVolumeRatioLte: kotlin.Double?, totalVolume: kotlin.Long?, totalVolumeAnyOf: kotlin.String?, totalVolumeGt: kotlin.Long?, totalVolumeGte: kotlin.Long?, totalVolumeLt: kotlin.Long?, totalVolumeLte: kotlin.Long?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetStocksV1ShortVolume200Response?> {
        val localVariableConfig = getStocksV1ShortVolumeRequestConfig(ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, date = date, dateAnyOf = dateAnyOf, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, shortVolumeRatio = shortVolumeRatio, shortVolumeRatioAnyOf = shortVolumeRatioAnyOf, shortVolumeRatioGt = shortVolumeRatioGt, shortVolumeRatioGte = shortVolumeRatioGte, shortVolumeRatioLt = shortVolumeRatioLt, shortVolumeRatioLte = shortVolumeRatioLte, totalVolume = totalVolume, totalVolumeAnyOf = totalVolumeAnyOf, totalVolumeGt = totalVolumeGt, totalVolumeGte = totalVolumeGte, totalVolumeLt = totalVolumeLt, totalVolumeLte = totalVolumeLte, limit = limit, sort = sort)

        return request<Unit, GetStocksV1ShortVolume200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStocksV1ShortVolume
     *
     * @param ticker The primary ticker symbol for the stock. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param date The date of trade activity reported in the format YYYY-MM-DD (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param shortVolumeRatio The percentage of total volume that was sold short. Calculated as (short_volume / total_volume) * 100. Value must be a floating point number. (optional)
     * @param shortVolumeRatioAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number. (optional)
     * @param shortVolumeRatioGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param shortVolumeRatioGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param shortVolumeRatioLt Filter less than the value. Value must be a floating point number. (optional)
     * @param shortVolumeRatioLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param totalVolume Total reported volume across all venues for the ticker on the given date. Value must be an integer. (optional)
     * @param totalVolumeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param totalVolumeGt Filter greater than the value. Value must be an integer. (optional)
     * @param totalVolumeGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param totalVolumeLt Filter less than the value. Value must be an integer. (optional)
     * @param totalVolumeLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;10&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 10)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;ticker&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "ticker.asc")
     * @return RequestConfig
     */
    fun getStocksV1ShortVolumeRequestConfig(ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, date: kotlin.String?, dateAnyOf: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, shortVolumeRatio: kotlin.Double?, shortVolumeRatioAnyOf: kotlin.String?, shortVolumeRatioGt: kotlin.Double?, shortVolumeRatioGte: kotlin.Double?, shortVolumeRatioLt: kotlin.Double?, shortVolumeRatioLte: kotlin.Double?, totalVolume: kotlin.Long?, totalVolumeAnyOf: kotlin.String?, totalVolumeGt: kotlin.Long?, totalVolumeGte: kotlin.Long?, totalVolumeLt: kotlin.Long?, totalVolumeLte: kotlin.Long?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
                if (tickerAnyOf != null) {
                    put("ticker.any_of", listOf(tickerAnyOf.toString()))
                }
                if (tickerGt != null) {
                    put("ticker.gt", listOf(tickerGt.toString()))
                }
                if (tickerGte != null) {
                    put("ticker.gte", listOf(tickerGte.toString()))
                }
                if (tickerLt != null) {
                    put("ticker.lt", listOf(tickerLt.toString()))
                }
                if (tickerLte != null) {
                    put("ticker.lte", listOf(tickerLte.toString()))
                }
                if (date != null) {
                    put("date", listOf(date.toString()))
                }
                if (dateAnyOf != null) {
                    put("date.any_of", listOf(dateAnyOf.toString()))
                }
                if (dateGt != null) {
                    put("date.gt", listOf(dateGt.toString()))
                }
                if (dateGte != null) {
                    put("date.gte", listOf(dateGte.toString()))
                }
                if (dateLt != null) {
                    put("date.lt", listOf(dateLt.toString()))
                }
                if (dateLte != null) {
                    put("date.lte", listOf(dateLte.toString()))
                }
                if (shortVolumeRatio != null) {
                    put("short_volume_ratio", listOf(shortVolumeRatio.toString()))
                }
                if (shortVolumeRatioAnyOf != null) {
                    put("short_volume_ratio.any_of", listOf(shortVolumeRatioAnyOf.toString()))
                }
                if (shortVolumeRatioGt != null) {
                    put("short_volume_ratio.gt", listOf(shortVolumeRatioGt.toString()))
                }
                if (shortVolumeRatioGte != null) {
                    put("short_volume_ratio.gte", listOf(shortVolumeRatioGte.toString()))
                }
                if (shortVolumeRatioLt != null) {
                    put("short_volume_ratio.lt", listOf(shortVolumeRatioLt.toString()))
                }
                if (shortVolumeRatioLte != null) {
                    put("short_volume_ratio.lte", listOf(shortVolumeRatioLte.toString()))
                }
                if (totalVolume != null) {
                    put("total_volume", listOf(totalVolume.toString()))
                }
                if (totalVolumeAnyOf != null) {
                    put("total_volume.any_of", listOf(totalVolumeAnyOf.toString()))
                }
                if (totalVolumeGt != null) {
                    put("total_volume.gt", listOf(totalVolumeGt.toString()))
                }
                if (totalVolumeGte != null) {
                    put("total_volume.gte", listOf(totalVolumeGte.toString()))
                }
                if (totalVolumeLt != null) {
                    put("total_volume.lt", listOf(totalVolumeLt.toString()))
                }
                if (totalVolumeLte != null) {
                    put("total_volume.lte", listOf(totalVolumeLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stocks/v1/short-volume",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v3/reference/tickers/{ticker}
     * Ticker Details v3
     * Get a single ticker supported by Polygon.io. This response will have detailed information about the ticker and the company behind it.
     * @param ticker The ticker symbol of the asset.
     * @param date Specify a point in time to get information about the ticker available on that date. When retrieving information from SEC filings, we compare this date with the period of report date on the SEC filing.  For example, consider an SEC filing submitted by AAPL on 2019-07-31, with a period of report date ending on 2019-06-29. That means that the filing was submitted on 2019-07-31, but the filing was created based on information from 2019-06-29. If you were to query for AAPL details on 2019-06-29, the ticker details would include information from the SEC filing.  Defaults to the most recent available date. (optional)
     * @return GetTicker200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getTicker(ticker: kotlin.String, date: java.time.LocalDate? = null) : GetTicker200Response {
        val localVarResponse = getTickerWithHttpInfo(ticker = ticker, date = date)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetTicker200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v3/reference/tickers/{ticker}
     * Ticker Details v3
     * Get a single ticker supported by Polygon.io. This response will have detailed information about the ticker and the company behind it.
     * @param ticker The ticker symbol of the asset.
     * @param date Specify a point in time to get information about the ticker available on that date. When retrieving information from SEC filings, we compare this date with the period of report date on the SEC filing.  For example, consider an SEC filing submitted by AAPL on 2019-07-31, with a period of report date ending on 2019-06-29. That means that the filing was submitted on 2019-07-31, but the filing was created based on information from 2019-06-29. If you were to query for AAPL details on 2019-06-29, the ticker details would include information from the SEC filing.  Defaults to the most recent available date. (optional)
     * @return ApiResponse<GetTicker200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getTickerWithHttpInfo(ticker: kotlin.String, date: java.time.LocalDate?) : ApiResponse<GetTicker200Response?> {
        val localVariableConfig = getTickerRequestConfig(ticker = ticker, date = date)

        return request<Unit, GetTicker200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getTicker
     *
     * @param ticker The ticker symbol of the asset.
     * @param date Specify a point in time to get information about the ticker available on that date. When retrieving information from SEC filings, we compare this date with the period of report date on the SEC filing.  For example, consider an SEC filing submitted by AAPL on 2019-07-31, with a period of report date ending on 2019-06-29. That means that the filing was submitted on 2019-07-31, but the filing was created based on information from 2019-06-29. If you were to query for AAPL details on 2019-06-29, the ticker details would include information from the SEC filing.  Defaults to the most recent available date. (optional)
     * @return RequestConfig
     */
    fun getTickerRequestConfig(ticker: kotlin.String, date: java.time.LocalDate?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (date != null) {
                    put("date", listOf(parseDateToQueryString(date)))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v3/reference/tickers/{ticker}".replace("{"+"ticker"+"}", encodeURIComponent(ticker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /tmx/v1/corporate-events
     * 
     * 
     * @param date Scheduled date of the corporate event, formatted as YYYY-MM-DD. (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param type The normalized type of corporate event. Possible values include: analyst_day, business_update, capital_markets_day, conference, dividend, earnings_announcement_date, earnings_conference_call, earnings_results_announcement, forum, interim_statement, other_interim_announcement, production_update, research_and_development_day, seminar, shareholder_meeting, sales_update, stock_split, summit, service_level_update, tradeshow, company_travel, and workshop. (optional)
     * @param typeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param typeGt Filter greater than the value. (optional)
     * @param typeGte Filter greater than or equal to the value. (optional)
     * @param typeLt Filter less than the value. (optional)
     * @param typeLte Filter less than or equal to the value. (optional)
     * @param status The current status of the event. Possible values include: approved, canceled, confirmed, historical, pending_approval, postponed, and unconfirmed. (optional)
     * @param statusAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param statusGt Filter greater than the value. (optional)
     * @param statusGte Filter greater than or equal to the value. (optional)
     * @param statusLt Filter less than the value. (optional)
     * @param statusLte Filter less than or equal to the value. (optional)
     * @param ticker The company&#39;s stock symbol. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param isin Standard international identifier for the company&#39;s common stock. (optional)
     * @param isinAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param isinGt Filter greater than the value. (optional)
     * @param isinGte Filter greater than or equal to the value. (optional)
     * @param isinLt Filter less than the value. (optional)
     * @param isinLte Filter less than or equal to the value. (optional)
     * @param tradingVenue MIC (Market Identifier Code) of the exchange where the company&#39;s stock is listed. (optional)
     * @param tradingVenueAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tradingVenueGt Filter greater than the value. (optional)
     * @param tradingVenueGte Filter greater than or equal to the value. (optional)
     * @param tradingVenueLt Filter less than the value. (optional)
     * @param tradingVenueLte Filter less than or equal to the value. (optional)
     * @param tmxCompanyId Unique numeric identifier for the company used by TMX. Value must be an integer. (optional)
     * @param tmxCompanyIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param tmxCompanyIdGt Filter greater than the value. Value must be an integer. (optional)
     * @param tmxCompanyIdGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param tmxCompanyIdLt Filter less than the value. Value must be an integer. (optional)
     * @param tmxCompanyIdLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param tmxRecordId The unique alphanumeric identifier for the event record used by TMX. (optional)
     * @param tmxRecordIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tmxRecordIdGt Filter greater than the value. (optional)
     * @param tmxRecordIdGte Filter greater than or equal to the value. (optional)
     * @param tmxRecordIdLt Filter less than the value. (optional)
     * @param tmxRecordIdLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;date&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "date.desc")
     * @return GetTmxV1CorporateEvents200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getTmxV1CorporateEvents(date: kotlin.String? = null, dateAnyOf: kotlin.String? = null, dateGt: kotlin.String? = null, dateGte: kotlin.String? = null, dateLt: kotlin.String? = null, dateLte: kotlin.String? = null, type: kotlin.String? = null, typeAnyOf: kotlin.String? = null, typeGt: kotlin.String? = null, typeGte: kotlin.String? = null, typeLt: kotlin.String? = null, typeLte: kotlin.String? = null, status: kotlin.String? = null, statusAnyOf: kotlin.String? = null, statusGt: kotlin.String? = null, statusGte: kotlin.String? = null, statusLt: kotlin.String? = null, statusLte: kotlin.String? = null, ticker: kotlin.String? = null, tickerAnyOf: kotlin.String? = null, tickerGt: kotlin.String? = null, tickerGte: kotlin.String? = null, tickerLt: kotlin.String? = null, tickerLte: kotlin.String? = null, isin: kotlin.String? = null, isinAnyOf: kotlin.String? = null, isinGt: kotlin.String? = null, isinGte: kotlin.String? = null, isinLt: kotlin.String? = null, isinLte: kotlin.String? = null, tradingVenue: kotlin.String? = null, tradingVenueAnyOf: kotlin.String? = null, tradingVenueGt: kotlin.String? = null, tradingVenueGte: kotlin.String? = null, tradingVenueLt: kotlin.String? = null, tradingVenueLte: kotlin.String? = null, tmxCompanyId: kotlin.Long? = null, tmxCompanyIdAnyOf: kotlin.String? = null, tmxCompanyIdGt: kotlin.Long? = null, tmxCompanyIdGte: kotlin.Long? = null, tmxCompanyIdLt: kotlin.Long? = null, tmxCompanyIdLte: kotlin.Long? = null, tmxRecordId: kotlin.String? = null, tmxRecordIdAnyOf: kotlin.String? = null, tmxRecordIdGt: kotlin.String? = null, tmxRecordIdGte: kotlin.String? = null, tmxRecordIdLt: kotlin.String? = null, tmxRecordIdLte: kotlin.String? = null, limit: kotlin.Int? = 100, sort: kotlin.String? = "date.desc") : GetTmxV1CorporateEvents200Response {
        val localVarResponse = getTmxV1CorporateEventsWithHttpInfo(date = date, dateAnyOf = dateAnyOf, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, type = type, typeAnyOf = typeAnyOf, typeGt = typeGt, typeGte = typeGte, typeLt = typeLt, typeLte = typeLte, status = status, statusAnyOf = statusAnyOf, statusGt = statusGt, statusGte = statusGte, statusLt = statusLt, statusLte = statusLte, ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, isin = isin, isinAnyOf = isinAnyOf, isinGt = isinGt, isinGte = isinGte, isinLt = isinLt, isinLte = isinLte, tradingVenue = tradingVenue, tradingVenueAnyOf = tradingVenueAnyOf, tradingVenueGt = tradingVenueGt, tradingVenueGte = tradingVenueGte, tradingVenueLt = tradingVenueLt, tradingVenueLte = tradingVenueLte, tmxCompanyId = tmxCompanyId, tmxCompanyIdAnyOf = tmxCompanyIdAnyOf, tmxCompanyIdGt = tmxCompanyIdGt, tmxCompanyIdGte = tmxCompanyIdGte, tmxCompanyIdLt = tmxCompanyIdLt, tmxCompanyIdLte = tmxCompanyIdLte, tmxRecordId = tmxRecordId, tmxRecordIdAnyOf = tmxRecordIdAnyOf, tmxRecordIdGt = tmxRecordIdGt, tmxRecordIdGte = tmxRecordIdGte, tmxRecordIdLt = tmxRecordIdLt, tmxRecordIdLte = tmxRecordIdLte, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetTmxV1CorporateEvents200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /tmx/v1/corporate-events
     * 
     * 
     * @param date Scheduled date of the corporate event, formatted as YYYY-MM-DD. (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param type The normalized type of corporate event. Possible values include: analyst_day, business_update, capital_markets_day, conference, dividend, earnings_announcement_date, earnings_conference_call, earnings_results_announcement, forum, interim_statement, other_interim_announcement, production_update, research_and_development_day, seminar, shareholder_meeting, sales_update, stock_split, summit, service_level_update, tradeshow, company_travel, and workshop. (optional)
     * @param typeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param typeGt Filter greater than the value. (optional)
     * @param typeGte Filter greater than or equal to the value. (optional)
     * @param typeLt Filter less than the value. (optional)
     * @param typeLte Filter less than or equal to the value. (optional)
     * @param status The current status of the event. Possible values include: approved, canceled, confirmed, historical, pending_approval, postponed, and unconfirmed. (optional)
     * @param statusAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param statusGt Filter greater than the value. (optional)
     * @param statusGte Filter greater than or equal to the value. (optional)
     * @param statusLt Filter less than the value. (optional)
     * @param statusLte Filter less than or equal to the value. (optional)
     * @param ticker The company&#39;s stock symbol. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param isin Standard international identifier for the company&#39;s common stock. (optional)
     * @param isinAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param isinGt Filter greater than the value. (optional)
     * @param isinGte Filter greater than or equal to the value. (optional)
     * @param isinLt Filter less than the value. (optional)
     * @param isinLte Filter less than or equal to the value. (optional)
     * @param tradingVenue MIC (Market Identifier Code) of the exchange where the company&#39;s stock is listed. (optional)
     * @param tradingVenueAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tradingVenueGt Filter greater than the value. (optional)
     * @param tradingVenueGte Filter greater than or equal to the value. (optional)
     * @param tradingVenueLt Filter less than the value. (optional)
     * @param tradingVenueLte Filter less than or equal to the value. (optional)
     * @param tmxCompanyId Unique numeric identifier for the company used by TMX. Value must be an integer. (optional)
     * @param tmxCompanyIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param tmxCompanyIdGt Filter greater than the value. Value must be an integer. (optional)
     * @param tmxCompanyIdGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param tmxCompanyIdLt Filter less than the value. Value must be an integer. (optional)
     * @param tmxCompanyIdLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param tmxRecordId The unique alphanumeric identifier for the event record used by TMX. (optional)
     * @param tmxRecordIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tmxRecordIdGt Filter greater than the value. (optional)
     * @param tmxRecordIdGte Filter greater than or equal to the value. (optional)
     * @param tmxRecordIdLt Filter less than the value. (optional)
     * @param tmxRecordIdLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;date&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "date.desc")
     * @return ApiResponse<GetTmxV1CorporateEvents200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getTmxV1CorporateEventsWithHttpInfo(date: kotlin.String?, dateAnyOf: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, type: kotlin.String?, typeAnyOf: kotlin.String?, typeGt: kotlin.String?, typeGte: kotlin.String?, typeLt: kotlin.String?, typeLte: kotlin.String?, status: kotlin.String?, statusAnyOf: kotlin.String?, statusGt: kotlin.String?, statusGte: kotlin.String?, statusLt: kotlin.String?, statusLte: kotlin.String?, ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, isin: kotlin.String?, isinAnyOf: kotlin.String?, isinGt: kotlin.String?, isinGte: kotlin.String?, isinLt: kotlin.String?, isinLte: kotlin.String?, tradingVenue: kotlin.String?, tradingVenueAnyOf: kotlin.String?, tradingVenueGt: kotlin.String?, tradingVenueGte: kotlin.String?, tradingVenueLt: kotlin.String?, tradingVenueLte: kotlin.String?, tmxCompanyId: kotlin.Long?, tmxCompanyIdAnyOf: kotlin.String?, tmxCompanyIdGt: kotlin.Long?, tmxCompanyIdGte: kotlin.Long?, tmxCompanyIdLt: kotlin.Long?, tmxCompanyIdLte: kotlin.Long?, tmxRecordId: kotlin.String?, tmxRecordIdAnyOf: kotlin.String?, tmxRecordIdGt: kotlin.String?, tmxRecordIdGte: kotlin.String?, tmxRecordIdLt: kotlin.String?, tmxRecordIdLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetTmxV1CorporateEvents200Response?> {
        val localVariableConfig = getTmxV1CorporateEventsRequestConfig(date = date, dateAnyOf = dateAnyOf, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, type = type, typeAnyOf = typeAnyOf, typeGt = typeGt, typeGte = typeGte, typeLt = typeLt, typeLte = typeLte, status = status, statusAnyOf = statusAnyOf, statusGt = statusGt, statusGte = statusGte, statusLt = statusLt, statusLte = statusLte, ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, isin = isin, isinAnyOf = isinAnyOf, isinGt = isinGt, isinGte = isinGte, isinLt = isinLt, isinLte = isinLte, tradingVenue = tradingVenue, tradingVenueAnyOf = tradingVenueAnyOf, tradingVenueGt = tradingVenueGt, tradingVenueGte = tradingVenueGte, tradingVenueLt = tradingVenueLt, tradingVenueLte = tradingVenueLte, tmxCompanyId = tmxCompanyId, tmxCompanyIdAnyOf = tmxCompanyIdAnyOf, tmxCompanyIdGt = tmxCompanyIdGt, tmxCompanyIdGte = tmxCompanyIdGte, tmxCompanyIdLt = tmxCompanyIdLt, tmxCompanyIdLte = tmxCompanyIdLte, tmxRecordId = tmxRecordId, tmxRecordIdAnyOf = tmxRecordIdAnyOf, tmxRecordIdGt = tmxRecordIdGt, tmxRecordIdGte = tmxRecordIdGte, tmxRecordIdLt = tmxRecordIdLt, tmxRecordIdLte = tmxRecordIdLte, limit = limit, sort = sort)

        return request<Unit, GetTmxV1CorporateEvents200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getTmxV1CorporateEvents
     *
     * @param date Scheduled date of the corporate event, formatted as YYYY-MM-DD. (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param type The normalized type of corporate event. Possible values include: analyst_day, business_update, capital_markets_day, conference, dividend, earnings_announcement_date, earnings_conference_call, earnings_results_announcement, forum, interim_statement, other_interim_announcement, production_update, research_and_development_day, seminar, shareholder_meeting, sales_update, stock_split, summit, service_level_update, tradeshow, company_travel, and workshop. (optional)
     * @param typeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param typeGt Filter greater than the value. (optional)
     * @param typeGte Filter greater than or equal to the value. (optional)
     * @param typeLt Filter less than the value. (optional)
     * @param typeLte Filter less than or equal to the value. (optional)
     * @param status The current status of the event. Possible values include: approved, canceled, confirmed, historical, pending_approval, postponed, and unconfirmed. (optional)
     * @param statusAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param statusGt Filter greater than the value. (optional)
     * @param statusGte Filter greater than or equal to the value. (optional)
     * @param statusLt Filter less than the value. (optional)
     * @param statusLte Filter less than or equal to the value. (optional)
     * @param ticker The company&#39;s stock symbol. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param isin Standard international identifier for the company&#39;s common stock. (optional)
     * @param isinAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param isinGt Filter greater than the value. (optional)
     * @param isinGte Filter greater than or equal to the value. (optional)
     * @param isinLt Filter less than the value. (optional)
     * @param isinLte Filter less than or equal to the value. (optional)
     * @param tradingVenue MIC (Market Identifier Code) of the exchange where the company&#39;s stock is listed. (optional)
     * @param tradingVenueAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tradingVenueGt Filter greater than the value. (optional)
     * @param tradingVenueGte Filter greater than or equal to the value. (optional)
     * @param tradingVenueLt Filter less than the value. (optional)
     * @param tradingVenueLte Filter less than or equal to the value. (optional)
     * @param tmxCompanyId Unique numeric identifier for the company used by TMX. Value must be an integer. (optional)
     * @param tmxCompanyIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param tmxCompanyIdGt Filter greater than the value. Value must be an integer. (optional)
     * @param tmxCompanyIdGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param tmxCompanyIdLt Filter less than the value. Value must be an integer. (optional)
     * @param tmxCompanyIdLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param tmxRecordId The unique alphanumeric identifier for the event record used by TMX. (optional)
     * @param tmxRecordIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tmxRecordIdGt Filter greater than the value. (optional)
     * @param tmxRecordIdGte Filter greater than or equal to the value. (optional)
     * @param tmxRecordIdLt Filter less than the value. (optional)
     * @param tmxRecordIdLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;date&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "date.desc")
     * @return RequestConfig
     */
    fun getTmxV1CorporateEventsRequestConfig(date: kotlin.String?, dateAnyOf: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, type: kotlin.String?, typeAnyOf: kotlin.String?, typeGt: kotlin.String?, typeGte: kotlin.String?, typeLt: kotlin.String?, typeLte: kotlin.String?, status: kotlin.String?, statusAnyOf: kotlin.String?, statusGt: kotlin.String?, statusGte: kotlin.String?, statusLt: kotlin.String?, statusLte: kotlin.String?, ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, isin: kotlin.String?, isinAnyOf: kotlin.String?, isinGt: kotlin.String?, isinGte: kotlin.String?, isinLt: kotlin.String?, isinLte: kotlin.String?, tradingVenue: kotlin.String?, tradingVenueAnyOf: kotlin.String?, tradingVenueGt: kotlin.String?, tradingVenueGte: kotlin.String?, tradingVenueLt: kotlin.String?, tradingVenueLte: kotlin.String?, tmxCompanyId: kotlin.Long?, tmxCompanyIdAnyOf: kotlin.String?, tmxCompanyIdGt: kotlin.Long?, tmxCompanyIdGte: kotlin.Long?, tmxCompanyIdLt: kotlin.Long?, tmxCompanyIdLte: kotlin.Long?, tmxRecordId: kotlin.String?, tmxRecordIdAnyOf: kotlin.String?, tmxRecordIdGt: kotlin.String?, tmxRecordIdGte: kotlin.String?, tmxRecordIdLt: kotlin.String?, tmxRecordIdLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (date != null) {
                    put("date", listOf(date.toString()))
                }
                if (dateAnyOf != null) {
                    put("date.any_of", listOf(dateAnyOf.toString()))
                }
                if (dateGt != null) {
                    put("date.gt", listOf(dateGt.toString()))
                }
                if (dateGte != null) {
                    put("date.gte", listOf(dateGte.toString()))
                }
                if (dateLt != null) {
                    put("date.lt", listOf(dateLt.toString()))
                }
                if (dateLte != null) {
                    put("date.lte", listOf(dateLte.toString()))
                }
                if (type != null) {
                    put("type", listOf(type.toString()))
                }
                if (typeAnyOf != null) {
                    put("type.any_of", listOf(typeAnyOf.toString()))
                }
                if (typeGt != null) {
                    put("type.gt", listOf(typeGt.toString()))
                }
                if (typeGte != null) {
                    put("type.gte", listOf(typeGte.toString()))
                }
                if (typeLt != null) {
                    put("type.lt", listOf(typeLt.toString()))
                }
                if (typeLte != null) {
                    put("type.lte", listOf(typeLte.toString()))
                }
                if (status != null) {
                    put("status", listOf(status.toString()))
                }
                if (statusAnyOf != null) {
                    put("status.any_of", listOf(statusAnyOf.toString()))
                }
                if (statusGt != null) {
                    put("status.gt", listOf(statusGt.toString()))
                }
                if (statusGte != null) {
                    put("status.gte", listOf(statusGte.toString()))
                }
                if (statusLt != null) {
                    put("status.lt", listOf(statusLt.toString()))
                }
                if (statusLte != null) {
                    put("status.lte", listOf(statusLte.toString()))
                }
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
                if (tickerAnyOf != null) {
                    put("ticker.any_of", listOf(tickerAnyOf.toString()))
                }
                if (tickerGt != null) {
                    put("ticker.gt", listOf(tickerGt.toString()))
                }
                if (tickerGte != null) {
                    put("ticker.gte", listOf(tickerGte.toString()))
                }
                if (tickerLt != null) {
                    put("ticker.lt", listOf(tickerLt.toString()))
                }
                if (tickerLte != null) {
                    put("ticker.lte", listOf(tickerLte.toString()))
                }
                if (isin != null) {
                    put("isin", listOf(isin.toString()))
                }
                if (isinAnyOf != null) {
                    put("isin.any_of", listOf(isinAnyOf.toString()))
                }
                if (isinGt != null) {
                    put("isin.gt", listOf(isinGt.toString()))
                }
                if (isinGte != null) {
                    put("isin.gte", listOf(isinGte.toString()))
                }
                if (isinLt != null) {
                    put("isin.lt", listOf(isinLt.toString()))
                }
                if (isinLte != null) {
                    put("isin.lte", listOf(isinLte.toString()))
                }
                if (tradingVenue != null) {
                    put("trading_venue", listOf(tradingVenue.toString()))
                }
                if (tradingVenueAnyOf != null) {
                    put("trading_venue.any_of", listOf(tradingVenueAnyOf.toString()))
                }
                if (tradingVenueGt != null) {
                    put("trading_venue.gt", listOf(tradingVenueGt.toString()))
                }
                if (tradingVenueGte != null) {
                    put("trading_venue.gte", listOf(tradingVenueGte.toString()))
                }
                if (tradingVenueLt != null) {
                    put("trading_venue.lt", listOf(tradingVenueLt.toString()))
                }
                if (tradingVenueLte != null) {
                    put("trading_venue.lte", listOf(tradingVenueLte.toString()))
                }
                if (tmxCompanyId != null) {
                    put("tmx_company_id", listOf(tmxCompanyId.toString()))
                }
                if (tmxCompanyIdAnyOf != null) {
                    put("tmx_company_id.any_of", listOf(tmxCompanyIdAnyOf.toString()))
                }
                if (tmxCompanyIdGt != null) {
                    put("tmx_company_id.gt", listOf(tmxCompanyIdGt.toString()))
                }
                if (tmxCompanyIdGte != null) {
                    put("tmx_company_id.gte", listOf(tmxCompanyIdGte.toString()))
                }
                if (tmxCompanyIdLt != null) {
                    put("tmx_company_id.lt", listOf(tmxCompanyIdLt.toString()))
                }
                if (tmxCompanyIdLte != null) {
                    put("tmx_company_id.lte", listOf(tmxCompanyIdLte.toString()))
                }
                if (tmxRecordId != null) {
                    put("tmx_record_id", listOf(tmxRecordId.toString()))
                }
                if (tmxRecordIdAnyOf != null) {
                    put("tmx_record_id.any_of", listOf(tmxRecordIdAnyOf.toString()))
                }
                if (tmxRecordIdGt != null) {
                    put("tmx_record_id.gt", listOf(tmxRecordIdGt.toString()))
                }
                if (tmxRecordIdGte != null) {
                    put("tmx_record_id.gte", listOf(tmxRecordIdGte.toString()))
                }
                if (tmxRecordIdLt != null) {
                    put("tmx_record_id.lt", listOf(tmxRecordIdLt.toString()))
                }
                if (tmxRecordIdLte != null) {
                    put("tmx_record_id.lte", listOf(tmxRecordIdLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/tmx/v1/corporate-events",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter assetClass
     */
     enum class AssetClassListConditions(val value: kotlin.String) {
         @Json(name = "stocks") stocks("stocks"),
         @Json(name = "options") options("options"),
         @Json(name = "crypto") crypto("crypto"),
         @Json(name = "fx") fx("fx");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter dataType
     */
     enum class DataTypeListConditions(val value: kotlin.String) {
         @Json(name = "trade") trade("trade"),
         @Json(name = "bbo") bbo("bbo"),
         @Json(name = "nbbo") nbbo("nbbo");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sip
     */
     enum class SipListConditions(val value: kotlin.String) {
         @Json(name = "CTA") cTA("CTA"),
         @Json(name = "UTP") uTP("UTP"),
         @Json(name = "OPRA") oPRA("OPRA");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderListConditions(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortListConditions(val value: kotlin.String) {
         @Json(name = "asset_class") assetClass("asset_class"),
         @Json(name = "id") id("id"),
         @Json(name = "type") type("type"),
         @Json(name = "name") nameEnum("name"),
         @Json(name = "data_types") dataTypes("data_types"),
         @Json(name = "legacy") legacy("legacy");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v3/reference/conditions
     * Conditions
     * List all conditions that Polygon.io uses.
     * @param assetClass Filter for conditions within a given asset class. (optional)
     * @param dataType Filter by data type. (optional)
     * @param id Filter for conditions with a given ID. (optional)
     * @param sip Filter by SIP. If the condition contains a mapping for that SIP, the condition will be returned. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 1000. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to asset_class)
     * @return ListConditions200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listConditions(assetClass: AssetClassListConditions? = null, dataType: DataTypeListConditions? = null, id: kotlin.Int? = null, sip: SipListConditions? = null, order: OrderListConditions? = null, limit: kotlin.Int? = 10, sort: SortListConditions? = SortListConditions.assetClass) : ListConditions200Response {
        val localVarResponse = listConditionsWithHttpInfo(assetClass = assetClass, dataType = dataType, id = id, sip = sip, order = order, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListConditions200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v3/reference/conditions
     * Conditions
     * List all conditions that Polygon.io uses.
     * @param assetClass Filter for conditions within a given asset class. (optional)
     * @param dataType Filter by data type. (optional)
     * @param id Filter for conditions with a given ID. (optional)
     * @param sip Filter by SIP. If the condition contains a mapping for that SIP, the condition will be returned. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 1000. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to asset_class)
     * @return ApiResponse<ListConditions200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listConditionsWithHttpInfo(assetClass: AssetClassListConditions?, dataType: DataTypeListConditions?, id: kotlin.Int?, sip: SipListConditions?, order: OrderListConditions?, limit: kotlin.Int?, sort: SortListConditions?) : ApiResponse<ListConditions200Response?> {
        val localVariableConfig = listConditionsRequestConfig(assetClass = assetClass, dataType = dataType, id = id, sip = sip, order = order, limit = limit, sort = sort)

        return request<Unit, ListConditions200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listConditions
     *
     * @param assetClass Filter for conditions within a given asset class. (optional)
     * @param dataType Filter by data type. (optional)
     * @param id Filter for conditions with a given ID. (optional)
     * @param sip Filter by SIP. If the condition contains a mapping for that SIP, the condition will be returned. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 1000. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to asset_class)
     * @return RequestConfig
     */
    fun listConditionsRequestConfig(assetClass: AssetClassListConditions?, dataType: DataTypeListConditions?, id: kotlin.Int?, sip: SipListConditions?, order: OrderListConditions?, limit: kotlin.Int?, sort: SortListConditions?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (assetClass != null) {
                    put("asset_class", listOf(assetClass.value))
                }
                if (dataType != null) {
                    put("data_type", listOf(dataType.value))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (sip != null) {
                    put("sip", listOf(sip.value))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v3/reference/conditions",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter frequency
     */
     enum class FrequencyListDividends(val value: kotlin.Int) {
         @Json(name = "0") _0(0),
         @Json(name = "1") _1(1),
         @Json(name = "2") _2(2),
         @Json(name = "4") _4(4),
         @Json(name = "12") _12(12),
         @Json(name = "24") _24(24),
         @Json(name = "52") _52(52);

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter dividendType
     */
     enum class DividendTypeListDividends(val value: kotlin.String) {
         @Json(name = "CD") cD("CD"),
         @Json(name = "SC") sC("SC"),
         @Json(name = "LT") lT("LT"),
         @Json(name = "ST") sT("ST");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderListDividends(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortListDividends(val value: kotlin.String) {
         @Json(name = "ex_dividend_date") exDividendDate("ex_dividend_date"),
         @Json(name = "pay_date") payDate("pay_date"),
         @Json(name = "declaration_date") declarationDate("declaration_date"),
         @Json(name = "record_date") recordDate("record_date"),
         @Json(name = "cash_amount") cashAmount("cash_amount"),
         @Json(name = "ticker") ticker("ticker");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v3/reference/dividends
     * Dividends v3
     * Get a list of historical cash dividends, including the ticker symbol, declaration date, ex-dividend date, record date, pay date, frequency, and amount.
     * @param ticker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc. (optional)
     * @param exDividendDate Query by ex-dividend date with the format YYYY-MM-DD. (optional)
     * @param recordDate Query by record date with the format YYYY-MM-DD. (optional)
     * @param declarationDate Query by declaration date with the format YYYY-MM-DD. (optional)
     * @param payDate Query by pay date with the format YYYY-MM-DD. (optional)
     * @param frequency Query by the number of times per year the dividend is paid out.  Possible values are 0 (one-time), 1 (annually), 2 (bi-annually), 4 (quarterly), 12 (monthly), 24 (bi-monthly), and 52 (weekly). (optional)
     * @param cashAmount Query by the cash amount of the dividend. (optional)
     * @param dividendType Query by the type of dividend. Dividends that have been paid and/or are expected to be paid on consistent schedules are denoted as CD. Special Cash dividends that have been paid that are infrequent or unusual, and/or can not be expected to occur in the future are denoted as SC. (optional)
     * @param tickerGte Range by ticker. (optional)
     * @param tickerGt Range by ticker. (optional)
     * @param tickerLte Range by ticker. (optional)
     * @param tickerLt Range by ticker. (optional)
     * @param exDividendDateGte Range by ex_dividend_date. (optional)
     * @param exDividendDateGt Range by ex_dividend_date. (optional)
     * @param exDividendDateLte Range by ex_dividend_date. (optional)
     * @param exDividendDateLt Range by ex_dividend_date. (optional)
     * @param recordDateGte Range by record_date. (optional)
     * @param recordDateGt Range by record_date. (optional)
     * @param recordDateLte Range by record_date. (optional)
     * @param recordDateLt Range by record_date. (optional)
     * @param declarationDateGte Range by declaration_date. (optional)
     * @param declarationDateGt Range by declaration_date. (optional)
     * @param declarationDateLte Range by declaration_date. (optional)
     * @param declarationDateLt Range by declaration_date. (optional)
     * @param payDateGte Range by pay_date. (optional)
     * @param payDateGt Range by pay_date. (optional)
     * @param payDateLte Range by pay_date. (optional)
     * @param payDateLt Range by pay_date. (optional)
     * @param cashAmountGte Range by cash_amount. (optional)
     * @param cashAmountGt Range by cash_amount. (optional)
     * @param cashAmountLte Range by cash_amount. (optional)
     * @param cashAmountLt Range by cash_amount. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 1000. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to ex_dividend_date)
     * @return ListDividends200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listDividends(ticker: kotlin.String? = null, exDividendDate: java.time.LocalDate? = null, recordDate: java.time.LocalDate? = null, declarationDate: java.time.LocalDate? = null, payDate: java.time.LocalDate? = null, frequency: FrequencyListDividends? = null, cashAmount: java.math.BigDecimal? = null, dividendType: DividendTypeListDividends? = null, tickerGte: kotlin.String? = null, tickerGt: kotlin.String? = null, tickerLte: kotlin.String? = null, tickerLt: kotlin.String? = null, exDividendDateGte: java.time.LocalDate? = null, exDividendDateGt: java.time.LocalDate? = null, exDividendDateLte: java.time.LocalDate? = null, exDividendDateLt: java.time.LocalDate? = null, recordDateGte: java.time.LocalDate? = null, recordDateGt: java.time.LocalDate? = null, recordDateLte: java.time.LocalDate? = null, recordDateLt: java.time.LocalDate? = null, declarationDateGte: java.time.LocalDate? = null, declarationDateGt: java.time.LocalDate? = null, declarationDateLte: java.time.LocalDate? = null, declarationDateLt: java.time.LocalDate? = null, payDateGte: java.time.LocalDate? = null, payDateGt: java.time.LocalDate? = null, payDateLte: java.time.LocalDate? = null, payDateLt: java.time.LocalDate? = null, cashAmountGte: java.math.BigDecimal? = null, cashAmountGt: java.math.BigDecimal? = null, cashAmountLte: java.math.BigDecimal? = null, cashAmountLt: java.math.BigDecimal? = null, order: OrderListDividends? = null, limit: kotlin.Int? = 10, sort: SortListDividends? = SortListDividends.exDividendDate) : ListDividends200Response {
        val localVarResponse = listDividendsWithHttpInfo(ticker = ticker, exDividendDate = exDividendDate, recordDate = recordDate, declarationDate = declarationDate, payDate = payDate, frequency = frequency, cashAmount = cashAmount, dividendType = dividendType, tickerGte = tickerGte, tickerGt = tickerGt, tickerLte = tickerLte, tickerLt = tickerLt, exDividendDateGte = exDividendDateGte, exDividendDateGt = exDividendDateGt, exDividendDateLte = exDividendDateLte, exDividendDateLt = exDividendDateLt, recordDateGte = recordDateGte, recordDateGt = recordDateGt, recordDateLte = recordDateLte, recordDateLt = recordDateLt, declarationDateGte = declarationDateGte, declarationDateGt = declarationDateGt, declarationDateLte = declarationDateLte, declarationDateLt = declarationDateLt, payDateGte = payDateGte, payDateGt = payDateGt, payDateLte = payDateLte, payDateLt = payDateLt, cashAmountGte = cashAmountGte, cashAmountGt = cashAmountGt, cashAmountLte = cashAmountLte, cashAmountLt = cashAmountLt, order = order, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListDividends200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v3/reference/dividends
     * Dividends v3
     * Get a list of historical cash dividends, including the ticker symbol, declaration date, ex-dividend date, record date, pay date, frequency, and amount.
     * @param ticker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc. (optional)
     * @param exDividendDate Query by ex-dividend date with the format YYYY-MM-DD. (optional)
     * @param recordDate Query by record date with the format YYYY-MM-DD. (optional)
     * @param declarationDate Query by declaration date with the format YYYY-MM-DD. (optional)
     * @param payDate Query by pay date with the format YYYY-MM-DD. (optional)
     * @param frequency Query by the number of times per year the dividend is paid out.  Possible values are 0 (one-time), 1 (annually), 2 (bi-annually), 4 (quarterly), 12 (monthly), 24 (bi-monthly), and 52 (weekly). (optional)
     * @param cashAmount Query by the cash amount of the dividend. (optional)
     * @param dividendType Query by the type of dividend. Dividends that have been paid and/or are expected to be paid on consistent schedules are denoted as CD. Special Cash dividends that have been paid that are infrequent or unusual, and/or can not be expected to occur in the future are denoted as SC. (optional)
     * @param tickerGte Range by ticker. (optional)
     * @param tickerGt Range by ticker. (optional)
     * @param tickerLte Range by ticker. (optional)
     * @param tickerLt Range by ticker. (optional)
     * @param exDividendDateGte Range by ex_dividend_date. (optional)
     * @param exDividendDateGt Range by ex_dividend_date. (optional)
     * @param exDividendDateLte Range by ex_dividend_date. (optional)
     * @param exDividendDateLt Range by ex_dividend_date. (optional)
     * @param recordDateGte Range by record_date. (optional)
     * @param recordDateGt Range by record_date. (optional)
     * @param recordDateLte Range by record_date. (optional)
     * @param recordDateLt Range by record_date. (optional)
     * @param declarationDateGte Range by declaration_date. (optional)
     * @param declarationDateGt Range by declaration_date. (optional)
     * @param declarationDateLte Range by declaration_date. (optional)
     * @param declarationDateLt Range by declaration_date. (optional)
     * @param payDateGte Range by pay_date. (optional)
     * @param payDateGt Range by pay_date. (optional)
     * @param payDateLte Range by pay_date. (optional)
     * @param payDateLt Range by pay_date. (optional)
     * @param cashAmountGte Range by cash_amount. (optional)
     * @param cashAmountGt Range by cash_amount. (optional)
     * @param cashAmountLte Range by cash_amount. (optional)
     * @param cashAmountLt Range by cash_amount. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 1000. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to ex_dividend_date)
     * @return ApiResponse<ListDividends200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listDividendsWithHttpInfo(ticker: kotlin.String?, exDividendDate: java.time.LocalDate?, recordDate: java.time.LocalDate?, declarationDate: java.time.LocalDate?, payDate: java.time.LocalDate?, frequency: FrequencyListDividends?, cashAmount: java.math.BigDecimal?, dividendType: DividendTypeListDividends?, tickerGte: kotlin.String?, tickerGt: kotlin.String?, tickerLte: kotlin.String?, tickerLt: kotlin.String?, exDividendDateGte: java.time.LocalDate?, exDividendDateGt: java.time.LocalDate?, exDividendDateLte: java.time.LocalDate?, exDividendDateLt: java.time.LocalDate?, recordDateGte: java.time.LocalDate?, recordDateGt: java.time.LocalDate?, recordDateLte: java.time.LocalDate?, recordDateLt: java.time.LocalDate?, declarationDateGte: java.time.LocalDate?, declarationDateGt: java.time.LocalDate?, declarationDateLte: java.time.LocalDate?, declarationDateLt: java.time.LocalDate?, payDateGte: java.time.LocalDate?, payDateGt: java.time.LocalDate?, payDateLte: java.time.LocalDate?, payDateLt: java.time.LocalDate?, cashAmountGte: java.math.BigDecimal?, cashAmountGt: java.math.BigDecimal?, cashAmountLte: java.math.BigDecimal?, cashAmountLt: java.math.BigDecimal?, order: OrderListDividends?, limit: kotlin.Int?, sort: SortListDividends?) : ApiResponse<ListDividends200Response?> {
        val localVariableConfig = listDividendsRequestConfig(ticker = ticker, exDividendDate = exDividendDate, recordDate = recordDate, declarationDate = declarationDate, payDate = payDate, frequency = frequency, cashAmount = cashAmount, dividendType = dividendType, tickerGte = tickerGte, tickerGt = tickerGt, tickerLte = tickerLte, tickerLt = tickerLt, exDividendDateGte = exDividendDateGte, exDividendDateGt = exDividendDateGt, exDividendDateLte = exDividendDateLte, exDividendDateLt = exDividendDateLt, recordDateGte = recordDateGte, recordDateGt = recordDateGt, recordDateLte = recordDateLte, recordDateLt = recordDateLt, declarationDateGte = declarationDateGte, declarationDateGt = declarationDateGt, declarationDateLte = declarationDateLte, declarationDateLt = declarationDateLt, payDateGte = payDateGte, payDateGt = payDateGt, payDateLte = payDateLte, payDateLt = payDateLt, cashAmountGte = cashAmountGte, cashAmountGt = cashAmountGt, cashAmountLte = cashAmountLte, cashAmountLt = cashAmountLt, order = order, limit = limit, sort = sort)

        return request<Unit, ListDividends200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listDividends
     *
     * @param ticker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc. (optional)
     * @param exDividendDate Query by ex-dividend date with the format YYYY-MM-DD. (optional)
     * @param recordDate Query by record date with the format YYYY-MM-DD. (optional)
     * @param declarationDate Query by declaration date with the format YYYY-MM-DD. (optional)
     * @param payDate Query by pay date with the format YYYY-MM-DD. (optional)
     * @param frequency Query by the number of times per year the dividend is paid out.  Possible values are 0 (one-time), 1 (annually), 2 (bi-annually), 4 (quarterly), 12 (monthly), 24 (bi-monthly), and 52 (weekly). (optional)
     * @param cashAmount Query by the cash amount of the dividend. (optional)
     * @param dividendType Query by the type of dividend. Dividends that have been paid and/or are expected to be paid on consistent schedules are denoted as CD. Special Cash dividends that have been paid that are infrequent or unusual, and/or can not be expected to occur in the future are denoted as SC. (optional)
     * @param tickerGte Range by ticker. (optional)
     * @param tickerGt Range by ticker. (optional)
     * @param tickerLte Range by ticker. (optional)
     * @param tickerLt Range by ticker. (optional)
     * @param exDividendDateGte Range by ex_dividend_date. (optional)
     * @param exDividendDateGt Range by ex_dividend_date. (optional)
     * @param exDividendDateLte Range by ex_dividend_date. (optional)
     * @param exDividendDateLt Range by ex_dividend_date. (optional)
     * @param recordDateGte Range by record_date. (optional)
     * @param recordDateGt Range by record_date. (optional)
     * @param recordDateLte Range by record_date. (optional)
     * @param recordDateLt Range by record_date. (optional)
     * @param declarationDateGte Range by declaration_date. (optional)
     * @param declarationDateGt Range by declaration_date. (optional)
     * @param declarationDateLte Range by declaration_date. (optional)
     * @param declarationDateLt Range by declaration_date. (optional)
     * @param payDateGte Range by pay_date. (optional)
     * @param payDateGt Range by pay_date. (optional)
     * @param payDateLte Range by pay_date. (optional)
     * @param payDateLt Range by pay_date. (optional)
     * @param cashAmountGte Range by cash_amount. (optional)
     * @param cashAmountGt Range by cash_amount. (optional)
     * @param cashAmountLte Range by cash_amount. (optional)
     * @param cashAmountLt Range by cash_amount. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 1000. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to ex_dividend_date)
     * @return RequestConfig
     */
    fun listDividendsRequestConfig(ticker: kotlin.String?, exDividendDate: java.time.LocalDate?, recordDate: java.time.LocalDate?, declarationDate: java.time.LocalDate?, payDate: java.time.LocalDate?, frequency: FrequencyListDividends?, cashAmount: java.math.BigDecimal?, dividendType: DividendTypeListDividends?, tickerGte: kotlin.String?, tickerGt: kotlin.String?, tickerLte: kotlin.String?, tickerLt: kotlin.String?, exDividendDateGte: java.time.LocalDate?, exDividendDateGt: java.time.LocalDate?, exDividendDateLte: java.time.LocalDate?, exDividendDateLt: java.time.LocalDate?, recordDateGte: java.time.LocalDate?, recordDateGt: java.time.LocalDate?, recordDateLte: java.time.LocalDate?, recordDateLt: java.time.LocalDate?, declarationDateGte: java.time.LocalDate?, declarationDateGt: java.time.LocalDate?, declarationDateLte: java.time.LocalDate?, declarationDateLt: java.time.LocalDate?, payDateGte: java.time.LocalDate?, payDateGt: java.time.LocalDate?, payDateLte: java.time.LocalDate?, payDateLt: java.time.LocalDate?, cashAmountGte: java.math.BigDecimal?, cashAmountGt: java.math.BigDecimal?, cashAmountLte: java.math.BigDecimal?, cashAmountLt: java.math.BigDecimal?, order: OrderListDividends?, limit: kotlin.Int?, sort: SortListDividends?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
                if (exDividendDate != null) {
                    put("ex_dividend_date", listOf(parseDateToQueryString(exDividendDate)))
                }
                if (recordDate != null) {
                    put("record_date", listOf(parseDateToQueryString(recordDate)))
                }
                if (declarationDate != null) {
                    put("declaration_date", listOf(parseDateToQueryString(declarationDate)))
                }
                if (payDate != null) {
                    put("pay_date", listOf(parseDateToQueryString(payDate)))
                }
                if (frequency != null) {
                    put("frequency", listOf(frequency.toString()))
                }
                if (cashAmount != null) {
                    put("cash_amount", listOf(cashAmount.toString()))
                }
                if (dividendType != null) {
                    put("dividend_type", listOf(dividendType.value))
                }
                if (tickerGte != null) {
                    put("ticker.gte", listOf(tickerGte.toString()))
                }
                if (tickerGt != null) {
                    put("ticker.gt", listOf(tickerGt.toString()))
                }
                if (tickerLte != null) {
                    put("ticker.lte", listOf(tickerLte.toString()))
                }
                if (tickerLt != null) {
                    put("ticker.lt", listOf(tickerLt.toString()))
                }
                if (exDividendDateGte != null) {
                    put("ex_dividend_date.gte", listOf(parseDateToQueryString(exDividendDateGte)))
                }
                if (exDividendDateGt != null) {
                    put("ex_dividend_date.gt", listOf(parseDateToQueryString(exDividendDateGt)))
                }
                if (exDividendDateLte != null) {
                    put("ex_dividend_date.lte", listOf(parseDateToQueryString(exDividendDateLte)))
                }
                if (exDividendDateLt != null) {
                    put("ex_dividend_date.lt", listOf(parseDateToQueryString(exDividendDateLt)))
                }
                if (recordDateGte != null) {
                    put("record_date.gte", listOf(parseDateToQueryString(recordDateGte)))
                }
                if (recordDateGt != null) {
                    put("record_date.gt", listOf(parseDateToQueryString(recordDateGt)))
                }
                if (recordDateLte != null) {
                    put("record_date.lte", listOf(parseDateToQueryString(recordDateLte)))
                }
                if (recordDateLt != null) {
                    put("record_date.lt", listOf(parseDateToQueryString(recordDateLt)))
                }
                if (declarationDateGte != null) {
                    put("declaration_date.gte", listOf(parseDateToQueryString(declarationDateGte)))
                }
                if (declarationDateGt != null) {
                    put("declaration_date.gt", listOf(parseDateToQueryString(declarationDateGt)))
                }
                if (declarationDateLte != null) {
                    put("declaration_date.lte", listOf(parseDateToQueryString(declarationDateLte)))
                }
                if (declarationDateLt != null) {
                    put("declaration_date.lt", listOf(parseDateToQueryString(declarationDateLt)))
                }
                if (payDateGte != null) {
                    put("pay_date.gte", listOf(parseDateToQueryString(payDateGte)))
                }
                if (payDateGt != null) {
                    put("pay_date.gt", listOf(parseDateToQueryString(payDateGt)))
                }
                if (payDateLte != null) {
                    put("pay_date.lte", listOf(parseDateToQueryString(payDateLte)))
                }
                if (payDateLt != null) {
                    put("pay_date.lt", listOf(parseDateToQueryString(payDateLt)))
                }
                if (cashAmountGte != null) {
                    put("cash_amount.gte", listOf(cashAmountGte.toString()))
                }
                if (cashAmountGt != null) {
                    put("cash_amount.gt", listOf(cashAmountGt.toString()))
                }
                if (cashAmountLte != null) {
                    put("cash_amount.lte", listOf(cashAmountLte.toString()))
                }
                if (cashAmountLt != null) {
                    put("cash_amount.lt", listOf(cashAmountLt.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v3/reference/dividends",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter assetClass
     */
     enum class AssetClassListExchanges(val value: kotlin.String) {
         @Json(name = "stocks") stocks("stocks"),
         @Json(name = "options") options("options"),
         @Json(name = "crypto") crypto("crypto"),
         @Json(name = "fx") fx("fx");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter locale
     */
     enum class LocaleListExchanges(val value: kotlin.String) {
         @Json(name = "us") us("us"),
         @Json(name = "global") global("global");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v3/reference/exchanges
     * Exchanges
     * List all exchanges that Polygon.io knows about.
     * @param assetClass Filter by asset class. (optional)
     * @param locale Filter by locale. (optional)
     * @return ListExchanges200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listExchanges(assetClass: AssetClassListExchanges? = null, locale: LocaleListExchanges? = null) : ListExchanges200Response {
        val localVarResponse = listExchangesWithHttpInfo(assetClass = assetClass, locale = locale)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListExchanges200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v3/reference/exchanges
     * Exchanges
     * List all exchanges that Polygon.io knows about.
     * @param assetClass Filter by asset class. (optional)
     * @param locale Filter by locale. (optional)
     * @return ApiResponse<ListExchanges200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listExchangesWithHttpInfo(assetClass: AssetClassListExchanges?, locale: LocaleListExchanges?) : ApiResponse<ListExchanges200Response?> {
        val localVariableConfig = listExchangesRequestConfig(assetClass = assetClass, locale = locale)

        return request<Unit, ListExchanges200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listExchanges
     *
     * @param assetClass Filter by asset class. (optional)
     * @param locale Filter by locale. (optional)
     * @return RequestConfig
     */
    fun listExchangesRequestConfig(assetClass: AssetClassListExchanges?, locale: LocaleListExchanges?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (assetClass != null) {
                    put("asset_class", listOf(assetClass.value))
                }
                if (locale != null) {
                    put("locale", listOf(locale.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v3/reference/exchanges",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter timeframe
     */
     enum class TimeframeListFinancials(val value: kotlin.String) {
         @Json(name = "annual") annual("annual"),
         @Json(name = "quarterly") quarterly("quarterly"),
         @Json(name = "ttm") ttm("ttm");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderListFinancials(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortListFinancials(val value: kotlin.String) {
         @Json(name = "filing_date") filingDate("filing_date"),
         @Json(name = "period_of_report_date") periodOfReportDate("period_of_report_date");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /vX/reference/financials
     * Stock Financials vX
     * Get historical financial data for a stock ticker. The financials data is extracted from XBRL from company SEC filings using the methodology outlined &lt;a rel&#x3D;\&quot;noopener noreferrer nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;http://xbrl.squarespace.com/understanding-sec-xbrl-financi/\&quot;&gt;here&lt;/a&gt;.
     * @param ticker Query by company ticker. (optional)
     * @param cik Query by central index key (&lt;a rel&#x3D;\&quot;noopener noreferrer nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://www.sec.gov/edgar/searchedgar/cik.htm\&quot;&gt;CIK&lt;/a&gt;) Number (optional)
     * @param companyName Query by company name. (optional)
     * @param sic Query by standard industrial classification (&lt;a rel&#x3D;\&quot;noopener noreferrer nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://www.sec.gov/corpfin/division-of-corporation-finance-standard-industrial-classification-sic-code-list\&quot;&gt;SIC&lt;/a&gt;) (optional)
     * @param filingDate Query by the date when the filing with financials data was filed in YYYY-MM-DD format.  Best used when querying over date ranges to find financials based on filings that happen in a time period.  Examples:  To get financials based on filings that have happened after January 1, 2009 use the query param filing_date.gte&#x3D;2009-01-01  To get financials based on filings that happened in the year 2009 use the query params filing_date.gte&#x3D;2009-01-01&amp;filing_date.lt&#x3D;2010-01-01 (optional)
     * @param periodOfReportDate The period of report for the filing with financials data in YYYY-MM-DD format. (optional)
     * @param timeframe Query by timeframe. Annual financials originate from 10-K filings, and quarterly financials originate from 10-Q filings. Note: Most companies do not file quarterly reports for Q4 and instead include those financials in their annual report, so some companies my not return quarterly financials for Q4 (optional)
     * @param includeSources Whether or not to include the &#x60;xpath&#x60; and &#x60;formula&#x60; attributes for each financial data point. See the &#x60;xpath&#x60; and &#x60;formula&#x60; response attributes for more info. False by default. (optional, default to false)
     * @param companyNameSearch Search by company_name. (optional)
     * @param filingDateGte Search by filing_date. (optional)
     * @param filingDateGt Search by filing_date. (optional)
     * @param filingDateLte Search by filing_date. (optional)
     * @param filingDateLt Search by filing_date. (optional)
     * @param periodOfReportDateGte Search by period_of_report_date. (optional)
     * @param periodOfReportDateGt Search by period_of_report_date. (optional)
     * @param periodOfReportDateLte Search by period_of_report_date. (optional)
     * @param periodOfReportDateLt Search by period_of_report_date. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 100. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to period_of_report_date)
     * @return ListFinancials200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listFinancials(ticker: kotlin.String? = null, cik: kotlin.String? = null, companyName: kotlin.String? = null, sic: kotlin.String? = null, filingDate: java.time.LocalDate? = null, periodOfReportDate: java.time.LocalDate? = null, timeframe: TimeframeListFinancials? = null, includeSources: kotlin.Boolean? = false, companyNameSearch: kotlin.String? = null, filingDateGte: java.time.LocalDate? = null, filingDateGt: java.time.LocalDate? = null, filingDateLte: java.time.LocalDate? = null, filingDateLt: java.time.LocalDate? = null, periodOfReportDateGte: java.time.LocalDate? = null, periodOfReportDateGt: java.time.LocalDate? = null, periodOfReportDateLte: java.time.LocalDate? = null, periodOfReportDateLt: java.time.LocalDate? = null, order: OrderListFinancials? = null, limit: kotlin.Int? = 10, sort: SortListFinancials? = SortListFinancials.periodOfReportDate) : ListFinancials200Response {
        val localVarResponse = listFinancialsWithHttpInfo(ticker = ticker, cik = cik, companyName = companyName, sic = sic, filingDate = filingDate, periodOfReportDate = periodOfReportDate, timeframe = timeframe, includeSources = includeSources, companyNameSearch = companyNameSearch, filingDateGte = filingDateGte, filingDateGt = filingDateGt, filingDateLte = filingDateLte, filingDateLt = filingDateLt, periodOfReportDateGte = periodOfReportDateGte, periodOfReportDateGt = periodOfReportDateGt, periodOfReportDateLte = periodOfReportDateLte, periodOfReportDateLt = periodOfReportDateLt, order = order, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListFinancials200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /vX/reference/financials
     * Stock Financials vX
     * Get historical financial data for a stock ticker. The financials data is extracted from XBRL from company SEC filings using the methodology outlined &lt;a rel&#x3D;\&quot;noopener noreferrer nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;http://xbrl.squarespace.com/understanding-sec-xbrl-financi/\&quot;&gt;here&lt;/a&gt;.
     * @param ticker Query by company ticker. (optional)
     * @param cik Query by central index key (&lt;a rel&#x3D;\&quot;noopener noreferrer nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://www.sec.gov/edgar/searchedgar/cik.htm\&quot;&gt;CIK&lt;/a&gt;) Number (optional)
     * @param companyName Query by company name. (optional)
     * @param sic Query by standard industrial classification (&lt;a rel&#x3D;\&quot;noopener noreferrer nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://www.sec.gov/corpfin/division-of-corporation-finance-standard-industrial-classification-sic-code-list\&quot;&gt;SIC&lt;/a&gt;) (optional)
     * @param filingDate Query by the date when the filing with financials data was filed in YYYY-MM-DD format.  Best used when querying over date ranges to find financials based on filings that happen in a time period.  Examples:  To get financials based on filings that have happened after January 1, 2009 use the query param filing_date.gte&#x3D;2009-01-01  To get financials based on filings that happened in the year 2009 use the query params filing_date.gte&#x3D;2009-01-01&amp;filing_date.lt&#x3D;2010-01-01 (optional)
     * @param periodOfReportDate The period of report for the filing with financials data in YYYY-MM-DD format. (optional)
     * @param timeframe Query by timeframe. Annual financials originate from 10-K filings, and quarterly financials originate from 10-Q filings. Note: Most companies do not file quarterly reports for Q4 and instead include those financials in their annual report, so some companies my not return quarterly financials for Q4 (optional)
     * @param includeSources Whether or not to include the &#x60;xpath&#x60; and &#x60;formula&#x60; attributes for each financial data point. See the &#x60;xpath&#x60; and &#x60;formula&#x60; response attributes for more info. False by default. (optional, default to false)
     * @param companyNameSearch Search by company_name. (optional)
     * @param filingDateGte Search by filing_date. (optional)
     * @param filingDateGt Search by filing_date. (optional)
     * @param filingDateLte Search by filing_date. (optional)
     * @param filingDateLt Search by filing_date. (optional)
     * @param periodOfReportDateGte Search by period_of_report_date. (optional)
     * @param periodOfReportDateGt Search by period_of_report_date. (optional)
     * @param periodOfReportDateLte Search by period_of_report_date. (optional)
     * @param periodOfReportDateLt Search by period_of_report_date. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 100. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to period_of_report_date)
     * @return ApiResponse<ListFinancials200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listFinancialsWithHttpInfo(ticker: kotlin.String?, cik: kotlin.String?, companyName: kotlin.String?, sic: kotlin.String?, filingDate: java.time.LocalDate?, periodOfReportDate: java.time.LocalDate?, timeframe: TimeframeListFinancials?, includeSources: kotlin.Boolean?, companyNameSearch: kotlin.String?, filingDateGte: java.time.LocalDate?, filingDateGt: java.time.LocalDate?, filingDateLte: java.time.LocalDate?, filingDateLt: java.time.LocalDate?, periodOfReportDateGte: java.time.LocalDate?, periodOfReportDateGt: java.time.LocalDate?, periodOfReportDateLte: java.time.LocalDate?, periodOfReportDateLt: java.time.LocalDate?, order: OrderListFinancials?, limit: kotlin.Int?, sort: SortListFinancials?) : ApiResponse<ListFinancials200Response?> {
        val localVariableConfig = listFinancialsRequestConfig(ticker = ticker, cik = cik, companyName = companyName, sic = sic, filingDate = filingDate, periodOfReportDate = periodOfReportDate, timeframe = timeframe, includeSources = includeSources, companyNameSearch = companyNameSearch, filingDateGte = filingDateGte, filingDateGt = filingDateGt, filingDateLte = filingDateLte, filingDateLt = filingDateLt, periodOfReportDateGte = periodOfReportDateGte, periodOfReportDateGt = periodOfReportDateGt, periodOfReportDateLte = periodOfReportDateLte, periodOfReportDateLt = periodOfReportDateLt, order = order, limit = limit, sort = sort)

        return request<Unit, ListFinancials200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listFinancials
     *
     * @param ticker Query by company ticker. (optional)
     * @param cik Query by central index key (&lt;a rel&#x3D;\&quot;noopener noreferrer nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://www.sec.gov/edgar/searchedgar/cik.htm\&quot;&gt;CIK&lt;/a&gt;) Number (optional)
     * @param companyName Query by company name. (optional)
     * @param sic Query by standard industrial classification (&lt;a rel&#x3D;\&quot;noopener noreferrer nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://www.sec.gov/corpfin/division-of-corporation-finance-standard-industrial-classification-sic-code-list\&quot;&gt;SIC&lt;/a&gt;) (optional)
     * @param filingDate Query by the date when the filing with financials data was filed in YYYY-MM-DD format.  Best used when querying over date ranges to find financials based on filings that happen in a time period.  Examples:  To get financials based on filings that have happened after January 1, 2009 use the query param filing_date.gte&#x3D;2009-01-01  To get financials based on filings that happened in the year 2009 use the query params filing_date.gte&#x3D;2009-01-01&amp;filing_date.lt&#x3D;2010-01-01 (optional)
     * @param periodOfReportDate The period of report for the filing with financials data in YYYY-MM-DD format. (optional)
     * @param timeframe Query by timeframe. Annual financials originate from 10-K filings, and quarterly financials originate from 10-Q filings. Note: Most companies do not file quarterly reports for Q4 and instead include those financials in their annual report, so some companies my not return quarterly financials for Q4 (optional)
     * @param includeSources Whether or not to include the &#x60;xpath&#x60; and &#x60;formula&#x60; attributes for each financial data point. See the &#x60;xpath&#x60; and &#x60;formula&#x60; response attributes for more info. False by default. (optional, default to false)
     * @param companyNameSearch Search by company_name. (optional)
     * @param filingDateGte Search by filing_date. (optional)
     * @param filingDateGt Search by filing_date. (optional)
     * @param filingDateLte Search by filing_date. (optional)
     * @param filingDateLt Search by filing_date. (optional)
     * @param periodOfReportDateGte Search by period_of_report_date. (optional)
     * @param periodOfReportDateGt Search by period_of_report_date. (optional)
     * @param periodOfReportDateLte Search by period_of_report_date. (optional)
     * @param periodOfReportDateLt Search by period_of_report_date. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 100. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to period_of_report_date)
     * @return RequestConfig
     */
    fun listFinancialsRequestConfig(ticker: kotlin.String?, cik: kotlin.String?, companyName: kotlin.String?, sic: kotlin.String?, filingDate: java.time.LocalDate?, periodOfReportDate: java.time.LocalDate?, timeframe: TimeframeListFinancials?, includeSources: kotlin.Boolean?, companyNameSearch: kotlin.String?, filingDateGte: java.time.LocalDate?, filingDateGt: java.time.LocalDate?, filingDateLte: java.time.LocalDate?, filingDateLt: java.time.LocalDate?, periodOfReportDateGte: java.time.LocalDate?, periodOfReportDateGt: java.time.LocalDate?, periodOfReportDateLte: java.time.LocalDate?, periodOfReportDateLt: java.time.LocalDate?, order: OrderListFinancials?, limit: kotlin.Int?, sort: SortListFinancials?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
                if (cik != null) {
                    put("cik", listOf(cik.toString()))
                }
                if (companyName != null) {
                    put("company_name", listOf(companyName.toString()))
                }
                if (sic != null) {
                    put("sic", listOf(sic.toString()))
                }
                if (filingDate != null) {
                    put("filing_date", listOf(parseDateToQueryString(filingDate)))
                }
                if (periodOfReportDate != null) {
                    put("period_of_report_date", listOf(parseDateToQueryString(periodOfReportDate)))
                }
                if (timeframe != null) {
                    put("timeframe", listOf(timeframe.value))
                }
                if (includeSources != null) {
                    put("include_sources", listOf(includeSources.toString()))
                }
                if (companyNameSearch != null) {
                    put("company_name.search", listOf(companyNameSearch.toString()))
                }
                if (filingDateGte != null) {
                    put("filing_date.gte", listOf(parseDateToQueryString(filingDateGte)))
                }
                if (filingDateGt != null) {
                    put("filing_date.gt", listOf(parseDateToQueryString(filingDateGt)))
                }
                if (filingDateLte != null) {
                    put("filing_date.lte", listOf(parseDateToQueryString(filingDateLte)))
                }
                if (filingDateLt != null) {
                    put("filing_date.lt", listOf(parseDateToQueryString(filingDateLt)))
                }
                if (periodOfReportDateGte != null) {
                    put("period_of_report_date.gte", listOf(parseDateToQueryString(periodOfReportDateGte)))
                }
                if (periodOfReportDateGt != null) {
                    put("period_of_report_date.gt", listOf(parseDateToQueryString(periodOfReportDateGt)))
                }
                if (periodOfReportDateLte != null) {
                    put("period_of_report_date.lte", listOf(parseDateToQueryString(periodOfReportDateLte)))
                }
                if (periodOfReportDateLt != null) {
                    put("period_of_report_date.lt", listOf(parseDateToQueryString(periodOfReportDateLt)))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/vX/reference/financials",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter ipoStatus
     */
     enum class IpoStatusListIPOs(val value: kotlin.String) {
         @Json(name = "direct_listing_process") directListingProcess("direct_listing_process"),
         @Json(name = "history") history("history"),
         @Json(name = "new") new("new"),
         @Json(name = "pending") pending("pending"),
         @Json(name = "postponed") postponed("postponed"),
         @Json(name = "rumor") rumor("rumor"),
         @Json(name = "withdrawn") withdrawn("withdrawn");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderListIPOs(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortListIPOs(val value: kotlin.String) {
         @Json(name = "listing_date") listingDate("listing_date"),
         @Json(name = "ticker") ticker("ticker"),
         @Json(name = "last_updated") lastUpdated("last_updated"),
         @Json(name = "security_type") securityType("security_type"),
         @Json(name = "issuer_name") issuerName("issuer_name"),
         @Json(name = "currency_code") currencyCode("currency_code"),
         @Json(name = "isin") isin("isin"),
         @Json(name = "us_code") usCode("us_code"),
         @Json(name = "final_issue_price") finalIssuePrice("final_issue_price"),
         @Json(name = "min_shares_offered") minSharesOffered("min_shares_offered"),
         @Json(name = "max_shares_offered") maxSharesOffered("max_shares_offered"),
         @Json(name = "lowest_offer_price") lowestOfferPrice("lowest_offer_price"),
         @Json(name = "highest_offer_price") highestOfferPrice("highest_offer_price"),
         @Json(name = "total_offer_size") totalOfferSize("total_offer_size"),
         @Json(name = "shares_outstanding") sharesOutstanding("shares_outstanding"),
         @Json(name = "primary_exchange") primaryExchange("primary_exchange"),
         @Json(name = "lot_size") lotSize("lot_size"),
         @Json(name = "security_description") securityDescription("security_description"),
         @Json(name = "ipo_status") ipoStatus("ipo_status"),
         @Json(name = "announced_date") announcedDate("announced_date");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /vX/reference/ipos
     * IPOs
     * The IPOs API provides access to detailed information about Initial Public Offerings (IPOs), including both upcoming and historical events. With this API, you can query for a comprehensive list of IPOs, along with key details such as the issuer name, ticker symbol, ISIN, IPO date, number of shares offered, expected price range, and final offering price. You can filter the results by status to focus on new, rumors, pending, historical, and more.
     * @param ticker Specify a case-sensitive ticker symbol. For example, TSLA represents Tesla Inc. (optional)
     * @param usCode Specify a us_code. This is a unique nine-character alphanumeric code that identifies a North American financial security for the purposes of facilitating clearing and settlement of trades. (optional)
     * @param isin Specify an International Securities Identification Number (ISIN). This is a unique twelve-digit code that is assigned to every security issuance in the world. (optional)
     * @param listingDate Specify a listing date. This is the first trading date for the newly listed entity. (optional)
     * @param ipoStatus Specify an IPO status. (optional)
     * @param listingDateGte Range by listing_date. (optional)
     * @param listingDateGt Range by listing_date. (optional)
     * @param listingDateLte Range by listing_date. (optional)
     * @param listingDateLt Range by listing_date. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 1000. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to listing_date)
     * @return ListIPOs200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listIPOs(ticker: kotlin.String? = null, usCode: kotlin.String? = null, isin: kotlin.String? = null, listingDate: java.time.LocalDate? = null, ipoStatus: IpoStatusListIPOs? = null, listingDateGte: java.time.LocalDate? = null, listingDateGt: java.time.LocalDate? = null, listingDateLte: java.time.LocalDate? = null, listingDateLt: java.time.LocalDate? = null, order: OrderListIPOs? = OrderListIPOs.desc, limit: kotlin.Int? = 10, sort: SortListIPOs? = SortListIPOs.listingDate) : ListIPOs200Response {
        val localVarResponse = listIPOsWithHttpInfo(ticker = ticker, usCode = usCode, isin = isin, listingDate = listingDate, ipoStatus = ipoStatus, listingDateGte = listingDateGte, listingDateGt = listingDateGt, listingDateLte = listingDateLte, listingDateLt = listingDateLt, order = order, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListIPOs200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /vX/reference/ipos
     * IPOs
     * The IPOs API provides access to detailed information about Initial Public Offerings (IPOs), including both upcoming and historical events. With this API, you can query for a comprehensive list of IPOs, along with key details such as the issuer name, ticker symbol, ISIN, IPO date, number of shares offered, expected price range, and final offering price. You can filter the results by status to focus on new, rumors, pending, historical, and more.
     * @param ticker Specify a case-sensitive ticker symbol. For example, TSLA represents Tesla Inc. (optional)
     * @param usCode Specify a us_code. This is a unique nine-character alphanumeric code that identifies a North American financial security for the purposes of facilitating clearing and settlement of trades. (optional)
     * @param isin Specify an International Securities Identification Number (ISIN). This is a unique twelve-digit code that is assigned to every security issuance in the world. (optional)
     * @param listingDate Specify a listing date. This is the first trading date for the newly listed entity. (optional)
     * @param ipoStatus Specify an IPO status. (optional)
     * @param listingDateGte Range by listing_date. (optional)
     * @param listingDateGt Range by listing_date. (optional)
     * @param listingDateLte Range by listing_date. (optional)
     * @param listingDateLt Range by listing_date. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 1000. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to listing_date)
     * @return ApiResponse<ListIPOs200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listIPOsWithHttpInfo(ticker: kotlin.String?, usCode: kotlin.String?, isin: kotlin.String?, listingDate: java.time.LocalDate?, ipoStatus: IpoStatusListIPOs?, listingDateGte: java.time.LocalDate?, listingDateGt: java.time.LocalDate?, listingDateLte: java.time.LocalDate?, listingDateLt: java.time.LocalDate?, order: OrderListIPOs?, limit: kotlin.Int?, sort: SortListIPOs?) : ApiResponse<ListIPOs200Response?> {
        val localVariableConfig = listIPOsRequestConfig(ticker = ticker, usCode = usCode, isin = isin, listingDate = listingDate, ipoStatus = ipoStatus, listingDateGte = listingDateGte, listingDateGt = listingDateGt, listingDateLte = listingDateLte, listingDateLt = listingDateLt, order = order, limit = limit, sort = sort)

        return request<Unit, ListIPOs200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listIPOs
     *
     * @param ticker Specify a case-sensitive ticker symbol. For example, TSLA represents Tesla Inc. (optional)
     * @param usCode Specify a us_code. This is a unique nine-character alphanumeric code that identifies a North American financial security for the purposes of facilitating clearing and settlement of trades. (optional)
     * @param isin Specify an International Securities Identification Number (ISIN). This is a unique twelve-digit code that is assigned to every security issuance in the world. (optional)
     * @param listingDate Specify a listing date. This is the first trading date for the newly listed entity. (optional)
     * @param ipoStatus Specify an IPO status. (optional)
     * @param listingDateGte Range by listing_date. (optional)
     * @param listingDateGt Range by listing_date. (optional)
     * @param listingDateLte Range by listing_date. (optional)
     * @param listingDateLt Range by listing_date. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 1000. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to listing_date)
     * @return RequestConfig
     */
    fun listIPOsRequestConfig(ticker: kotlin.String?, usCode: kotlin.String?, isin: kotlin.String?, listingDate: java.time.LocalDate?, ipoStatus: IpoStatusListIPOs?, listingDateGte: java.time.LocalDate?, listingDateGt: java.time.LocalDate?, listingDateLte: java.time.LocalDate?, listingDateLt: java.time.LocalDate?, order: OrderListIPOs?, limit: kotlin.Int?, sort: SortListIPOs?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
                if (usCode != null) {
                    put("us_code", listOf(usCode.toString()))
                }
                if (isin != null) {
                    put("isin", listOf(isin.toString()))
                }
                if (listingDate != null) {
                    put("listing_date", listOf(parseDateToQueryString(listingDate)))
                }
                if (ipoStatus != null) {
                    put("ipo_status", listOf(ipoStatus.value))
                }
                if (listingDateGte != null) {
                    put("listing_date.gte", listOf(parseDateToQueryString(listingDateGte)))
                }
                if (listingDateGt != null) {
                    put("listing_date.gt", listOf(parseDateToQueryString(listingDateGt)))
                }
                if (listingDateLte != null) {
                    put("listing_date.lte", listOf(parseDateToQueryString(listingDateLte)))
                }
                if (listingDateLt != null) {
                    put("listing_date.lt", listOf(parseDateToQueryString(listingDateLt)))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/vX/reference/ipos",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter order
     */
     enum class OrderListNews(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortListNews(val value: kotlin.String) {
         @Json(name = "published_utc") publishedUtc("published_utc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v2/reference/news
     * Ticker News
     * Get the most recent news articles relating to a stock ticker symbol, including a summary of the article and a link to the original source.
     * @param ticker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc. (optional)
     * @param publishedUtc Return results published on, before, or after this date. (optional)
     * @param tickerGte Search by ticker. (optional)
     * @param tickerGt Search by ticker. (optional)
     * @param tickerLte Search by ticker. (optional)
     * @param tickerLt Search by ticker. (optional)
     * @param publishedUtcGte Search by published_utc. (optional)
     * @param publishedUtcGt Search by published_utc. (optional)
     * @param publishedUtcLte Search by published_utc. (optional)
     * @param publishedUtcLt Search by published_utc. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 1000. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to published_utc)
     * @return ListNews200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listNews(ticker: kotlin.String? = null, publishedUtc: ListNewsPublishedUtcParameter? = null, tickerGte: kotlin.String? = null, tickerGt: kotlin.String? = null, tickerLte: kotlin.String? = null, tickerLt: kotlin.String? = null, publishedUtcGte: ListNewsPublishedUtcParameter? = null, publishedUtcGt: ListNewsPublishedUtcParameter? = null, publishedUtcLte: ListNewsPublishedUtcParameter? = null, publishedUtcLt: ListNewsPublishedUtcParameter? = null, order: OrderListNews? = null, limit: kotlin.Int? = 10, sort: SortListNews? = SortListNews.publishedUtc) : ListNews200Response {
        val localVarResponse = listNewsWithHttpInfo(ticker = ticker, publishedUtc = publishedUtc, tickerGte = tickerGte, tickerGt = tickerGt, tickerLte = tickerLte, tickerLt = tickerLt, publishedUtcGte = publishedUtcGte, publishedUtcGt = publishedUtcGt, publishedUtcLte = publishedUtcLte, publishedUtcLt = publishedUtcLt, order = order, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListNews200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/reference/news
     * Ticker News
     * Get the most recent news articles relating to a stock ticker symbol, including a summary of the article and a link to the original source.
     * @param ticker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc. (optional)
     * @param publishedUtc Return results published on, before, or after this date. (optional)
     * @param tickerGte Search by ticker. (optional)
     * @param tickerGt Search by ticker. (optional)
     * @param tickerLte Search by ticker. (optional)
     * @param tickerLt Search by ticker. (optional)
     * @param publishedUtcGte Search by published_utc. (optional)
     * @param publishedUtcGt Search by published_utc. (optional)
     * @param publishedUtcLte Search by published_utc. (optional)
     * @param publishedUtcLt Search by published_utc. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 1000. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to published_utc)
     * @return ApiResponse<ListNews200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listNewsWithHttpInfo(ticker: kotlin.String?, publishedUtc: ListNewsPublishedUtcParameter?, tickerGte: kotlin.String?, tickerGt: kotlin.String?, tickerLte: kotlin.String?, tickerLt: kotlin.String?, publishedUtcGte: ListNewsPublishedUtcParameter?, publishedUtcGt: ListNewsPublishedUtcParameter?, publishedUtcLte: ListNewsPublishedUtcParameter?, publishedUtcLt: ListNewsPublishedUtcParameter?, order: OrderListNews?, limit: kotlin.Int?, sort: SortListNews?) : ApiResponse<ListNews200Response?> {
        val localVariableConfig = listNewsRequestConfig(ticker = ticker, publishedUtc = publishedUtc, tickerGte = tickerGte, tickerGt = tickerGt, tickerLte = tickerLte, tickerLt = tickerLt, publishedUtcGte = publishedUtcGte, publishedUtcGt = publishedUtcGt, publishedUtcLte = publishedUtcLte, publishedUtcLt = publishedUtcLt, order = order, limit = limit, sort = sort)

        return request<Unit, ListNews200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listNews
     *
     * @param ticker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc. (optional)
     * @param publishedUtc Return results published on, before, or after this date. (optional)
     * @param tickerGte Search by ticker. (optional)
     * @param tickerGt Search by ticker. (optional)
     * @param tickerLte Search by ticker. (optional)
     * @param tickerLt Search by ticker. (optional)
     * @param publishedUtcGte Search by published_utc. (optional)
     * @param publishedUtcGt Search by published_utc. (optional)
     * @param publishedUtcLte Search by published_utc. (optional)
     * @param publishedUtcLt Search by published_utc. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 1000. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to published_utc)
     * @return RequestConfig
     */
    fun listNewsRequestConfig(ticker: kotlin.String?, publishedUtc: ListNewsPublishedUtcParameter?, tickerGte: kotlin.String?, tickerGt: kotlin.String?, tickerLte: kotlin.String?, tickerLt: kotlin.String?, publishedUtcGte: ListNewsPublishedUtcParameter?, publishedUtcGt: ListNewsPublishedUtcParameter?, publishedUtcLte: ListNewsPublishedUtcParameter?, publishedUtcLt: ListNewsPublishedUtcParameter?, order: OrderListNews?, limit: kotlin.Int?, sort: SortListNews?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
                if (publishedUtc != null) {
                }
                if (tickerGte != null) {
                    put("ticker.gte", listOf(tickerGte.toString()))
                }
                if (tickerGt != null) {
                    put("ticker.gt", listOf(tickerGt.toString()))
                }
                if (tickerLte != null) {
                    put("ticker.lte", listOf(tickerLte.toString()))
                }
                if (tickerLt != null) {
                    put("ticker.lt", listOf(tickerLt.toString()))
                }
                if (publishedUtcGte != null) {
                }
                if (publishedUtcGt != null) {
                }
                if (publishedUtcLte != null) {
                }
                if (publishedUtcLt != null) {
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/reference/news",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter contractType
     */
     enum class ContractTypeListOptionsContracts(val value: kotlin.String) {
         @Json(name = "call") call("call"),
         @Json(name = "put") put("put");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderListOptionsContracts(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortListOptionsContracts(val value: kotlin.String) {
         @Json(name = "ticker") ticker("ticker"),
         @Json(name = "underlying_ticker") underlyingTicker("underlying_ticker"),
         @Json(name = "expiration_date") expirationDate("expiration_date"),
         @Json(name = "strike_price") strikePrice("strike_price");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v3/reference/options/contracts
     * Options Contracts
     * Query for historical options contracts. This provides both active and expired options contracts.
     * @param underlyingTicker Query for contracts relating to an underlying stock ticker. (optional)
     * @param ticker This parameter has been deprecated. To search by specific options ticker, use the Options Contract endpoint [here](https://polygon.io/docs/options/get_v3_reference_options_contracts__options_ticker). (optional)
     * @param contractType Query by the type of contract. (optional)
     * @param expirationDate Query by contract expiration with date format YYYY-MM-DD. (optional)
     * @param asOf Specify a point in time for contracts as of this date with format YYYY-MM-DD. Defaults to today&#39;s date. (optional)
     * @param strikePrice Query by strike price of a contract. (optional)
     * @param expired Query for expired contracts. Default is false. (optional)
     * @param underlyingTickerGte Range by underlying_ticker. (optional)
     * @param underlyingTickerGt Range by underlying_ticker. (optional)
     * @param underlyingTickerLte Range by underlying_ticker. (optional)
     * @param underlyingTickerLt Range by underlying_ticker. (optional)
     * @param expirationDateGte Range by expiration_date. (optional)
     * @param expirationDateGt Range by expiration_date. (optional)
     * @param expirationDateLte Range by expiration_date. (optional)
     * @param expirationDateLt Range by expiration_date. (optional)
     * @param strikePriceGte Range by strike_price. (optional)
     * @param strikePriceGt Range by strike_price. (optional)
     * @param strikePriceLte Range by strike_price. (optional)
     * @param strikePriceLt Range by strike_price. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 1000. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to ticker)
     * @return ListOptionsContracts200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listOptionsContracts(underlyingTicker: kotlin.String? = null, ticker: kotlin.String? = null, contractType: ContractTypeListOptionsContracts? = null, expirationDate: kotlin.String? = null, asOf: kotlin.String? = null, strikePrice: java.math.BigDecimal? = null, expired: kotlin.Boolean? = null, underlyingTickerGte: kotlin.String? = null, underlyingTickerGt: kotlin.String? = null, underlyingTickerLte: kotlin.String? = null, underlyingTickerLt: kotlin.String? = null, expirationDateGte: kotlin.String? = null, expirationDateGt: kotlin.String? = null, expirationDateLte: kotlin.String? = null, expirationDateLt: kotlin.String? = null, strikePriceGte: java.math.BigDecimal? = null, strikePriceGt: java.math.BigDecimal? = null, strikePriceLte: java.math.BigDecimal? = null, strikePriceLt: java.math.BigDecimal? = null, order: OrderListOptionsContracts? = null, limit: kotlin.Int? = 10, sort: SortListOptionsContracts? = SortListOptionsContracts.ticker) : ListOptionsContracts200Response {
        val localVarResponse = listOptionsContractsWithHttpInfo(underlyingTicker = underlyingTicker, ticker = ticker, contractType = contractType, expirationDate = expirationDate, asOf = asOf, strikePrice = strikePrice, expired = expired, underlyingTickerGte = underlyingTickerGte, underlyingTickerGt = underlyingTickerGt, underlyingTickerLte = underlyingTickerLte, underlyingTickerLt = underlyingTickerLt, expirationDateGte = expirationDateGte, expirationDateGt = expirationDateGt, expirationDateLte = expirationDateLte, expirationDateLt = expirationDateLt, strikePriceGte = strikePriceGte, strikePriceGt = strikePriceGt, strikePriceLte = strikePriceLte, strikePriceLt = strikePriceLt, order = order, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListOptionsContracts200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v3/reference/options/contracts
     * Options Contracts
     * Query for historical options contracts. This provides both active and expired options contracts.
     * @param underlyingTicker Query for contracts relating to an underlying stock ticker. (optional)
     * @param ticker This parameter has been deprecated. To search by specific options ticker, use the Options Contract endpoint [here](https://polygon.io/docs/options/get_v3_reference_options_contracts__options_ticker). (optional)
     * @param contractType Query by the type of contract. (optional)
     * @param expirationDate Query by contract expiration with date format YYYY-MM-DD. (optional)
     * @param asOf Specify a point in time for contracts as of this date with format YYYY-MM-DD. Defaults to today&#39;s date. (optional)
     * @param strikePrice Query by strike price of a contract. (optional)
     * @param expired Query for expired contracts. Default is false. (optional)
     * @param underlyingTickerGte Range by underlying_ticker. (optional)
     * @param underlyingTickerGt Range by underlying_ticker. (optional)
     * @param underlyingTickerLte Range by underlying_ticker. (optional)
     * @param underlyingTickerLt Range by underlying_ticker. (optional)
     * @param expirationDateGte Range by expiration_date. (optional)
     * @param expirationDateGt Range by expiration_date. (optional)
     * @param expirationDateLte Range by expiration_date. (optional)
     * @param expirationDateLt Range by expiration_date. (optional)
     * @param strikePriceGte Range by strike_price. (optional)
     * @param strikePriceGt Range by strike_price. (optional)
     * @param strikePriceLte Range by strike_price. (optional)
     * @param strikePriceLt Range by strike_price. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 1000. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to ticker)
     * @return ApiResponse<ListOptionsContracts200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listOptionsContractsWithHttpInfo(underlyingTicker: kotlin.String?, ticker: kotlin.String?, contractType: ContractTypeListOptionsContracts?, expirationDate: kotlin.String?, asOf: kotlin.String?, strikePrice: java.math.BigDecimal?, expired: kotlin.Boolean?, underlyingTickerGte: kotlin.String?, underlyingTickerGt: kotlin.String?, underlyingTickerLte: kotlin.String?, underlyingTickerLt: kotlin.String?, expirationDateGte: kotlin.String?, expirationDateGt: kotlin.String?, expirationDateLte: kotlin.String?, expirationDateLt: kotlin.String?, strikePriceGte: java.math.BigDecimal?, strikePriceGt: java.math.BigDecimal?, strikePriceLte: java.math.BigDecimal?, strikePriceLt: java.math.BigDecimal?, order: OrderListOptionsContracts?, limit: kotlin.Int?, sort: SortListOptionsContracts?) : ApiResponse<ListOptionsContracts200Response?> {
        val localVariableConfig = listOptionsContractsRequestConfig(underlyingTicker = underlyingTicker, ticker = ticker, contractType = contractType, expirationDate = expirationDate, asOf = asOf, strikePrice = strikePrice, expired = expired, underlyingTickerGte = underlyingTickerGte, underlyingTickerGt = underlyingTickerGt, underlyingTickerLte = underlyingTickerLte, underlyingTickerLt = underlyingTickerLt, expirationDateGte = expirationDateGte, expirationDateGt = expirationDateGt, expirationDateLte = expirationDateLte, expirationDateLt = expirationDateLt, strikePriceGte = strikePriceGte, strikePriceGt = strikePriceGt, strikePriceLte = strikePriceLte, strikePriceLt = strikePriceLt, order = order, limit = limit, sort = sort)

        return request<Unit, ListOptionsContracts200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listOptionsContracts
     *
     * @param underlyingTicker Query for contracts relating to an underlying stock ticker. (optional)
     * @param ticker This parameter has been deprecated. To search by specific options ticker, use the Options Contract endpoint [here](https://polygon.io/docs/options/get_v3_reference_options_contracts__options_ticker). (optional)
     * @param contractType Query by the type of contract. (optional)
     * @param expirationDate Query by contract expiration with date format YYYY-MM-DD. (optional)
     * @param asOf Specify a point in time for contracts as of this date with format YYYY-MM-DD. Defaults to today&#39;s date. (optional)
     * @param strikePrice Query by strike price of a contract. (optional)
     * @param expired Query for expired contracts. Default is false. (optional)
     * @param underlyingTickerGte Range by underlying_ticker. (optional)
     * @param underlyingTickerGt Range by underlying_ticker. (optional)
     * @param underlyingTickerLte Range by underlying_ticker. (optional)
     * @param underlyingTickerLt Range by underlying_ticker. (optional)
     * @param expirationDateGte Range by expiration_date. (optional)
     * @param expirationDateGt Range by expiration_date. (optional)
     * @param expirationDateLte Range by expiration_date. (optional)
     * @param expirationDateLt Range by expiration_date. (optional)
     * @param strikePriceGte Range by strike_price. (optional)
     * @param strikePriceGt Range by strike_price. (optional)
     * @param strikePriceLte Range by strike_price. (optional)
     * @param strikePriceLt Range by strike_price. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 1000. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to ticker)
     * @return RequestConfig
     */
    fun listOptionsContractsRequestConfig(underlyingTicker: kotlin.String?, ticker: kotlin.String?, contractType: ContractTypeListOptionsContracts?, expirationDate: kotlin.String?, asOf: kotlin.String?, strikePrice: java.math.BigDecimal?, expired: kotlin.Boolean?, underlyingTickerGte: kotlin.String?, underlyingTickerGt: kotlin.String?, underlyingTickerLte: kotlin.String?, underlyingTickerLt: kotlin.String?, expirationDateGte: kotlin.String?, expirationDateGt: kotlin.String?, expirationDateLte: kotlin.String?, expirationDateLt: kotlin.String?, strikePriceGte: java.math.BigDecimal?, strikePriceGt: java.math.BigDecimal?, strikePriceLte: java.math.BigDecimal?, strikePriceLt: java.math.BigDecimal?, order: OrderListOptionsContracts?, limit: kotlin.Int?, sort: SortListOptionsContracts?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (underlyingTicker != null) {
                    put("underlying_ticker", listOf(underlyingTicker.toString()))
                }
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
                if (contractType != null) {
                    put("contract_type", listOf(contractType.value))
                }
                if (expirationDate != null) {
                    put("expiration_date", listOf(expirationDate.toString()))
                }
                if (asOf != null) {
                    put("as_of", listOf(asOf.toString()))
                }
                if (strikePrice != null) {
                    put("strike_price", listOf(strikePrice.toString()))
                }
                if (expired != null) {
                    put("expired", listOf(expired.toString()))
                }
                if (underlyingTickerGte != null) {
                    put("underlying_ticker.gte", listOf(underlyingTickerGte.toString()))
                }
                if (underlyingTickerGt != null) {
                    put("underlying_ticker.gt", listOf(underlyingTickerGt.toString()))
                }
                if (underlyingTickerLte != null) {
                    put("underlying_ticker.lte", listOf(underlyingTickerLte.toString()))
                }
                if (underlyingTickerLt != null) {
                    put("underlying_ticker.lt", listOf(underlyingTickerLt.toString()))
                }
                if (expirationDateGte != null) {
                    put("expiration_date.gte", listOf(expirationDateGte.toString()))
                }
                if (expirationDateGt != null) {
                    put("expiration_date.gt", listOf(expirationDateGt.toString()))
                }
                if (expirationDateLte != null) {
                    put("expiration_date.lte", listOf(expirationDateLte.toString()))
                }
                if (expirationDateLt != null) {
                    put("expiration_date.lt", listOf(expirationDateLt.toString()))
                }
                if (strikePriceGte != null) {
                    put("strike_price.gte", listOf(strikePriceGte.toString()))
                }
                if (strikePriceGt != null) {
                    put("strike_price.gt", listOf(strikePriceGt.toString()))
                }
                if (strikePriceLte != null) {
                    put("strike_price.lte", listOf(strikePriceLte.toString()))
                }
                if (strikePriceLt != null) {
                    put("strike_price.lt", listOf(strikePriceLt.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v3/reference/options/contracts",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter order
     */
     enum class OrderListStockSplits(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortListStockSplits(val value: kotlin.String) {
         @Json(name = "execution_date") executionDate("execution_date"),
         @Json(name = "ticker") ticker("ticker");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v3/reference/splits
     * Stock Splits v3
     * Get a list of historical stock splits, including the ticker symbol, the execution date, and the factors of the split ratio.
     * @param ticker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc. (optional)
     * @param executionDate Query by execution date with the format YYYY-MM-DD. (optional)
     * @param reverseSplit Query for reverse stock splits. A split ratio where split_from is greater than split_to represents a reverse split. By default this filter is not used. (optional)
     * @param tickerGte Range by ticker. (optional)
     * @param tickerGt Range by ticker. (optional)
     * @param tickerLte Range by ticker. (optional)
     * @param tickerLt Range by ticker. (optional)
     * @param executionDateGte Range by execution_date. (optional)
     * @param executionDateGt Range by execution_date. (optional)
     * @param executionDateLte Range by execution_date. (optional)
     * @param executionDateLt Range by execution_date. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 1000. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to execution_date)
     * @return ListStockSplits200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listStockSplits(ticker: kotlin.String? = null, executionDate: java.time.LocalDate? = null, reverseSplit: kotlin.Boolean? = null, tickerGte: kotlin.String? = null, tickerGt: kotlin.String? = null, tickerLte: kotlin.String? = null, tickerLt: kotlin.String? = null, executionDateGte: java.time.LocalDate? = null, executionDateGt: java.time.LocalDate? = null, executionDateLte: java.time.LocalDate? = null, executionDateLt: java.time.LocalDate? = null, order: OrderListStockSplits? = null, limit: kotlin.Int? = 10, sort: SortListStockSplits? = SortListStockSplits.executionDate) : ListStockSplits200Response {
        val localVarResponse = listStockSplitsWithHttpInfo(ticker = ticker, executionDate = executionDate, reverseSplit = reverseSplit, tickerGte = tickerGte, tickerGt = tickerGt, tickerLte = tickerLte, tickerLt = tickerLt, executionDateGte = executionDateGte, executionDateGt = executionDateGt, executionDateLte = executionDateLte, executionDateLt = executionDateLt, order = order, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListStockSplits200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v3/reference/splits
     * Stock Splits v3
     * Get a list of historical stock splits, including the ticker symbol, the execution date, and the factors of the split ratio.
     * @param ticker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc. (optional)
     * @param executionDate Query by execution date with the format YYYY-MM-DD. (optional)
     * @param reverseSplit Query for reverse stock splits. A split ratio where split_from is greater than split_to represents a reverse split. By default this filter is not used. (optional)
     * @param tickerGte Range by ticker. (optional)
     * @param tickerGt Range by ticker. (optional)
     * @param tickerLte Range by ticker. (optional)
     * @param tickerLt Range by ticker. (optional)
     * @param executionDateGte Range by execution_date. (optional)
     * @param executionDateGt Range by execution_date. (optional)
     * @param executionDateLte Range by execution_date. (optional)
     * @param executionDateLt Range by execution_date. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 1000. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to execution_date)
     * @return ApiResponse<ListStockSplits200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listStockSplitsWithHttpInfo(ticker: kotlin.String?, executionDate: java.time.LocalDate?, reverseSplit: kotlin.Boolean?, tickerGte: kotlin.String?, tickerGt: kotlin.String?, tickerLte: kotlin.String?, tickerLt: kotlin.String?, executionDateGte: java.time.LocalDate?, executionDateGt: java.time.LocalDate?, executionDateLte: java.time.LocalDate?, executionDateLt: java.time.LocalDate?, order: OrderListStockSplits?, limit: kotlin.Int?, sort: SortListStockSplits?) : ApiResponse<ListStockSplits200Response?> {
        val localVariableConfig = listStockSplitsRequestConfig(ticker = ticker, executionDate = executionDate, reverseSplit = reverseSplit, tickerGte = tickerGte, tickerGt = tickerGt, tickerLte = tickerLte, tickerLt = tickerLt, executionDateGte = executionDateGte, executionDateGt = executionDateGt, executionDateLte = executionDateLte, executionDateLt = executionDateLt, order = order, limit = limit, sort = sort)

        return request<Unit, ListStockSplits200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listStockSplits
     *
     * @param ticker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc. (optional)
     * @param executionDate Query by execution date with the format YYYY-MM-DD. (optional)
     * @param reverseSplit Query for reverse stock splits. A split ratio where split_from is greater than split_to represents a reverse split. By default this filter is not used. (optional)
     * @param tickerGte Range by ticker. (optional)
     * @param tickerGt Range by ticker. (optional)
     * @param tickerLte Range by ticker. (optional)
     * @param tickerLt Range by ticker. (optional)
     * @param executionDateGte Range by execution_date. (optional)
     * @param executionDateGt Range by execution_date. (optional)
     * @param executionDateLte Range by execution_date. (optional)
     * @param executionDateLt Range by execution_date. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 1000. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to execution_date)
     * @return RequestConfig
     */
    fun listStockSplitsRequestConfig(ticker: kotlin.String?, executionDate: java.time.LocalDate?, reverseSplit: kotlin.Boolean?, tickerGte: kotlin.String?, tickerGt: kotlin.String?, tickerLte: kotlin.String?, tickerLt: kotlin.String?, executionDateGte: java.time.LocalDate?, executionDateGt: java.time.LocalDate?, executionDateLte: java.time.LocalDate?, executionDateLt: java.time.LocalDate?, order: OrderListStockSplits?, limit: kotlin.Int?, sort: SortListStockSplits?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
                if (executionDate != null) {
                    put("execution_date", listOf(parseDateToQueryString(executionDate)))
                }
                if (reverseSplit != null) {
                    put("reverse_split", listOf(reverseSplit.toString()))
                }
                if (tickerGte != null) {
                    put("ticker.gte", listOf(tickerGte.toString()))
                }
                if (tickerGt != null) {
                    put("ticker.gt", listOf(tickerGt.toString()))
                }
                if (tickerLte != null) {
                    put("ticker.lte", listOf(tickerLte.toString()))
                }
                if (tickerLt != null) {
                    put("ticker.lt", listOf(tickerLt.toString()))
                }
                if (executionDateGte != null) {
                    put("execution_date.gte", listOf(parseDateToQueryString(executionDateGte)))
                }
                if (executionDateGt != null) {
                    put("execution_date.gt", listOf(parseDateToQueryString(executionDateGt)))
                }
                if (executionDateLte != null) {
                    put("execution_date.lte", listOf(parseDateToQueryString(executionDateLte)))
                }
                if (executionDateLt != null) {
                    put("execution_date.lt", listOf(parseDateToQueryString(executionDateLt)))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v3/reference/splits",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter assetClass
     */
     enum class AssetClassListTickerTypes(val value: kotlin.String) {
         @Json(name = "stocks") stocks("stocks"),
         @Json(name = "options") options("options"),
         @Json(name = "crypto") crypto("crypto"),
         @Json(name = "fx") fx("fx"),
         @Json(name = "indices") indices("indices");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter locale
     */
     enum class LocaleListTickerTypes(val value: kotlin.String) {
         @Json(name = "us") us("us"),
         @Json(name = "global") global("global");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v3/reference/tickers/types
     * Ticker Types
     * List all ticker types that Polygon.io has.
     * @param assetClass Filter by asset class. (optional)
     * @param locale Filter by locale. (optional)
     * @return ListTickerTypes200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listTickerTypes(assetClass: AssetClassListTickerTypes? = null, locale: LocaleListTickerTypes? = null) : ListTickerTypes200Response {
        val localVarResponse = listTickerTypesWithHttpInfo(assetClass = assetClass, locale = locale)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListTickerTypes200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v3/reference/tickers/types
     * Ticker Types
     * List all ticker types that Polygon.io has.
     * @param assetClass Filter by asset class. (optional)
     * @param locale Filter by locale. (optional)
     * @return ApiResponse<ListTickerTypes200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listTickerTypesWithHttpInfo(assetClass: AssetClassListTickerTypes?, locale: LocaleListTickerTypes?) : ApiResponse<ListTickerTypes200Response?> {
        val localVariableConfig = listTickerTypesRequestConfig(assetClass = assetClass, locale = locale)

        return request<Unit, ListTickerTypes200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listTickerTypes
     *
     * @param assetClass Filter by asset class. (optional)
     * @param locale Filter by locale. (optional)
     * @return RequestConfig
     */
    fun listTickerTypesRequestConfig(assetClass: AssetClassListTickerTypes?, locale: LocaleListTickerTypes?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (assetClass != null) {
                    put("asset_class", listOf(assetClass.value))
                }
                if (locale != null) {
                    put("locale", listOf(locale.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v3/reference/tickers/types",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter type
     */
     enum class TypeListTickers(val value: kotlin.String) {
         @Json(name = "CS") cS("CS"),
         @Json(name = "ADRC") aDRC("ADRC"),
         @Json(name = "ADRP") aDRP("ADRP"),
         @Json(name = "ADRR") aDRR("ADRR"),
         @Json(name = "UNIT") uNIT("UNIT"),
         @Json(name = "RIGHT") rIGHT("RIGHT"),
         @Json(name = "PFD") pFD("PFD"),
         @Json(name = "FUND") fUND("FUND"),
         @Json(name = "SP") sP("SP"),
         @Json(name = "WARRANT") wARRANT("WARRANT"),
         @Json(name = "INDEX") iNDEX("INDEX"),
         @Json(name = "ETF") eTF("ETF"),
         @Json(name = "ETN") eTN("ETN"),
         @Json(name = "OS") oS("OS"),
         @Json(name = "GDR") gDR("GDR"),
         @Json(name = "OTHER") oTHER("OTHER"),
         @Json(name = "NYRS") nYRS("NYRS"),
         @Json(name = "AGEN") aGEN("AGEN"),
         @Json(name = "EQLK") eQLK("EQLK"),
         @Json(name = "BOND") bOND("BOND"),
         @Json(name = "ADRW") aDRW("ADRW"),
         @Json(name = "BASKET") bASKET("BASKET"),
         @Json(name = "LT") lT("LT");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter market
     */
     enum class MarketListTickers(val value: kotlin.String) {
         @Json(name = "stocks") stocks("stocks"),
         @Json(name = "crypto") crypto("crypto"),
         @Json(name = "fx") fx("fx"),
         @Json(name = "otc") otc("otc"),
         @Json(name = "indices") indices("indices");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderListTickers(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortListTickers(val value: kotlin.String) {
         @Json(name = "ticker") ticker("ticker"),
         @Json(name = "name") nameEnum("name"),
         @Json(name = "market") market("market"),
         @Json(name = "locale") locale("locale"),
         @Json(name = "primary_exchange") primaryExchange("primary_exchange"),
         @Json(name = "type") type("type"),
         @Json(name = "currency_symbol") currencySymbol("currency_symbol"),
         @Json(name = "currency_name") currencyName("currency_name"),
         @Json(name = "base_currency_symbol") baseCurrencySymbol("base_currency_symbol"),
         @Json(name = "base_currency_name") baseCurrencyName("base_currency_name"),
         @Json(name = "cik") cik("cik"),
         @Json(name = "composite_figi") compositeFigi("composite_figi"),
         @Json(name = "share_class_figi") shareClassFigi("share_class_figi"),
         @Json(name = "last_updated_utc") lastUpdatedUtc("last_updated_utc"),
         @Json(name = "delisted_utc") delistedUtc("delisted_utc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v3/reference/tickers
     * Tickers
     * Query all ticker symbols which are supported by Polygon.io. This API currently includes Stocks/Equities, Indices, Forex, and Crypto.
     * @param ticker Specify a ticker symbol. Defaults to empty string which queries all tickers. (optional)
     * @param type Specify the type of the tickers. Find the types that we support via our [Ticker Types API](https://polygon.io/docs/stocks/get_v3_reference_tickers_types). Defaults to empty string which queries all types. (optional)
     * @param market Filter by market type. By default all markets are included. (optional)
     * @param exchange Specify the primary exchange of the asset in the ISO code format. Find more information about the ISO codes [at the ISO org website](https://www.iso20022.org/market-identifier-codes). Defaults to empty string which queries all exchanges. (optional)
     * @param cusip Specify the CUSIP code of the asset you want to search for. Find more information about CUSIP codes [at their website](https://www.cusip.com/identifiers.html#/CUSIP). Defaults to empty string which queries all CUSIPs.  Note: Although you can query by CUSIP, due to legal reasons we do not return the CUSIP in the response. (optional)
     * @param cik Specify the CIK of the asset you want to search for. Find more information about CIK codes [at their website](https://www.sec.gov/edgar/searchedgar/cik.htm). Defaults to empty string which queries all CIKs. (optional)
     * @param date Specify a point in time to retrieve tickers available on that date. Defaults to the most recent available date. (optional)
     * @param search Search for terms within the ticker and/or company name. (optional)
     * @param active Specify if the tickers returned should be actively traded on the queried date. Default is true. (optional)
     * @param tickerGte Range by ticker. (optional)
     * @param tickerGt Range by ticker. (optional)
     * @param tickerLte Range by ticker. (optional)
     * @param tickerLt Range by ticker. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 100 and max is 1000. (optional, default to 100)
     * @param sort Sort field used for ordering. (optional, default to ticker)
     * @return ListTickers200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listTickers(ticker: kotlin.String? = null, type: TypeListTickers? = null, market: MarketListTickers? = null, exchange: kotlin.String? = null, cusip: kotlin.String? = null, cik: kotlin.String? = null, date: java.time.LocalDate? = null, search: kotlin.String? = null, active: kotlin.Boolean? = null, tickerGte: kotlin.String? = null, tickerGt: kotlin.String? = null, tickerLte: kotlin.String? = null, tickerLt: kotlin.String? = null, order: OrderListTickers? = null, limit: kotlin.Int? = 100, sort: SortListTickers? = SortListTickers.ticker) : ListTickers200Response {
        val localVarResponse = listTickersWithHttpInfo(ticker = ticker, type = type, market = market, exchange = exchange, cusip = cusip, cik = cik, date = date, search = search, active = active, tickerGte = tickerGte, tickerGt = tickerGt, tickerLte = tickerLte, tickerLt = tickerLt, order = order, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListTickers200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v3/reference/tickers
     * Tickers
     * Query all ticker symbols which are supported by Polygon.io. This API currently includes Stocks/Equities, Indices, Forex, and Crypto.
     * @param ticker Specify a ticker symbol. Defaults to empty string which queries all tickers. (optional)
     * @param type Specify the type of the tickers. Find the types that we support via our [Ticker Types API](https://polygon.io/docs/stocks/get_v3_reference_tickers_types). Defaults to empty string which queries all types. (optional)
     * @param market Filter by market type. By default all markets are included. (optional)
     * @param exchange Specify the primary exchange of the asset in the ISO code format. Find more information about the ISO codes [at the ISO org website](https://www.iso20022.org/market-identifier-codes). Defaults to empty string which queries all exchanges. (optional)
     * @param cusip Specify the CUSIP code of the asset you want to search for. Find more information about CUSIP codes [at their website](https://www.cusip.com/identifiers.html#/CUSIP). Defaults to empty string which queries all CUSIPs.  Note: Although you can query by CUSIP, due to legal reasons we do not return the CUSIP in the response. (optional)
     * @param cik Specify the CIK of the asset you want to search for. Find more information about CIK codes [at their website](https://www.sec.gov/edgar/searchedgar/cik.htm). Defaults to empty string which queries all CIKs. (optional)
     * @param date Specify a point in time to retrieve tickers available on that date. Defaults to the most recent available date. (optional)
     * @param search Search for terms within the ticker and/or company name. (optional)
     * @param active Specify if the tickers returned should be actively traded on the queried date. Default is true. (optional)
     * @param tickerGte Range by ticker. (optional)
     * @param tickerGt Range by ticker. (optional)
     * @param tickerLte Range by ticker. (optional)
     * @param tickerLt Range by ticker. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 100 and max is 1000. (optional, default to 100)
     * @param sort Sort field used for ordering. (optional, default to ticker)
     * @return ApiResponse<ListTickers200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listTickersWithHttpInfo(ticker: kotlin.String?, type: TypeListTickers?, market: MarketListTickers?, exchange: kotlin.String?, cusip: kotlin.String?, cik: kotlin.String?, date: java.time.LocalDate?, search: kotlin.String?, active: kotlin.Boolean?, tickerGte: kotlin.String?, tickerGt: kotlin.String?, tickerLte: kotlin.String?, tickerLt: kotlin.String?, order: OrderListTickers?, limit: kotlin.Int?, sort: SortListTickers?) : ApiResponse<ListTickers200Response?> {
        val localVariableConfig = listTickersRequestConfig(ticker = ticker, type = type, market = market, exchange = exchange, cusip = cusip, cik = cik, date = date, search = search, active = active, tickerGte = tickerGte, tickerGt = tickerGt, tickerLte = tickerLte, tickerLt = tickerLt, order = order, limit = limit, sort = sort)

        return request<Unit, ListTickers200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listTickers
     *
     * @param ticker Specify a ticker symbol. Defaults to empty string which queries all tickers. (optional)
     * @param type Specify the type of the tickers. Find the types that we support via our [Ticker Types API](https://polygon.io/docs/stocks/get_v3_reference_tickers_types). Defaults to empty string which queries all types. (optional)
     * @param market Filter by market type. By default all markets are included. (optional)
     * @param exchange Specify the primary exchange of the asset in the ISO code format. Find more information about the ISO codes [at the ISO org website](https://www.iso20022.org/market-identifier-codes). Defaults to empty string which queries all exchanges. (optional)
     * @param cusip Specify the CUSIP code of the asset you want to search for. Find more information about CUSIP codes [at their website](https://www.cusip.com/identifiers.html#/CUSIP). Defaults to empty string which queries all CUSIPs.  Note: Although you can query by CUSIP, due to legal reasons we do not return the CUSIP in the response. (optional)
     * @param cik Specify the CIK of the asset you want to search for. Find more information about CIK codes [at their website](https://www.sec.gov/edgar/searchedgar/cik.htm). Defaults to empty string which queries all CIKs. (optional)
     * @param date Specify a point in time to retrieve tickers available on that date. Defaults to the most recent available date. (optional)
     * @param search Search for terms within the ticker and/or company name. (optional)
     * @param active Specify if the tickers returned should be actively traded on the queried date. Default is true. (optional)
     * @param tickerGte Range by ticker. (optional)
     * @param tickerGt Range by ticker. (optional)
     * @param tickerLte Range by ticker. (optional)
     * @param tickerLt Range by ticker. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 100 and max is 1000. (optional, default to 100)
     * @param sort Sort field used for ordering. (optional, default to ticker)
     * @return RequestConfig
     */
    fun listTickersRequestConfig(ticker: kotlin.String?, type: TypeListTickers?, market: MarketListTickers?, exchange: kotlin.String?, cusip: kotlin.String?, cik: kotlin.String?, date: java.time.LocalDate?, search: kotlin.String?, active: kotlin.Boolean?, tickerGte: kotlin.String?, tickerGt: kotlin.String?, tickerLte: kotlin.String?, tickerLt: kotlin.String?, order: OrderListTickers?, limit: kotlin.Int?, sort: SortListTickers?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
                if (type != null) {
                    put("type", listOf(type.value))
                }
                if (market != null) {
                    put("market", listOf(market.value))
                }
                if (exchange != null) {
                    put("exchange", listOf(exchange.toString()))
                }
                if (cusip != null) {
                    put("cusip", listOf(cusip.toString()))
                }
                if (cik != null) {
                    put("cik", listOf(cik.toString()))
                }
                if (date != null) {
                    put("date", listOf(parseDateToQueryString(date)))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
                if (tickerGte != null) {
                    put("ticker.gte", listOf(tickerGte.toString()))
                }
                if (tickerGt != null) {
                    put("ticker.gt", listOf(tickerGt.toString()))
                }
                if (tickerLte != null) {
                    put("ticker.lte", listOf(tickerLte.toString()))
                }
                if (tickerLt != null) {
                    put("ticker.lt", listOf(tickerLt.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v3/reference/tickers",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
